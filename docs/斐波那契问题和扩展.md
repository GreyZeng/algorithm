## 斐波那契问题和扩展
LeetCode_0509_FibonacciNumber.java
[TODO]LintCode_0949_FibonacciNumberII.java

斐波那契数列的暴力解法是O(2^n)

如果某个递归，除了初始项之外，具有如下的形式
F(N) = C1 * F(N) + C2 * F(N-1) + … + Ck * F(N-k) ( C1…Ck 和k都是常数)

并且这个递归的表达式是严格的、不随条件转移的
那么都存在类似斐波那契数列的优化，时间复杂度都能优化成O(logN)
|F2,F3| * | a,b| = |F3,F4|
          | c,d|

a = 0, b,c,d = 1

如果存在条件转移，那就用不了，例如：Code06_ConvertToLetterString

某个数的N次方的logN算法
LintCode_0428_PowXN.java
N无论正负先转换成正数abs(N)，如果N是系统最小值，那么先算abs(N+1),  
LintCode_0428_PowXN.java

矩阵的乘法/N次幂



第一年农场有1只成熟的母牛A，往后的每年：
1）每一只成熟的母牛都会生一只母牛
2）每一只新出生的母牛都在出生的第三年成熟
3）每一只母牛永远不会死
返回N年后牛的数量
TIPS : F(N) = F(N-1) + F(N-3) （最后F(N-3)表示三阶问题，同理，F(N) = F(N-1) + ... + F(N-K)
表示某个K阶问题
NowCoder_Cow.java
假设母牛10年后会死，表达式：
F(N) = F(N-1) + F(N-3) - F(N-10)
N年后牛的数量等于，去年牛的数量，和3年前牛的数量（因为3年后牛可以生小牛）

