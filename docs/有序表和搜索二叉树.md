## 有序表
TreeMap

一个有序表使用的例子

NowCoder_FindJob.java
每种工作有难度和报酬，规定如下
class Job {
public int money;// 该工作的报酬
public int hard; // 该工作的难度
}
给定一个Job类型的数组jobarr，表示所有岗位，每个岗位都可以提供任意份工作
选工作的标准是在难度不超过自身能力值的情况下，选择报酬最高的岗位
给定一个int类型的数组arr，表示所有人的能力
返回int类型的数组，表示每个人按照标准选工作后所能获得的最高报酬

排序
难度一样，只保留最高报酬的
难度更大，报酬却更小的也删掉
然后加入有序表，找离自己最近的最大的值

## 搜索二叉树

任何一个节点，左树都比这个节点小，右数都比这个节点大，经典二叉树是没有重复值的，有重复值就压在一起

构造搜索二叉树，
比节点大，就往右边滑，滑到空就把节点加上
比节点小，就往左边滑，滑到空就把节点加上


搜索二叉树的增删改，改的话，可以转换成删再增

删
1. 未找到，直接返回
2. 如果找到，既没有左孩子，也没有右孩子，直接删掉
3. 如果找到，有右无左，右孩子提拔
4. 如果找到，有左无右，左孩子提拔
5. 如果找到，有左有右，则找右树的最左节点（后继节点），右树最左节点的右孩子直接给新的右树最左节点

注意delete方法在删除的时候，需要考虑后继节点是直接的右孩子还是距离需要删除的节点有一定距离的节点！

搜索二叉树的最大问题是：输入状况决定性能，如果输入状况比较好，树是平衡的，输入状况比较差，树不是平衡的，
严格的平衡性指的是：任何一个节点左树右树高度差不超过1

所以需要引入自平衡的功能
--> 平衡搜索二叉树


左旋和右旋要针对具体节点说，一般是针对根节点

TreeMap O(logN)
HashMap O(1)

用TreeMap必须保证key要可排序

TreeMap的底层是平衡搜索二叉树, O(logN)
 
平衡搜索二叉树要满足：
1. key按序组织
2. 增删改O(logN)

AVL, SBT, 红黑树都是平衡搜索二叉树的一种具体实现
AVL：最严格的平衡性 左右高度只差绝对值小于2
SBT: 任何一个叔节点节点数不少于他的侄子节点
左右树节点数的规模差不多就是2倍+1
红黑树：
1）节点要不就是红，要不就是黑
2) 头黑，叶黑
3）红节点的子一定是黑 --> 红和红不能相邻 --> 最长就是黑红交替，最短就是全黑
4) 从任何一个点到到他的子， 所有路径，黑节点的数量一样多 --> 长和短不能超过2倍以上。
插入时，违规的情况有五种，删除的时候，违规的情况有八种
以上三种树都是通过左旋右旋操作来调整。

平衡性调整
增加节点：只查父节点平衡性是否被破坏
删除节点：
如果被删除节点是叶子节点，只查父节点平衡性是否被破坏
如果被删除节点有右孩子，则右孩子顶替被删除节点，然后查父节点平衡性是否被破坏
如果被删除节点有左右孩子，则将后继节点代替被删除，则从后继节点的父节点开始检查父节点平衡性是否被破坏

AVL树，SBT，红黑树，查询平衡性都是一样的规则，只有调整平衡性调整的时候细节有些不一样

AVL树，SBT，红黑树怎么调整平衡性？
增加：插入位置的父节点一直往上查，看下每个节点是否违规
删除：删除位置的父节点一直往上查，看下每个节点是否违规，如果删除节点包含左右孩子，那么必须从这个节点的后继节点往上一直查


AVL查违规行为LL，LR，RL，RR
如果：左右高度只差绝对值小于2 说明不违规
如果左右高度差大于1，右高则肯定是RR或者RL，左高则LL或者LR
因为左树的左边不平就是LL，因为左边的右边不平的话，就是LR，右边同理

LL调整-X右旋即可，RR同理
LR，RL就是将底下的孙节点上到顶部来
举例：假设二叉树
[x,a,b,L,C,T,S,null,null,甲，乙]
LR调整第一步，a左旋
LR调整第二步，x右旋

如果左边孩子的左树和右树，必须要做LL的调整，删掉右树的一个高度后，必须做LL调整，不能做LR调整
见：[a,b,5,6,c,null,null,4,5]



SBT根据不同key的数量查违规行为LL,LR,RL,RR

如果节点X
左孩子节点个数 < [X.R.L]个数 RL
左孩子节点个数 < [X.R.R]个数 RR
假设树为：[X(20),b(13),c(6),d(7),e(5)]
右子节点个数 < [X.L.L]个数 LL --> 右旋X,递归X，递归b
假设树为：[X(20),a(13),b(6),c(5),d(7),null,null,T(3),S(3)]
右孩子节点个数 < [X.L.R]个数 LR --> d左旋，X右旋，递归调用m(a),m(x),m(d) (m(a)和m(x)执行顺序没关系，m(d)一定要最后执行)

SBT在删除节点的时候，不做平衡性调整，只在add节点的时候做平衡性调整，因为有递归行为

Code_0061_SizeBalancedTreeMap.java
Code_0062_SizeBalancedTreeMap.java


跳表 可以实现有序表的所有功能
首位置是null，弃而不用，标记为最小的key
Node有多个往外指的指针

先看跳表的add操作
有多少层指针
至少一层 
Random 0 +一条
Random 1 停止

找到大于等于当前值的最早出现的位置
高层往右，右到不能再右往下跳

每次都从高层开始找

要手写SkipListMap
floorKey
cellingKey

底层更新频繁，调整代价高的，比如数据库的底层实现：B+树

Redis为什么选跳表而不是AVL树或者SBT红黑树来实现，因为跳表方便序列化。


eg：
LeetCode 632

[1,5,9,13]
[4,12]
[8,12]
[0,7,8,9]
找到一个最窄区间[a,b],如果有多个最窄区间且开始位置最小的那个区间，使得这个区间内至少包含每个数组的一个数
tips:
用有序表
第一次把每个数组的第0个位置的值放有序表
然后弹出一个区间（这个区间肯定包括几个数组的数），记录一个min
 有序表中弹出最小的，这个最小值来自于哪个数组，就再把这个数组的下一个加入有序表
 周而复始
 可以封装每个数组的元素（在哪个数组的哪个位置）
 
 
 最窄的且开始位置最小的区间就是答案

需要改写有序表的题目一
给定一个数组arr，和两个整数a和b（a<=b）
求arr中有多少个子数组，累加和在[a,b]这个范围上
返回达标的子数组数量

子数组必须以i位置结尾，有多少是落在[a,b], 就可以通过前缀和
0 - 0
0 - 1
...
0 - i-1 
有多少个累加和落在 [sum - a, sum -b] 上
前缀和加入到有序表

有序表提供add(num) [可以加入重复数字] 和 search(L,R)【L...R中有多少个，其实只需要提供<num的数有多少个这个接口加工而来】 两个接口即可

需要改写有序表的题目二
有一个滑动窗口：

1）L是滑动窗口最左位置、R是滑动窗口最右位置，一开始LR都在数组左侧
2）任何一步都可能R往右动，表示某个数进了窗口
3）任何一步都可能L往右动，表示某个数出了窗口

想知道每一个窗口状态的中位数（严格中位数，如果是偶数，要返回上下中位数之和除以2）
tips：
有序表找第K小


改写有序表的题目核心点

1）分析增加什么数据项可以支持题目

2）有序表一定要保持内部参与排序的key不重复

3）增加这个数据项了，在平衡性调整时，保证这个数据项也能更新正确

4）做到上面3点，剩下就是搜索二叉树怎么实现你想要的接口的问题了






