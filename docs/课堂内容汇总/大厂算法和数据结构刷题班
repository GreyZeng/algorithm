大厂高频算法和数据结构面试题

01 大厂高频算法和数据结构面试题1

题目：

给定一个有序数组arr，代表坐落在X轴上的点，给定一个正数K，代表绳子的长度，返回绳子最多压中几个点？
即使绳子边缘处盖住点也算盖住

给定一个文件目录的路径，写一个函数统计这个目录下所有的文件数量并返回，隐藏文件也算，但是文件夹不算

给定一个非负整数num，如何不用循环语句，返回>=num，并且离num最近的，2的某次方

一个数组中只有两种字符'G'和'B'，可以让所有的G都放在左侧，所有的B都放在右侧
或者可以让所有的G都放在右侧，所有的B都放在左侧，但是只能在相邻字符之间进行交换操作，返回至少需要交换几次

给定一个二维数组matrix，你可以从任何位置出发，走向上、下、左、右四个方向，返回能走出来的最长的递增链长度

给定两个非负数组x和hp，长度都是N，再给定一个正数range
x有序，x[i]表示i号怪兽在x轴上的位置
hp[i]表示i号怪兽的血量
再给定一个正数range，表示如果法师释放技能的范围长度
被打到的每只怪兽损失1点血量。返回要把所有怪兽血量清空，至少需要释放多少次AOE技能？

给定一个数组arr，你可以在每个数字之前决定+或者-但是必须所有数字都参与，再给定一个数target
请问最后算出target的方法数



02 大厂高频算法和数据结构面试题2

题目：

给定数组hard和money，长度都为N，hard[i]表示i号工作的难度， money[i]表示i号工作的收入
给定数组ability，长度都为M，ability[j]表示j号人的能力，每一号工作，都可以提供无数的岗位，难度和收入都一样
但是人的能力必须>=这份工作的难度，才能上班。返回一个长度为M的数组ans，ans[j]表示j号人能获得的最好收入

贩卖机只支持硬币支付，且收退都只支持10 ，50，100三种面额
一次购买只能出一瓶可乐，且投钱和找零都遵循优先使用大钱的原则
需要购买的可乐数量是m，其中手头拥有的10、50、100的数量分别为a、b、c，可乐的价格是x(x是10的倍数)
请计算出需要投入硬币次数

已知一个消息流会不断地吐出整数1~N，但不一定按照顺序依次吐出，如果上次打印的序号为i， 那么当i+1出现时
请打印i+1及其之后接收过的并且连续的所有数，直到1~N全部接收并打印完，请设计这种接收并打印的结构

现有司机N*2人，调度中心会将所有司机平分给A、B两区域，i号司机去A可得收入为income[i][0]，去B可得收入为income[i][1]
返回能使所有司机总收入最高的方案是多少钱?

设计有setAll功能的哈希表，put、get、setAll方法，时间复杂度O(1)

给定一个数组arr，只能对arr中的一个子数组排序，但是想让arr整体都有序，返回满足这一设定的子数组中最短的是多长



03 大厂高频算法和数据结构面试题3

题目：

求一个字符串中，最长无重复字符子串长度

只由小写字母（a~z）组成的一批字符串，都放在字符类型的数组String[] arr中，如果其中某两个字符串所含有的字符种类完全一样
就将两个字符串算作一类，比如baacbba和bac就算作一类，返回arr中有多少类

给定一个只有0和1组成的二维数组，返回边框全是1（内部无所谓）的最大正方形面积

给定一个数组arr，代表每个人的能力值。再给定一个非负数k，如果两个人能力差值正好为k，那么可以凑在一起比赛
一局比赛只有两个人，返回最多可以同时有多少场比赛

给定一个正数数组arr，代表若干人的体重，再给定一个正数limit，表示所有船共同拥有的载重量，每艘船最多坐两人，且不能超过载重
想让所有的人同时过河，并且用最好的分配方法让船尽量少，返回最少的船数
Leetcode链接 : https://leetcode.com/problems/boats-to-save-people/

给定整数数组nums和目标值goal，需要从nums中选出一个子序列，使子序列元素总和最接近goal
也就是说如果子序列元素和为sum ，需要最小化绝对差abs(sum - goal)，返回 abs(sum - goal)可能的最小值
注意数组的子序列是通过移除原始数组中的某些元素（可能全部或无）而形成的数组。

电子游戏“辐射4”中，任务“通向自由”要求玩家到达名为“Freedom Trail Ring”的金属表盘，并使用表盘拼写特定关键词才能开门
给定一个字符串 ring，表示刻在外环上的编码；给定另一个字符串 key，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的最少步数
最初，ring 的第一个字符与12:00方向对齐。您需要顺时针或逆时针旋转 ring 以使 key 的一个字符在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完 key 中的所有字符
旋转 ring 拼出 key 字符 key[i] 的阶段中：
您可以将 ring 顺时针或逆时针旋转一个位置，计为1步。旋转的最终目的是将字符串 ring 的一个字符与 12:00 方向对齐，并且这个字符必须等于字符 key[i] 。
如果字符 key[i] 已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作 1 步。按完之后，您可以开始拼写 key 的下一个字符（下一阶段）, 直至完成所有拼写。
Leetcode题目：https://leetcode.com/problems/freedom-trail/

给定三个参数，二叉树的头节点head，树上某个节点target，正数K。从target开始，可以向上走或者向下走，返回与target的距离是K的所有节点



04 大厂高频算法和数据结构面试题4

题目：

数组为{3, 2, 2, 3, 1}，查询为(0, 3, 2)，意思是在数组里下标0~3这个范围上，有几个？答案返回2
假设给你一个数组arr，对这个数组的查询非常频繁，且都给了查询组，请返回所有查询的结果

返回一个数组中子数组最大累加和

返回一个二维数组中子矩阵最大累加和

返回一个数组中所选数字不能相邻的情况下最大子序列累加和

老师想给孩子们分发糖果，有N个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分
你需要按照以下要求，帮助老师给这些孩子分发糖果：
每个孩子至少分配到 1 个糖果。
评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。
那么这样下来，返回老师至少需要准备多少颗糖果
进阶：在原来要求的基础上，增加一个要求，相邻的孩子间如果分数一样，分的糖果数必须一样，返回至少需要准备多少颗糖果

生成长度为size的达标数组，什么叫达标？对于任意的i<k<j，满足[i]+[j]!=[k]*2。给定一个正数size，返回长度为size的达标数组

给定三个字符串s1、s2、s3，请你帮忙验证s3是否是由s1和s2交错组成的
Leetcode题目：https://leetcode.com/problems/interleaving-string/

大楼轮廓线问题
Leetcode题目：https://leetcode.com/problems/the-skyline-problem/



05 大厂高频算法和数据结构面试题5

题目：

已知一棵搜索二叉树上没有重复值的节点，现在有一个数组arr，是这棵搜索二叉树先序遍历的结果，请根据arr生成整棵树并返回头节点

如果一个节点X，它左树结构和右树结构完全一样，那么我们说以X为头的树是相等树，给定一棵二叉树的头节点head，返回head整棵树上有多少棵相等子树

编辑距离问题

给定两个字符串s1和s2，问s2最少删除多少字符可以成为s1的子串？比如 s1 = "abcde"，s2 = "axbc"，s2删掉'x'即可，返回1



06 大厂高频算法和数据结构面试题6

数组中所有数都异或起来的结果，叫做异或和。给定一个数组arr，返回arr的最大子数组异或和

数组中所有数都异或起来的结果，叫做异或和。给定一个数组arr，想知道arr中哪两个数的异或结果最大，返回最大的异或结果
Leetcode题目：https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/

给定一个非负整数组成的数组nums。另有一个查询数组queries，其中queries[i]=[xi, mi]
第i个查询的答案是xi和任何nums数组中不超过mi的元素按位异或（XOR）得到的最大值
换句话说，答案是max(nums[j] XOR xi)，其中所有j均满足nums[j]<= mi。如果nums中的所有元素都大于mi，最终答案就是-1
返回一个整数数组answer作为查询的答案，其中answer.length==queries.length且answer[i]是第i个查询的答案
Leetcode题目：https://leetcode.com/problems/maximum-xor-with-an-element-from-array/

数组中所有数都异或起来的结果，叫做异或和。给定一个数组arr，可以任意切分成若干个不相交的子数组。其中一定存在一种最优方案，使得切出异或和为0的子数组最多，返回这个最多数量

Nim博弈，给定一个正数数组arr，先手和后手每次可以选择在一个位置拿走若干值，这个值要大于0，但是要小于该处的剩余，谁最先拿空arr谁赢，根据arr返回谁赢



07 大厂高频算法和数据结构面试题7

给定一个非负数组成的数组，长度一定大于1，想知道数组中哪两个数&的结果最大，返回这个最大结果。要求时间复杂度O(N)，额外空间复杂度O(1)

给定一个二叉树，我们在树的节点上安装摄像头，节点上的每个摄影头都可以监视其父对象、自身及其直接子对象，计算监控树的所有节点所需的最小摄像头数量

给定一个数组arr，返回如果排序之后（注意是如果排序），相邻两数的最大差值。要求时间复杂度O(N)，不能使用非基于比较的排序

给定一个有序数组arr，其中值可能为正、负、0。返回arr中每个数都平方之后不同的结果有多少种？
给定一个数组arr，先递减然后递增，返回arr中有多少个不同的数字？

假设所有字符都是小写字母，大字符串是str，arr是去重的单词表, 每个单词都不是空字符串且可以使用任意次。使用arr中的单词有多少种拼接str的方式，返回方法数。

String str, int K, String[] parts, int[] record
Parts和records的长度一样长，str一定要分割成k个部分，分割出来的每部分在parts里必须得有，那一部分的得分在record里，请问str切成k个部分，返回最大得分



08 大厂高频算法和数据结构面试题8

给定一个字符串str，str表示一个公式，公式里可能有整数、加减乘除符号和左右括号。返回公式的计算结果
难点在于括号可能嵌套很多层，str="48*((70-65)-43)+8*1"，返回-1816。str="3+1*4"，返回7。str="3+(1*4)"，返回7。
1，可以认为给定的字符串一定是正确的公式，即不需要对str做公式有效性检查
2，如果是负数，就需要用括号括起来，比如"4*(-3)"但如果负数作为公式的开头或括号部分的开头，则可以没有括号，比如"-3*4"和"(-3*4)"都是合法的
3，不用考虑计算过程中会发生溢出的情况。

给定n个非负整数a1，a2，...an，每个数代表坐标中的一个点 (i, ai)。在坐标内画n条垂直线
垂直线i的两个端点分别为(i, ai)和(i, 0)，找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水
Leetcode题目：https://leetcode.com/problems/container-with-most-water/

给定一个char[][] matrix，也就是char类型的二维数组，再给定一个字符串word，
可以从任何一个某个位置出发，可以走上、下、左、右，能不能找到word？
 char[][] m = {  { 'a', 'b', 'z' }, 
                 { 'c', 'd', 'o' }, 
                 { 'f', 'e', 'o' } }
设定1：可以走重复路的情况下，返回能不能找到
比如，word = "zoooz"，是可以找到的，z -> o -> o -> o -> z，因为允许走一条路径中已经走过的字符
设定2：不可以走重复路的情况下，返回能不能找到
比如，word = "zoooz"，是不可以找到的，因为允许走一条路径中已经走过的字符不能重复走 

给定一个矩阵matrix，值有正、负、0。蛇可以空降到最左列的任何一个位置，初始增长值是0。蛇每一步可以选择右上、右、右下三个方向的任何一个前进
沿途的数字累加起来，作为增长值；但是蛇一旦增长值为负数，就会死去。蛇有一种能力，可以使用一次：把某个格子里的数变成相反数
蛇可以走到任何格子的时候停止，返回蛇能获得的最大增长值



09 大厂高频算法和数据结构面试题9

题目：

给定一个数组arr，长度为N，arr中的值不是0就是1。arr[i]表示第i栈灯的状态，0代表灭灯，1代表亮灯
每一栈灯都有开关，但是按下i号灯的开关，会同时改变i-1、i、i+1栈灯的状态
问题一：如果N栈灯排成一条直线,请问最少按下多少次开关？
i为中间位置时，i号灯的开关能影响i-1、i和i+1
0号灯的开关只能影响0和1位置的灯
N-1号灯的开关只能影响N-2和N-1位置的灯
问题二：如果N栈灯排成一个圈,请问最少按下多少次开关,能让灯都亮起来
i为中间位置时，i号灯的开关能影响i-1、i和i+1
0号灯的开关能影响N-1、0和1位置的灯
N-1号灯的开关能影响N-2、N-1和0位置的灯

给你一个由若干括号和字母组成的字符串 s ，删除最小数量的无效括号，使得输入的字符串有效。返回所有可能的结果。答案可以按任意顺序返回
Leetcode题目：https://leetcode.com/problems/remove-invalid-parentheses/

给定一个数组arr，求最长递增子序列长度
Leetcode题目：https://leetcode.com/problems/longest-increasing-subsequence

给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度
当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样
请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）
注意：不允许旋转信封

定义何为step sum？比如680，680 + 68 + 6 = 754，680的step sum叫754。给定一个正数num，判断它是不是某个数的step sum



10 大厂高频算法和数据结构面试题10

题目：

给你一个非负整数数组 nums ，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。

Top K Frequent Words II
Implement three methods for Topk Class:
TopK(k). The constructor.
add(word). Add a new word.
topk(). Get the current top k frequent words.
LintCode题目：https://www.lintcode.com/problem/550/

给出两个整数n和k，找出所有包含从1到n的数字，且恰好拥有k个逆序对的不同的数组的个数
逆序对的定义如下：对于数组的第i个和第 j个元素，如果满i < j且 a[i] > a[j]，则其为一个逆序对，否则不是
由于答案可能很大，只需要返回 答案 mod 10^9 + 7 的值
Leetcode题目：https://leetcode.com/problems/k-inverse-pairs-array/

给定一棵搜索二叉树头节点，转化成首尾相接的有序双向链表（节点都有两个方向的指针）

给定一个布尔表达式和一个期望的布尔结果 result，布尔表达式由 0 (false)、1 (true)、& (AND)、 | (OR) 和 ^ (XOR) 符号组成。实现一个函数，算出有几种可使该表达式得出 result 值的括号方法。
Leetcode题目：https://leetcode-cn.com/problems/boolean-evaluation-lcci/



11 大厂高频算法和数据结构面试题11

题目：

问题一：一个字符串至少需要添加多少个字符能整体变成回文串
问题二：返回问题一的其中一种添加结果
问题三：返回问题一的所有添加结果

问题一：一个字符串至少要切几刀能让切出来的子串都是回文串
问题二：返回问题一的其中一种划分结果
问题三：返回问题一的所有划分结果



12 大厂高频算法和数据结构面试题12

题目：

给定长度为m的字符串aim，以及一个长度为n的字符串str，问能否在str中找到一个长度为m的连续子串，
使得这个子串刚好由aim的m个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1

给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数
进阶，在两个都有序的数组中找整体第K小的数，可以做到O(log(Min(M,N)))

给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。请你设计并实现时间复杂度为 O(n) 的算法解决此问题。

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖整个字符串s的，而不是部分字符串。
返回p能否匹配s



13 大厂高频算法和数据结构面试题13

题目：

谷歌面试题扩展版，面值为1~N的牌组成一组，每次你从组里等概率的抽出1~N中的一张，下次抽会换一个新的组，有无限组
当累加和<a时，你将一直抽牌；当累加和>=a且<b时，你将获胜；当累加和>=b时，你将失败
返回获胜的概率，给定的参数为N，a，b

假设有 n 台超级洗衣机放在同一排上。开始的时候，每台洗衣机内可能有一定量的衣服，也可能是空的
在每一步操作中，你可以选择任意 m （1 ≤ m ≤ n） 台洗衣机，与此同时将每台洗衣机的一件衣服送到相邻的一台洗衣机
给定一个非负整数数组代表从左至右每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的最少的操作步数
如果不能使每台洗衣机中衣物的数量相等，则返回-1
Leetcode题目：https://leetcode.com/problems/super-washing-machines/

旋变字符串
使用下面描述的算法可以扰乱字符串 s 得到字符串 t ：
如果字符串的长度为 1 ，算法停止
如果字符串的长度 > 1 ，执行下述步骤：
在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 s ，则可以将其分成两个子字符串 x 和 y ，且满足 s = x + y 。
随机 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，s 可能是 s = x + y 或者 s = y + x 。
在 x 和 y 这两个子字符串上继续从步骤 1 开始递归执行此算法。
给你两个 长度相等 的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。如果是，返回 true ；否则，返回 false 。
Leetcode题目：https://leetcode.com/problems/scramble-string/

有一个 m x n 的二元网格，其中 1 表示砖块，0 表示空白。砖块 稳定（不会掉落）的前提是：
一块砖直接连接到网格的顶部，或者至少有一块相邻（4 个方向之一）砖块稳定不会掉落时
给你一个数组 hits ，这是需要依次消除砖块的位置。每当消除 hits[i] = (rowi, coli) 位置上的砖块时，对应位置的砖块（若存在）会消失
然后其他的砖块可能因为这一消除操作而掉落。一旦砖块掉落，它会立即从网格中消失（即，它不会落在其他稳定的砖块上）
返回一个数组 result ，其中 result[i] 表示第 i 次消除操作对应掉落的砖块数目
注意，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。
Leetcode题目：https://leetcode.com/problems/bricks-falling-when-hit/



14 大厂高频算法和数据结构面试题14

题目：

给定一个只由左括号和右括号的字符串，返回最长的有效括号子串的长度

arr中求子数组的累加和是<=K的并且是最大的，返回这个最大的累加和

从二叉树的某个节点x开始，往下子节点都要的，叫子树；在二叉树上只要能连起来的任何结构，叫子拓扑结构；
返回二叉树上满足搜索二叉树性质的、最大子拓扑结构的节点数

给定一个棵完全二叉树，返回这棵树的节点个数，要求时间复杂度小于O(树的节点数)

给定一个棵搜索二叉树的头节点head，其中有两个节点错了，交换过来就能让整棵树重新变成搜索二叉树，怎么找到并调整正确？
Leetcode题目：https://leetcode.com/problems/recover-binary-search-tree/

给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。
 


15 大厂高频算法和数据结构面试题15

题目：股票系列问题

https://leetcode.com/problems/best-time-to-buy-and-sell-stock/

https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/

https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/

https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/

https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/

https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/



16 大厂高频算法和数据结构面试题16

题目：

给定一个有正、有负、有0的数组arr，
给定一个整数k，
返回arr的子集是否能累加出k
1）正常怎么做？
2）如果arr中的数值很大，但是arr的长度不大，怎么做？

给定一个正数数组arr，
返回arr的子集不能累加出的最小正数
1）正常怎么做？
2）如果arr中肯定有1这个值，怎么做？

给定一个已排序的正整数数组 nums，和一个正整数 n 。从 [1, n] 区间内选取任意个数字补充到 nums 中，
使得 [1, n] 区间内的任何数字都可以用 nums 中某几个数字的和来表示，请输出满足上述要求的最少需要补充的数字个数

给定整数power，给定一个数组arr，给定一个数组reverse。含义如下：
arr的长度一定是2的power次方，reverse中的每个值一定都在0~power范围。
例如power = 2, arr = {3, 1, 4, 2}，reverse = {0, 1, 0, 2}
任何一个在前的数字可以和任何一个在后的数组，构成一对数。可能是升序关系、相等关系或者降序关系。
比如arr开始时有如下的降序对：(3,1)、(3,2)、(4,2)，一共3个。
接下来根据reverse对arr进行调整：
reverse[0] = 0, 表示在arr中，划分每1(2的0次方)个数一组，然后每个小组内部逆序，那么arr变成[3,1,4,2]，此时有3个逆序对。
reverse[1] = 1, 表示在arr中，划分每2(2的1次方)个数一组，然后每个小组内部逆序，那么arr变成[1,3,2,4]，此时有1个逆序对
reverse[2] = 0, 表示在arr中，划分每1(2的0次方)个数一组，然后每个小组内部逆序，那么arr变成[1,3,2,4]，此时有1个逆序对。
reverse[3] = 2, 表示在arr中，划分每4(2的2次方)个数一组，然后每个小组内部逆序，那么arr变成[4,2,3,1]，此时有5个逆序对。
所以返回[3,1,1,5]，表示每次调整之后的逆序对数量。
输入数据状况：
power的范围[0,20]
arr长度范围[1,10的7次方]
reverse长度范围[1,10的6次方]

约瑟夫环问题
给定一个链表头节点head，和一个正数m，从头开始，每次数到m就杀死当前节点，然后被杀节点的下一个节点从1开始重新数，周而复始直到只剩一个节点，返回最后的节点
Leetcode题目：https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/



17 大厂高频算法和数据结构面试题17

题目：

给定一个每一行有序、每一列也有序，整体可能无序的二维数组，再给定一个数num，返回二维数组中有没有num这个数

给定一个每一行有序、每一列也有序，整体可能无序的二维数组，再给定一个正数k，返回二维数组中第k小的数
Leetcode题目：https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/

给定一个字符串数组arr，里面都是互不相同的单词，找出所有不同的索引对(i, j)，使得列表中的两个单词，words[i] + words[j]，可拼接成回文串。
Leetcode题目：https://leetcode.com/problems/palindrome-pairs/

给定两个字符串S和T，返回S的所有子序列中有多少个子序列的字面值等于T

给定一个字符串str，返回str的所有子序列中有多少不同的字面值
Leetcode题目：https://leetcode.com/problems/distinct-subsequences-ii/



18 大厂高频算法和数据结构面试题18

题目：

给定一个数组arr，长度为N，arr中的值只有1，2，3三种
arr[i] == 1，代表汉诺塔问题中，从上往下第i个圆盘目前在左
arr[i] == 2，代表汉诺塔问题中，从上往下第i个圆盘目前在中
arr[i] == 3，代表汉诺塔问题中，从上往下第i个圆盘目前在右
那么arr整体就代表汉诺塔游戏过程中的一个状况，如果这个状况不是汉诺塔最优解运动过程中的状况，返回-1
如果这个状况是汉诺塔最优解运动过程中的状态，返回它是第几个状态

在给定的二维二进制数组 A 中，存在两座岛。（岛是由四面相连的 1 形成的一个最大组。）现在，我们可以将 0 变为 1，以使两座岛连接起来，变成一座岛。
返回必须翻转的 0 的最小数目。（可以保证答案至少是1）
Leetcode题目：https://leetcode.com/problems/shortest-bridge/

给定一个矩阵matrix，先从左上角开始，每一步只能往右或者往下走，走到右下角。然后从右下角出发，每一步只能往上或者往左走，再回到左上角。任何一个位置的数字，只能获得一遍。返回最大路径和。
输入描述:
第一行输入两个整数M和N，M,N<=200
接下来M行，每行N个整数，表示矩阵中元素
输出描述:
输出一个整数，表示最大路径和
牛客网题目：https://www.nowcoder.com/questionTerminal/8ecfe02124674e908b2aae65aad4efdf

给定两个有序数组arr1和arr2，再给定一个整数k，返回来自arr1和arr2的两个数相加和最大的前k个，两个数必须分别来自两个数组，按照降序输出
时间复杂度为O(klogk)
输入描述：
第一行三个整数N, K分别表示数组arr1, arr2的大小，以及需要询问的数
接下来一行N个整数，表示arr1内的元素
再接下来一行N个整数，表示arr2内的元素
输出描述：
输出K个整数表示答案
牛客网题目：https://www.nowcoder.com/practice/7201cacf73e7495aa5f88b223bbbf6d1



19 大厂高频算法和数据结构面试题19

题目：

LRU内存/缓存替换算法
Leetcode题目：https://leetcode.com/problems/lru-cache/

LFU内存/缓存替换算法
Leetcode题目：https://leetcode.com/problems/lfu-cache/

给定一个正数N，比如N = 13，在纸上把所有数都列出来如下：
1 2 3 4 5 6 7 8 9 10 11 12 13
可以数出1这个字符出现了6次，给定一个正数N，如果把1~N都列出来，返回1这个字符出现的多少次

你有k个非递减排列的整数列表。找到一个最小区间，使得k个列表中的每个列表至少有一个数包含在其中
我们定义如果 b-a < d-c 或者在 b-a == d-c 时 a < c，则区间 [a,b] 比 [c,d] 小。
Leetcode题目：https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/

一张扑克有3个属性，每种属性有3种值（A、B、C）
比如"AAA"，第一个属性值A，第二个属性值A，第三个属性值A
比如"BCA"，第一个属性值B，第二个属性值C，第三个属性值A
给定一个字符串类型的数组cards[]，每一个字符串代表一张扑克
从中挑选三张扑克，一个属性达标的条件是：这个属性在三张扑克中全一样，或全不一样
挑选的三张扑克达标的要求是：每种属性都满足上面的条件
比如："ABC"、"CBC"、"BBC"
第一张第一个属性为"A"、第二张第一个属性为"C"、第三张第一个属性为"B"，全不一样
第一张第二个属性为"B"、第二张第二个属性为"B"、第三张第二个属性为"B"，全一样
第一张第三个属性为"C"、第二张第三个属性为"C"、第三张第三个属性为"C"，全一样
每种属性都满足在三张扑克中全一样，或全不一样，所以这三张扑克达标
返回在cards[]中任意挑选三张扑克，达标的方法数



20 大厂高频算法和数据结构面试题20

题目：

如果只给定一个二叉树前序遍历数组pre和中序遍历数组in，能否不重建树，而直接生成这个二叉树的后序数组并返回，已知二叉树中没有重复值

给定一个由不同正整数的组成的非空数组 A，考虑下面的图：有 A.length 个节点，按从 A[0] 到 A[A.length - 1] 标记；
只有当 A[i] 和 A[j] 共用一个大于 1 的公因数时，A[i] 和 A[j] 之间才有一条边。返回图中最大连通集合的大小
Leetcode题目：https://leetcode.com/problems/largest-component-size-by-common-factor/

完美洗牌问题
给定一个长度为偶数的数组arr，假设长度为N*2
左部分：arr[L1...Ln] 右部分： arr[R1...Rn]
请把arr调整成arr[L1,R1,L2,R2,L3,R3,...,Ln,Rn]
要求时间复杂度O(N)，额外空间复杂度O(1)

给定一个字符串str，当然可以生成很多子序列，返回有多少个子序列是回文子序列，空序列不算回文
比如，str = “aba”，回文子序列：{a}、{a}、 {a,a}、 {b}、{a,b,a}，返回5



21 大厂高频算法和数据结构面试题21

题目：

树链剖分专题
给定数组father，大小为N，表示一共有N个节点
father[i] = j 表示点i的父亲是点j， father表示的树一定是一棵树而不是森林
给定数组values，大小为N，values[i]=v表示节点i的权值是v
实现如下4个方法，保证4个方法都很快！
1)让某个子树所有节点值加上v，入参：int head, int v
2)查询某个子树所有节点值的累加和，入参：int head
3)在树上从a到b的整条链上所有加上v，入参：int a, int b, int v
4)查询在树上从a到b的整条链上所有节点值的累加和，入参：int a, int b



22 大厂高频算法和数据结构面试题22

题目：

给定数组 nums 由正整数组成，找到三个互不重叠的子数组的最大和。每个子数组的长度为k，我们要使这3*k个项的和最大化。返回每个区间起始索引的列表（索引从 0 开始）。如果有多个结果，返回字典序最小的一个。
Leetcode题目：https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水
Leetcode题目：https://leetcode.com/problems/trapping-rain-water/

给你一个 m x n 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。
Leetcode题目：https://leetcode.com/problems/trapping-rain-water-ii/

一个不含有负数的数组可以代表一圈环形山，每个位置的值代表山的高度
比如， {3,1,2,4,5}、{4,5,3,1,2}或{1,2,4,5,3}都代表同样结构的环形山
山峰A和山峰B能够相互看见的条件为: 
1.如果A和B是同一座山，认为不能相互看见
2.如果A和B是不同的山，并且在环中相邻，认为可以相互看见
3.如果A和B是不同的山，并且在环中不相邻，假设两座山高度的最小值为min
       1)如果A通过顺时针方向到B的途中没有高度比min大的山峰，认为A和B可以相互看见
       2)如果A通过逆时针方向到B的途中没有高度比min大的山峰，认为A和B可以相互看见
两个方向只要有一个能看见，就算A和B可以相互看见
给定一个不含有负数且没有重复值的数组 arr，请返回有多少对山峰能够相互看见
进阶，给定一个不含有负数但可能含有重复值的数组arr，返回有多少对山峰能够相互看见

你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。
你有一堆可以焊接在一起的钢筋 rods。举个例子，如果钢筋的长度为 1、2 和 3，则可以将它们焊接在一起形成长度为 6 的支架。
返回广告牌的最大可能安装高度。如果没法安装广告牌，请返回 0。
Leetcode题目：https://leetcode.com/problems/tallest-billboard/



23 大厂高频算法和数据结构面试题23

题目：

给定数组father大小为N，表示一共有N个节点
father[i] = j 表示点i的父亲是点j， father表示的树一定是一棵树而不是森林
queries是二维数组，大小为M*2，每一个长度为2的数组都表示一条查询
[4,9], 表示想查询4和9之间的最低公共祖先… 
[3,7], 表示想查询3和7之间的最低公共祖先…
tree和queries里面的所有值，都一定在0~N-1之间
返回一个数组ans，大小为M，ans[i]表示第i条查询的答案

给定一个数组arr，长度为N > 1，从中间切一刀，保证左部分和右部分都有数字，一共有N-1种切法
如此多的切法中，每一种都有:绝对值(左部分最大值 – 右部分最大值)，返回最大的绝对值是多少

定义什么是可整合数组：一个数组排完序之后，除了最左侧的数外，有arr[i] = arr[i-1]+1
则称这个数组为可整合数组比如{5,1,2,4,3}、{6,2,3,1,5,4}都是可整合数组，返回arr中最长可整合子数组的长度

超级水王问题
给定一个数组arr，长度为N，如果某个数出现次数大于N/2，称该数为水王数，如果arr中有水王数，打印这个数；如果没有水王数，打印没有水王数
要求时间复杂度O(N)，额外空间复杂度O(1)
扩展1：摩尔投票
扩展2：给定一个正数K，返回所有出现次数>N/K的数

有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。
找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。
Leetcode题目：https://leetcode.com/problems/minimum-cost-to-merge-stones/



24 大厂高频算法和数据结构面试题24

题目：

给定一个正数数组arr，长度一定大于6（>=7），一定要选3个数字做分割点，从而分出4个部分，并且每部分都有数
分割点的数字直接删除，不属于任何4个部分中的任何一个。返回有没有可能分出的4个部分累加和一样大
如：{3,2,3,7,4,4,3,1,1,6,7,1,5,2}。可以分成{3,2,3}、{4,4}、{1,1,6}、{1,5,2}。分割点是不算的！

长度为N的数组arr，一定可以组成N^2个数字对。例如arr = [3,1,2]，数字对有(3,3) (3,1) (3,2) (1,3) (1,1) (1,2) (2,3) (2,1) (2,2)
也就是任意两个数都可以，而且自己和自己也算数字对。数字对怎么排序？第一维数据从小到大；第一维数据一样的，第二维数组也从小到大
所以上面的数值对排序的结果为：(1,1)(1,2)(1,3)(2,1)(2,2)(2,3)(3,1)(3,2)(3,3)。给定一个数组arr，和整数k，返回第k小的数值对

正常的里程表会依次显示自然数表示里程
吉祥的里程表会忽略含有4的数字而跳到下一个完全不含有4的数
正常：1 2 3 4 5 6 7 8  9 10 11 12 13 14 15
吉祥：1 2 3 5 6 7 8 9 10 11 12 13 15 16 17 ... 38 39 50 51 52 53 55
给定一个吉祥里程表的数字num(当然这个数字中不含有4)
返回这个数字代表的真实里程

N * M的棋盘（N和M是输入参数），每种颜色的格子数必须相同的，上下左右的格子算相邻，相邻格子染的颜色必须不同，所有格子必须染色，返回至少多少种颜色可以完成任务

给定两个字符串str1和str2，在str1中寻找一个最短子串，能包含str2的所有字符，字符顺序无所谓，str1的这个最短子串也可以包含多余的字符，返回这个最短包含子串

给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）
Leetcode题目：https://leetcode.com/problems/remove-duplicate-letters/



25 大厂高频算法和数据结构面试题25

题目：

An IP address is a formatted 32-bit unsigned integer where each group of 8 bits is printed as a decimal number and the dot character '.' splits the groups.
For example, the binary number 00001111 10001000 11111111 01101011 (spaces added for clarity) formatted as an IP address would be "15.136.255.107".
A CIDR block is a format used to denote a specific set of IP addresses. It is a string consisting of a base IP address, followed by a slash, followed by a prefix length k.
The addresses it covers are all the IPs whose first k bits are the same as the base IP address.
For example, "123.45.67.89/20" is a CIDR block with a prefix length of 20. Any IP address whose binary representation matches
01111011 00101101 0100xxxx xxxxxxxx, where x can be either 0 or 1, is in the set covered by the CIDR block.
You are given a start IP address ip and the number of IP addresses we need to cover n. 
Your goal is to use as few CIDR blocks as possible to cover all the IP addresses in the inclusive range [ip, ip + n - 1] exactly
No other IP addresses outside of the range should be covered.
Return the shortest list of CIDR blocks that covers the range of IP addresses. If there are multiple answers, return any of them.
Leetcode题目：https://leetcode.com/problems/ip-to-cidr/

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组
注意：答案中不可以包含重复的三元组
Leetcode题目：https://leetcode.com/problems/3sum/

给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。求最多有多少个点在同一条直线上。
Leetcode题目：https://leetcode.com/problems/max-points-on-a-line/

良好加油站问题最优解
Leetcode题目：https://leetcode.com/problems/gas-station/



26 大厂高频算法和数据结构面试题26

题目：

有三个有序数组，分别在三个数组中挑出3个数，x、y、z。返回 |x-y| + |y-z| + |z-x|最小是多少？
Leetcode题目：https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/

给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words，找出所有同时在二维网格和字典中出现的单词
单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格
同一个单元格内的字母在一个单词中不允许被重复使用。
Leetcode题目：https://leetcode.com/problems/word-search-ii/

给定一个仅包含数字 0-9 的字符串和一个目标值，在数字之间添加 二元 运算符（不是一元）+、- 或 * ，返回所有能够得到目标值的表达式。
输入: num = "123", target = 6
输出: ["1+2+3", "1*2*3"] 
示例 2:
输入: num = "232", target = 8
输出: ["2*3+2", "2+3*2"]
示例 3:
输入: num = "105", target = 5
输出: ["1*0+5","10-5"]
示例 4:
输入: num = "00", target = 0
输出: ["0+0", "0-0", "0*0"]
Leetcode题目：https://leetcode.com/problems/expression-add-operators/

按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的 转换序列 是形式上像 beginWord -> s1 -> s2 -> ... -> sk 这样的单词序列，并满足：
每对相邻的单词之间仅有单个字母不同。
转换过程中的每个单词 si（1 <= i <= k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词
给你两个单词 beginWord 和 endWord ，以及一个字典 wordList
请你找出并返回所有从 beginWord 到 endWord 的 最短转换序列 ，如果不存在这样的转换序列，返回一个空列表
每个序列都应该以单词列表 [beginWord, s1, s2, ..., sk] 的形式返回
Leetcode题目：https://leetcode.com/problems/word-ladder-ii/



27 大厂高频算法和数据结构面试题27

题目：

每一个项目都有三个数，[a,b,c]表示这个项目a和b乐队参演，花费为c
每一个乐队可能在多个项目里都出现了，但是只能被挑一次
nums是可以挑选的项目数量，所以一定会有nums*2只乐队被挑选出来
返回一共挑nums轮(也就意味着一定请到所有的乐队)，最少花费是多少？
如果怎么都无法在nums轮请到nums*2只乐队且每只乐队只能被挑一次，返回-1
nums<9，programs长度小于500，每组测试乐队的全部数量一定是nums*2，且标号一定是0 ~ nums*2-1

企鹅厂每年都会发文化衫，文化衫有很多种，厂庆的时候，企鹅们都需要穿文化衫来拍照
一次采访中，记者随机遇到的企鹅，企鹅会告诉记者还有多少企鹅跟他穿一种文化衫
我们将这些回答放在answers数组里，返回鹅厂中企鹅的最少数量
Leetcode题目：https://leetcode.com/problems/rabbits-in-forest/

给定一个整数数组nums和一个整数目标值target，请你在该数组中找出和为目标值target的那两个整数，并返回它们的数组下标
你可以假设每种输入只会对应一个答案。但是数组中同一个元素在答案里不能重复出现，你可以按任意顺序返回答案
Leetcode题目：https://leetcode.com/problems/two-sum/

给你一个32位的有符号整数x，返回将x中的数字部分反转后的结果，如果反转后整数超过 32 位的有符号整数的范围，就返回0
假设环境不允许存储 64 位整数（有符号或无符号）
Leetcode题目：https://leetcode.com/problems/reverse-integer/



28 大厂高频算法和数据结构面试题28

题目：

请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）
函数 myAtoi(string s) 的算法如下：
读入字符串并丢弃无用的前导空格
检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为231 − 1。
返回整数作为最终结果。
注意：本题中的空白字符只包括空格字符 ' ' 。除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。
Leetcode题目：https://leetcode.com/problems/string-to-integer-atoi/

罗马数字包含以下七种字符： I， V， X， L，C，D 和 M
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给你一个整数，将其转为罗马数字
Leetcode题目：https://leetcode.com/problems/integer-to-roman/

罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 
同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。
Leetcode题目：https://leetcode.com/problems/roman-to-integer/

编写一个函数来查找字符串数组中的最长公共前缀，如果不存在公共前缀，返回空字符串 ""。
Leetcode题目：https://leetcode.com/problems/longest-common-prefix/

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。
给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
按键2对应：'a', 'b', 'c'
按键3对应：'d', 'e', 'f'
按键4对应：'g', 'h', 'i'
按键5对应：'j', 'k', 'l'
按键6对应：'m', 'n', 'o'
按键7对应：'p', 'q', 'r', 's'
按键8对应：'t', 'u', 'v'
按键9对应：'w', 'x', 'y', 'z'
示例 1：
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
示例 2：
输入：digits = ""
输出：[]
示例 3：
输入：digits = "2"
输出：["a","b","c"]
Leetcode题目：https://leetcode.com/problems/letter-combinations-of-a-phone-number/

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
进阶：你能尝试使用一趟扫描实现吗？
Leetcode题目：https://leetcode.com/problems/remove-nth-node-from-end-of-list/

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
Leetcode题目：https://leetcode.com/problems/valid-parentheses/

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的括号组合。
示例 1：
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
示例 2：
输入：n = 1
输出：["()"]
Leetcode题目：https://leetcode.com/problems/generate-parentheses/

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
示例 1：
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
示例 2：
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4,_,_,_,_,_]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
Leetcode题目：https://leetcode.com/problems/remove-duplicates-from-sorted-array/

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。
要求：设计并实现时间复杂度为 O(log n) 的算法
Leetcode题目：https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/

请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。
数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
数独部分空格内已填入了数字，空白格用 '.' 表示。
注意：
一个有效的数独（部分已被填充）不一定是可解的。
只需要根据以上规则，验证已经填入的数字是否有效即可。
Leetcode题目：https://leetcode.com/problems/valid-sudoku/

编写一个程序，通过填充空格来解决数独问题。
数独的解法需遵循如下规则：
数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次
数独部分空格内已填入了数字，空白格用 '.' 表示。
Leetcode题目：https://leetcode.com/problems/sudoku-solver/

给定一个正整数 n ，输出的第 n 项。
前五项如下：
1.     1
2.     11
3.     21
4.     1211
5.     111221
第一项是数字 1 
描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 "11"
描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 "21"
描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 "1211"
描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 "111221"
返回第N项的字符串
Leetcode题目：https://leetcode.com/problems/count-and-say/

给定一个字符串数组，将字母异位词组合在一起。可以按任意顺序返回结果列表。
字母异位词指字母相同，但排列不同的字符串。
示例 1:
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
示例 2:
输入: strs = [""]
输出: [[""]]
示例 3:
输入: strs = ["a"]
输出: [["a"]]
Leetcode题目：https://leetcode.com/problems/group-anagrams/



29 大厂高频算法和数据结构面试题29

题目：

整数数组 nums 按升序排列，数组中的值 互不相同 。
在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，
使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数
例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。
Leetcode题目：https://leetcode.com/problems/search-in-rotated-sorted-array/

实现 pow(x, n) ，即计算 x 的 n 次幂函数
Leetcode题目：https://leetcode.com/problems/powx-n/

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi]
请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间
Leetcode题目：https://leetcode.com/problems/merge-intervals/

一个机器人位于一个 m x n 网格的左上角
机器人每次只能向下或者向右移动一步
机器人试图达到网格的右下角
问总共有多少条不同的路径？
Leetcode题目：https://leetcode.com/problems/unique-paths/

给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加1
最高位数字存放在数组的首位， 数组中每个元素只存储单个数字
你可以假设除了整数 0 之外，这个整数不会以零开头
示例 1：
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
示例 2：
输入：digits = [9,9,9]
输出：[1,0,0,0]
解释：输入数组表示数字 1000。
示例 3：
输入：digits = [0]
输出：[1]
Leetcode题目：https://leetcode.com/problems/plus-one/

实现 int sqrt(int x) 函数。
计算并返回 x 的平方根，其中 x 是非负整数。
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
示例 1:
输入: 4
输出: 2
示例 2:
输入: 8
输出: 2
说明: 8 的平方根是 2.82842...，由于返回类型是整数，小数部分将被舍去。
Leetcode题目：https://leetcode.com/problems/sqrtx/

给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。
进阶：
一个直观的解决方案是使用 O(m * n) 的额外空间，但这并不是一个好的解决方案。
一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。
你能想出一个仅使用常量空间的解决方案吗？
Leetcode题目：https://leetcode.com/problems/set-matrix-zeroes/



30 大厂高频算法和数据结构面试题30

题目：

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
Leetcode题目 : https://leetcode.com/problems/word-search/

给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。
示例 1：
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
示例 2：
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
Leetcode题目 : https://leetcode.com/problems/merge-sorted-array/

一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：
'A' -> 1
'B' -> 2
...
'Z' -> 26
要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：
"AAJF" ，将消息分组为 (1 1 10 6)
"KJF" ，将消息分组为 (11 10 6)
注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。
给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。
题目数据保证答案肯定是一个 32 位 的整数。
Leetcode题目 : https://leetcode.com/problems/decode-ways/

一条包含字母 A-Z 的消息通过以下的方式进行了编码：
'A' -> 1
'B' -> 2
...
'Z' -> 26
除了上述的条件以外，现在加密字符串可以包含字符 '*'了，字符'*'可以被当做1到9当中的任意一个数字。
给定一条包含数字和字符'*'的加密信息，请确定解码方法的总数。
同时，由于结果值可能会相当的大，所以你应当对109 + 7取模。（翻译者标注：此处取模主要是为了防止溢出）
示例 1 :
输入: "*"
输出: 9
解释: 加密的信息可以被解密为: "A", "B", "C", "D", "E", "F", "G", "H", "I".
示例 2 :
输入: "1*"
输出: 9 + 9 = 18（翻译者标注：这里1*可以分解为1,* 或者当做1*来处理，所以结果是9+9=18）
Leetcode题目 : https://leetcode.com/problems/decode-ways-ii/

给定一个二叉树，判断其是否是一个有效的二叉搜索树。
Leetcode题目 : https://leetcode.com/problems/validate-binary-search-tree/

给定一个二叉树，检查它是否是镜像对称的。
Leetcode题目 : https://leetcode.com/problems/symmetric-tree/

给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
Leetcode题目 : https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/

给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。
高度平衡二叉树是一棵满足每个节点的左右两个子树的高度差的绝对值不超过1的二叉树
Leetcode题目 : https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/

给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
初始状态下，所有 next 指针都被设置为 NULL。
进阶：
这棵树如果是普通二叉树，该怎么做。
你只能使用常量级额外空间。
Leetcode题目 : https://leetcode.com/problems/populating-next-right-pointers-in-each-node/

给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。
在「杨辉三角」中，每个数是它左上方和右上方的数的和。
Leetcode题目 : https://leetcode.com/problems/pascals-triangle/

给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。
在「杨辉三角」中，每个数是它左上方和右上方的数的和。
你可以优化你的算法到 O(1) 空间复杂度吗？
Leetcode题目 : https://leetcode.com/problems/pascals-triangle-ii/

路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。
路径和 是路径中各节点值的总和。
给你一个二叉树的根节点 root ，返回其 最大路径和。
进阶：
如果返回最大路径和上的所有节点，该怎么做？
Leetcode题目 : https://leetcode.com/problems/binary-tree-maximum-path-sum/



31 大厂高频算法和数据结构面试题31

题目：

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
说明：本题中，我们将空字符串定义为有效的回文串。
示例 1:
输入: "A man, a plan, a canal: Panama"
输出: true
解释："amanaplanacanalpanama" 是回文串
示例 2:
输入: "race a car"
输出: false
解释："raceacar" 不是回文串
Leetcode题目 : https://leetcode.com/problems/valid-palindrome/

字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：
序列中第一个单词是 beginWord
序列中最后一个单词是 endWord
每次转换只能改变一个字母。
转换过程中的中间单词必须是字典 wordList 中的单词
给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。
Leetcode题目 : https://leetcode.com/problems/word-ladder/

给你一个 m x n 的矩阵 board ，由若干字符 'X' 和 'O' ，找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。
Leetcode题目 : https://leetcode.com/problems/surrounded-regions/

给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。
说明：拆分时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。
Leetcode题目 : https://leetcode.com/problems/word-break/
Lintcode题目 : https://www.lintcode.com/problem/107/

给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。
说明：分隔时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。
示例 1：
输入:
s = "catsanddog"
wordDict = ["cat", "cats", "and", "sand", "dog"]
输出:
[
  "cats and dog",
  "cat sand dog"
]
示例 2：
输入:
s = "pineapplepenapple"
wordDict = ["apple", "pen", "applepen", "pine", "pineapple"]
输出:
[
  "pine apple pen apple",
  "pineapple pen apple",
  "pine applepen apple"
]
解释: 注意你可以重复使用字典中的单词。
示例 3：
输入:
s = "catsandog"
wordDict = ["cats", "dog", "sand", "and", "cat"]
输出:
[]
Leetcode题目 : https://leetcode.com/problems/word-break-ii/

给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表头节点。
进阶：你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？
Leetcode题目 : https://leetcode.com/problems/sort-list/

根据 逆波兰表示法，求表达式的值。
有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。
说明：整数除法只保留整数部分。给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。
示例 1：
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
示例 2：
输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
示例 3：
输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
输出：22
解释：
该算式转化为常见的中缀算术表达式为：
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
Leetcode题目 : https://leetcode.com/problems/evaluate-reverse-polish-notation/



32 大厂高频算法和数据结构面试题32

题目：

给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。
Leetcode题目 : https://leetcode.com/problems/maximum-product-subarray/

给定一个有序无重复的数组nums， 和两个整数lower和upper， 返回[lower,upper]上所有缺失的数字段
示例1:
nums = [0,1,3,50,75], lower = 0, upper = 99
输出:["2","4->49","51->74","76->99"]
示例2:
nums = [], lower = 1, upper = 1
输出: ["1"]
示例3:
nums = [], lower = -3, upper = -1
输出： ["-3->-1"]
示例4:
nums = [-1], lower = -1, upper = -1
输出: []
示例5: 
nums = [-1], lower = -2, upper = -1
输出: ["-2"]
Leetcode题目 : https://leetcode.com/problems/missing-ranges/

给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以 字符串形式返回小数 。
如果小数部分为循环小数，则将循环的部分括在括号内。
如果存在多个答案，只需返回 任意一个 。
对于所有给定的输入，保证 答案字符串的长度小于 104 。
示例 1：
输入：numerator = 1, denominator = 2
输出："0.5"
示例 2：
输入：numerator = 2, denominator = 1
输出："2"
示例 3：
输入：numerator = 2, denominator = 3
输出："0.(6)"
示例 4：
输入：numerator = 4, denominator = 333
输出："0.(012)"
示例 5：
输入：numerator = 1, denominator = 5
输出："0.2"
Leetcode题目 : https://leetcode.com/problems/fraction-to-recurring-decimal/

给你一个字符串 columnTitle ，表示 Excel 表格中的列名称。返回该列名称对应的列序号。
例如，

    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 
    ...
示例 1:
输入: columnTitle = "A"
输出: 1
示例 2:
输入: columnTitle = "AB"
输出: 28
示例 3:
输入: columnTitle = "ZY"
输出: 701
示例 4:
输入: columnTitle = "FXSHRXW"
输出: 2147483647
Leetcode题目 : https://leetcode.com/problems/excel-sheet-column-number/

给定一个整数 n，返回 n! 结果尾数中零的数量。
示例 1:
输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
示例 2:
输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
说明: 你算法的时间复杂度应为 O(log n) 。
Leetcode题目 : https://leetcode.com/problems/factorial-trailing-zeroes/

给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。
进阶：
尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？
示例 1:
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
示例 2:
输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
Leetcode题目 : https://leetcode.com/problems/rotate-array/

颠倒给定的 32 位无符号整数的二进制位。
进阶:
如果多次调用这个函数，你将如何优化你的算法？
示例 1：
输入：n = 00000010100101000001111010011100
输出：964176192 (00111001011110000010100101000000)
解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
示例 2：
输入：n = 11111111111111111111111111111101
输出：3221225471 (10111111111111111111111111111111)
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
Leetcode题目 : https://leetcode.com/problems/reverse-bits/

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。
示例 1：
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
示例 2：
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
示例 3：
输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
提示：
输入必须是长度为 32 的 二进制串 。
进阶：
如果多次调用这个函数，你将如何优化你的算法？
Leetcode题目 : https://leetcode.com/problems/number-of-1-bits/

编写一个算法来判断一个数 n 是不是快乐数。
「快乐数」定义为：
对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果 可以变为  1，那么这个数就是快乐数。
如果 n 是快乐数就返回 true ；不是，则返回 false 。
示例 1：
输入：19
输出：true
解释：
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
示例 2：
输入：n = 2
输出：false
提示：
1 <= n <= 2^31 - 1
Leetcode题目 : https://leetcode.com/problems/happy-number

统计所有小于非负整数 n 的质数的数量。
示例 1：
输入：n = 10
输出：4
解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
示例 2：
输入：n = 0
输出：0
示例 3：
输入：n = 1
输出：0
提示：
0 <= n <= 5 * 10^6
Leetcode题目 : https://leetcode.com/problems/count-primes/

拼多多笔试题 : 给定一个数组arr，arr[i] = j，表示第i号试题的难度为j。给定一个非负数M
想出一张卷子，对于任何相邻的两道题目，前一题的难度不能超过后一题的难度+M
返回所有可能的卷子种数



33 大厂高频算法和数据结构面试题33

题目：

你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。
在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。
例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。
请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。
示例 1：
输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
示例 2：
输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
输出：false
解释：总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。
Leetcode题目 : https://leetcode.com/problems/course-schedule/

现在你总共有 n 门课需要选，记为 0 到 n-1。
在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]
给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。
可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。
示例 1:
输入: 2, [[1,0]] 
输出: [0,1]
解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
示例 2:
输入: 4, [[1,0],[2,0],[3,1],[3,2]]
输出: [0,1,2,3] or [0,2,1,3]
解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
Leetcode题目 : https://leetcode.com/problems/course-schedule-ii/

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。
这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。
同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。
给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。
示例 1：
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
示例 2：
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 3：
输入：nums = [0]
输出：0
Leetcode题目 : https://leetcode.com/problems/house-robber-ii/

请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。
Leetcode题目 : https://leetcode.com/problems/delete-node-in-a-linked-list/

给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。
示例:
输入: [1,2,3,4]
输出: [24,12,8,6]
说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。
进阶：
你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）
Leetcode题目 : https://leetcode.com/problems/product-of-array-except-self/

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。
示例 1:
输入: s = "anagram", t = "nagaram"
输出: true
示例 2:
输入: s = "rat", t = "car"
输出: false
Leetcode题目 : https://leetcode.com/problems/valid-anagram/

给定一个二维数组，实现二维数组的迭代器，包含hasNext()和next()两个迭代器常见方法。
Leetcode题目 : https://leetcode.com/problems/flatten-2d-vector/

出版社印发了一个名单，名单上的每一行都是一个字符串，字符串都是小写字母，但是字符串出现的先后顺序和日常的字典序不一样
现在怀疑出版社内部对于字符有自己的字典序规则，请根据字符串之间出现的顺序，返回可能存在的、出版社内部的字符顺序
如果从名单来看不存在这样的字符顺序，返回空字符串
Leetcode题目 : https://leetcode.com/problems/alien-dictionary/

给定一个数n，所有人的编号从0到n-1
给定一个函数 boolean know(int i, int j)，该函数表示i这个人认不认识j这个人，认识关系是单向的
有了这个函数，你可以检查认识这件事情。
规定何为明星？1）所有人都认识这个人。2）这个人不认识自己之外的所有人。那么这个人就是明星
利用know函数，找到明星，返回明星的编号，如果没有明星返回-1。
Leetcode题目 : https://leetcode.com/problems/find-the-celebrity/

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。
给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。
完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。
示例 1：
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
示例 2：
输入：n = 13
输出：2
解释：13 = 4 + 9
Leetcode题目 : https://leetcode.com/problems/perfect-squares/

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
示例:
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
说明:
必须在原数组上操作，不能拷贝额外的数组。
尽量减少操作次数。
Leetcode题目 : https://leetcode.com/problems/move-zeroes/



34 大厂高频算法和数据结构面试题34

题目：

给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。
假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。
你设计的解决方案必须不修改数组 nums 且只用常量级 O(1) 的额外空间。
Leetcode题目 : https://leetcode.com/problems/find-the-duplicate-number/

生命游戏，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。
给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。
每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：
如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；
如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；
如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；
如果死细胞周围正好有三个活细胞，则该位置死细胞复活；
下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 m x n 网格面板 board 的当前状态，返回下一个状态。
Leetcode题目 : https://leetcode.com/problems/game-of-life/

中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。
例如，
[2,3,4] 的中位数是 3
[2,3] 的中位数是 (2 + 3) / 2 = 2.5
设计一个支持以下两种操作的数据结构：
void addNum(int num) - 从数据流中添加一个整数到数据结构中。
double findMedian() - 返回目前所有元素的中位数。
Leetcode题目 : https://leetcode.com/problems/find-median-from-data-stream/

给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。
示例：
输入：nums = [5,2,6,1]
输出：[2,1,1,0] 
解释：
5 的右侧有 2 个更小的元素 (2 和 1)
2 的右侧仅有 1 个更小的元素 (1)
6 的右侧有 1 个更小的元素 (1)
1 的右侧有 0 个更小的元素
Leetcode题目 : https://leetcode.com/problems/count-of-smaller-numbers-after-self/

给你一个整数数组 nums，将它重新排列成 nums[0] < nums[1] > nums[2] < nums[3]... 的顺序。
你可以假设所有输入数组都可以得到满足题目要求的结果。
示例 1：
输入：nums = [1,5,1,1,6,4]
输出：[1,6,1,5,1,4]
解释：[1,4,1,5,1,6] 同样是符合题目要求的结果，可以被判题程序接受。
示例 2：
输入：nums = [1,3,2,2,3,1]
输出：[2,3,1,3,1,2]
进阶：你能用 O(n) 时间复杂度和原地 O(1) 额外空间来实现吗？
Leetcode题目 : https://leetcode.com/problems/wiggle-sort-ii/

给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。
Leetcode题目 : https://leetcode.com/problems/power-of-three/

给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。
请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。
示例 1:
输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL
示例 2:
输入: 2->1->3->5->6->4->7->NULL 
输出: 2->3->6->7->1->5->4->NULL
说明:
应当保持奇数节点和偶数节点的相对顺序。
链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。
Leetcode题目 : https://leetcode.com/problems/odd-even-linked-list/

给定一个字符串str，和一个正数k，返回字符种类不超过k种的最长子串长度。
Leetcode题目 : https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/

给你一个嵌套的整数列表 nestedList 。每个元素要么是一个整数，要么是一个列表；
该列表的元素也可能是整数或者是其他列表。请你实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。
实现扁平迭代器类 NestedIterator ：
NestedIterator(List<NestedInteger> nestedList) 用嵌套列表 nestedList 初始化迭代器。
int next() 返回嵌套列表的下一个整数。
boolean hasNext() 如果仍然存在待迭代的整数，返回 true ；否则，返回 false 。
你的代码将会用下述伪代码检测：
initialize iterator with nestedList
res = []
while iterator.hasNext()
    append iterator.next() to the end of res
return res
如果 res 与预期的扁平化列表匹配，那么你的代码将会被判为正确。
示例 1：
输入：nestedList = [[1,1],2,[1,1]]
输出：[1,1,2,1,1]
解释：通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,1,2,1,1]。
示例 2：
输入：nestedList = [1,[4,[6]]]
输出：[1,4,6]
解释：通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,4,6]。
Leetcode题目 : https://leetcode.com/problems/flatten-nested-list-iterator/

tic-tac-toe游戏，不知道的同学可以自行搜索。请实现以下类TicTacToe。
构造方法：TicTacToe(int n) : TicTacToe游戏的类，n表示目前在n*n的棋盘上玩游戏。
内部方法：int move(int i, int j, int p) : p只可能是1和2，表示玩家1还是玩家2。当前玩家在i行j列上走了一步。返回值只可能是0、1、2，0表示没有玩家赢；1表示玩家1赢了；2表示玩家2赢了。
Leetcode题目 : https://leetcode.com/problems/design-tic-tac-toe/

设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构。
insert(val)：当元素 val 不存在时，向集合中插入该项。
remove(val)：元素 val 存在时，从集合中移除该项。
getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。
Leetcode题目 : https://leetcode.com/problems/insert-delete-getrandom-o1/

给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。
实现 Solution class:
Solution(int[] nums) 使用整数数组 nums 初始化对象
int[] reset() 重设数组到它的初始状态并返回
int[] shuffle() 返回数组随机打乱后的结果
Leetcode题目 : https://leetcode.com/problems/shuffle-an-array/



35 大厂高频算法和数据结构面试题35

给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。
示例 1:
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
示例 2:
输入: nums = [1], k = 1
输出: [1]
提示：
1 <= nums.length <= 10^5
k 的取值范围是 [1, 数组中不相同的元素的个数]
题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的
进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。
Leetcode题目 : https://leetcode.com/problems/top-k-frequent-elements/

给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。
示例 1：
输入：s = "aaabb", k = 3
输出：3
解释：最长子串为 "aaa" ，其中 'a' 重复了 3 次。
示例 2：
输入：s = "ababbc", k = 2
输出：5
解释：最长子串为 "ababb" ，其中 'a' 重复了 2 次， 'b' 重复了 3 次。
提示：
1 <= s.length <= 10^4
s 仅由小写英文字母组成
Leetcode题目 : https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/

写一个程序，输出从 1 到 n 数字的字符串表示。
1. 如果 n 是3的倍数，输出“Fizz”；
2. 如果 n 是5的倍数，输出“Buzz”；
3.如果 n 同时是3和5的倍数，输出 “FizzBuzz”。
示例：
n = 15,
返回:
[
    "1",
    "2",
    "Fizz",
    "4",
    "Buzz",
    "Fizz",
    "7",
    "8",
    "Fizz",
    "Buzz",
    "11",
    "Fizz",
    "13",
    "14",
    "FizzBuzz"
]
Leetcode题目 : https://leetcode.com/problems/fizz-buzz/

给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。
为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。
例如:
输入:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]
输出:
2
解释:
两个元组如下:
1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
Leetcode题目 : https://leetcode.com/problems/4sum-ii/

给定一个未排序的整数数组，找到最长递增子序列的个数。
示例 1:
输入: [1,3,5,4,7]
输出: 2
解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。
示例 2:
输入: [2,2,2,2,2]
输出: 5
解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。
注意: 给定的数组长度不超过 2000 并且结果一定是32位有符号整数。
Leetcode题目 : https://leetcode.com/problems/number-of-longest-increasing-subsequence/

给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。
注意：两个节点之间的路径长度由它们之间的边数表示。
注意: 给定的二叉树不超过10000个结点。 树的高度不超过1000。
Leetcode题目 : https://leetcode.com/problems/longest-univalue-path/

来自真实笔试
给定一个长度len，表示一共有几位
所有字符都是小写(a~z)，可以生成长度为1，长度为2，
长度为3...长度为len的所有字符串
如果把所有字符串根据字典序排序，每个字符串都有所在的位置。
给定一个字符串str，给定len，请返回str是总序列中的第几个
比如len = 4，字典序的前几个字符串为:
a aa aaa aaaa aaab ... aaaz ... azzz b ba baa baaa ... bzzz c ...
a是这个序列中的第1个，bzzz是这个序列中的第36558个

来自小红书
[0,4,7] ： 0表示这里石头没有颜色，如果变红代价是4，如果变蓝代价是7
[1,X,X] ： 1表示这里石头已经是红，而且不能改颜色，所以后两个数X无意义
[2,X,X] ： 2表示这里石头已经是蓝，而且不能改颜色，所以后两个数X无意义
颜色只可能是0、1、2，代价一定>=0
给你一批这样的小数组，要求最后必须所有石头都有颜色，且红色和蓝色一样多，返回最小代价
如果怎么都无法做到所有石头都有颜色、且红色和蓝色一样多，返回-1

来自小红书
一场电影开始和结束时间可以用一个小数组来表示["07:30","12:00"]
已知有2000场电影开始和结束都在同一天，这一天从00:00开始到23:59结束
一定要选3场完全不冲突的电影来观看，返回最大的观影时间
如果无法选出3场完全不冲突的电影来观看，返回-1

来自网易
map[i][j] == 0，代表(i,j)是海洋，渡过的话代价是2
map[i][j] == 1，代表(i,j)是陆地，渡过的话代价是1
map[i][j] == 2，代表(i,j)是障碍，无法渡过
每一步上、下、左、右都能走，返回从左上角走到右下角最小代价是多少，如果无法到达返回-1

来自网易
给定一个正数数组arr，表示每个小朋友的得分
任何两个相邻的小朋友，如果得分一样，怎么分糖果无所谓，但如果得分不一样，分数大的一定要比分数少的多拿一些糖果
假设所有的小朋友坐成一个环形，返回在不破坏上一条规则的情况下，需要的最少糖果数



36 大厂高频算法和数据结构面试题36

来自网易
规定：L[1]对应a，L[2]对应b，L[3]对应c，...，L[25]对应y
S1 = a
S(i) = S(i-1) + L[i] + reverse(invert(S(i-1)));
解释invert操作：
S1 = a
S2 = aby
假设invert(S(2)) = 甲乙丙
a + 甲 = 26, 那么 甲 = 26 - 1 = 25 -> y
b + 乙 = 26, 那么 乙 = 26 - 2 = 24 -> x
y + 丙 = 26, 那么 丙 = 26 - 25 = 1 -> a
如上就是每一位的计算方式，所以invert(S2) = yxa
所以S3 = S2 + L[3] + reverse(invert(S2)) = aby + c + axy = abycaxy
invert(abycaxy) = yxawyba, 再reverse = abywaxy
所以S4 = abycaxy + d + abywaxy = abycaxydabywaxy
直到S25结束
给定两个参数n和k，返回Sn的第k位是什么字符，n从1开始，k从1开始
比如n=4，k=2，表示S4的第2个字符是什么，返回b字符
 
来自京东
把一个01字符串切成多个部分，要求每一部分的0和1比例一样，同时要求尽可能多的划分
比如 : 01010101
01 01 01 01 这是一种切法，0和1比例为 1 : 1
0101 0101 也是一种切法，0和1比例为 1 : 1
两种切法都符合要求，但是那么尽可能多的划分为第一种切法，部分数为4
比如 : 00001111
只有一种切法就是00001111整体作为一块，那么尽可能多的划分，部分数为1
给定一个01字符串str，假设长度为N，要求返回一个长度为N的数组ans
其中ans[i] = str[0...i]这个前缀串，要求每一部分的0和1比例一样，同时要求尽可能多的划分下，部分数是多少
输入: str = "010100001"
输出: ans = [1, 1, 1, 2, 1, 2, 1, 1, 3]
 
来自美团
给定两个字符串s1和s2
返回在s1中有多少个子串等于s2
 
来自美团
() 分值为2
(()) 分值为3
((())) 分值为4
也就是说，每包裹一层，分数就是里面的分值+1
()() 分值为2 * 2
(())() 分值为3 * 2
也就是说，每连接一段，分数就是各部分相乘，以下是一个结合起来的例子
(()())()(()) -> (2 * 2 + 1) * 2 * 3 -> 30
给定一个括号字符串str，已知str一定是正确的括号结合，不会有违规嵌套
返回分数
 
来自美团
给定一个数组arr，长度为N，做出一个结构，可以高效的做如下的查询
1) int querySum(L,R) : 查询arr[L...R]上的累加和
2) int queryAim(L,R) : 查询arr[L...R]上的目标值，目标值定义如下：
       假设arr[L...R]上的值为[a,b,c,d]，a+b+c+d = s
       目标值为 : (s-a)^2 + (s-b)^2 + (s-c)^2 + (s-d)^2
3) int queryMax(L,R) : 查询arr[L...R]上的最大值
要求：
1) 初始化该结构的时间复杂度不能超过O(N*logN)
2) 三个查询的时间复杂度不能超过O(logN)
3) 查询时，认为arr的下标从1开始，比如 : 
   arr = [ 1, 1, 2, 3 ];
   querySum(1, 3) -> 4
   queryAim(2, 4) -> 50
   queryMax(1, 4) -> 3

来自美团
有一棵树，给定头节点h，和结构数组m，下标0弃而不用
比如h = 1, m = [ [] , [2,3], [4], [5,6], [], [], []]
表示1的孩子是2、3; 2的孩子是4; 3的孩子是5、6; 4、5和6是叶节点，都不再有孩子
每一个节点都有颜色，记录在c数组里，比如c[i] = 4, 表示节点i的颜色为4
一开始只有叶节点是有权值的，记录在w数组里，
比如，如果一开始就有w[i] = 3, 表示节点i是叶节点、且权值是3
现在规定非叶节点i的权值计算方式：
根据i的所有直接孩子来计算，假设i的所有直接孩子，颜色只有a,b,k
w[i] = Max {
             (颜色为a的所有孩子个数 + 颜色为a的孩子权值之和), 
             (颜色为b的所有孩子个数 + 颜色为b的孩子权值之和),
             (颜色为k的所有孩子个数 + 颜色k的孩子权值之和)
           }
请计算所有孩子的权值并返回

来自腾讯
给定一个数组arr，当拿走某个数a的时候，其他所有的数都+a
请返回最终所有数都拿走的最大分数
比如: [2,3,1]
当拿走3时，获得3分，数组变成[5,4]
当拿走5时，获得5分，数组变成[9]
当拿走9时，获得9分，数组变成[]
这是最大的拿取方式，返回总分17
 
来自腾讯
给定一个正数数组arr，代表每个人的体重。给定一个正数limit代表船的载重，所有船都是同样的载重量
每个人的体重都一定不大于船的载重
要求：
1, 可以1个人单独一搜船
2, 一艘船如果坐2人，两个人的体重相加需要是偶数，且总体重不能超过船的载重
3, 一艘船最多坐2人
返回如果想所有人同时坐船，船的最小数量
 
来自腾讯
给定一个字符串str，和一个正数k
返回长度为k的所有子序列中，字典序最大的子序列
 
来自哈喽单车(Leetcode原题)
Alice 和 Bob 两个人轮流玩一个游戏，Alice 先手。
一开始，有 n 个石子堆在一起。每个人轮流操作，正在操作的玩家可以从石子堆里拿走 任意 非零 平方数 个石子。
如果石子堆里没有石子了，则无法操作的玩家输掉游戏。
给你正整数 n ，且已知两个人都采取最优策略。如果 Alice 会赢得比赛，那么返回 True ，否则返回 False 。
leetcode原题 : https://leetcode.com/problems/stone-game-iv/

来自三七互娱(Leetcode原题)
给你一个数组 routes ，表示一系列公交线路，其中每个 routes[i] 表示一条公交线路，第 i 辆公交车将会在上面循环行驶。
例如，路线 routes[0] = [1, 5, 7] 表示第 0 辆公交车会一直按序列 1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ... 这样的车站路线行驶。
现在从 source 车站出发（初始时不在公交车上），要前往 target 车站。 期间仅可乘坐公交车。
求出 最少乘坐的公交车数量 。如果不可能到达终点车站，返回 -1 。
Leetcode原题 : https://leetcode.com/problems/bus-routes/



37 大厂高频算法和数据结构面试题37

给你二叉树的根结点 root ，请你将它展开为一个单链表：
展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 先序遍历 顺序相同。
Leetcode题目 : https://leetcode.com/problems/flatten-binary-tree-to-linked-list/

在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。
Leetcode题目 : https://leetcode.com/problems/maximal-square/

翻转一棵二叉树
任何节点的左右两个孩子交换
Leetcode题目 : https://leetcode.com/problems/invert-binary-tree/

给定一个经过编码的字符串，返回它解码后的字符串。
编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。
你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。
此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。
Leetcode题目 : https://leetcode.com/problems/decode-string/

假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。
请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。
输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
Leetcode题目 : https://leetcode.com/problems/queue-reconstruction-by-height/

给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。
路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
Leetcode题目 : https://leetcode.com/problems/path-sum-iii/

来自网易
刚入职网易互娱，新人mini项目便如火如荼的开展起来。为了更好的项目协作与管理，
小易决定将学到的甘特图知识用于mini项目时间预估。小易先把项目中每一项工作以任务的形式列举出来，
每项任务有一个预计花费时间与前置任务表，必须完成了该任务的前置任务才能着手去做该任务。
作为经验PM，小易把任务划分得井井有条，保证没有前置任务或者前置任务全数完成的任务，都可以同时进行。
小易给出了这样一个任务表，请作为程序的你计算需要至少多长时间才能完成所有任务。
输入第一行为一个正整数T，表示数据组数。
对于接下来每组数据，第一行为一个正整数N，表示一共有N项任务。
接下来N行，每行先有两个整数Di和Ki，表示完成第i个任务的预计花费时间为Di天，该任务有Ki个前置任务。
之后为Ki个整数Mj，表示第Mj个任务是第i个任务的前置任务。
数据范围：对于所有数据，满足1<=T<=3, 1<=N, Mj<=100000, 0<=Di<=1000, 0<=sum(Ki)<=N*2。

来自字节
扑克牌中的红桃J和梅花Q找不到了，为了利用剩下的牌做游戏，小明设计了新的游戏规则
1) A,2,3,4....10,J,Q,K分别对应1到13这些数字，大小王对应0
2) 游戏人数为2人，轮流从牌堆里摸牌，每次摸到的牌只有“保留”和“使用”两个选项，且当前轮必须做出选择
3) 如果选择“保留”当前牌，那么当前牌的分数加到总分里，并且可以一直持续到游戏结束
4) 如果选择“使用”当前牌，那么当前牌的分数*3，加到总分上去，但是只有当前轮，下一轮，下下轮生效，之后轮效果消失。
5) 每一轮总分大的人获胜
假设小明知道每一轮对手做出选择之后的总分，返回小明在每一轮都赢的情况下，最终的最大分是多少
如果小明怎么都无法保证每一轮都赢，返回-1



38 大厂高频算法和数据结构面试题38

给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。
异位词 指字母相同，但排列不同的字符串。
示例 1:
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
示例 2:
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
提示:
1 <= s.length, p.length <= 3 * 10^4
s 和 p 仅包含小写字母
Leetcode题目 : https://leetcode.com/problems/find-all-anagrams-in-a-string/

给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。
示例 1：
输入：nums = [4,3,2,7,8,2,3,1]
输出：[5,6]
示例 2：
输入：nums = [1,1]
输出：[2]
提示：
n == nums.length
1 <= n <= 10^5
1 <= nums[i] <= n
进阶：你能在不使用额外空间且时间复杂度为 O(n) 的情况下解决这个问题吗? 你可以假定返回的数组不算在额外空间内。
Leetcode题目 : https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/

给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。
Leetcode题目 : https://leetcode.com/problems/merge-two-binary-trees/

给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。
在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。
然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。
你需要计算完成所有任务所需要的 最短时间 。
示例 1：
输入：tasks = ["A","A","A","B","B","B"], n = 2
输出：8
解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B
在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 
示例 2：
输入：tasks = ["A","A","A","B","B","B"], n = 0
输出：6
解释：在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n = 0
["A","A","A","B","B","B"]
["A","B","A","B","A","B"]
["B","B","B","A","A","A"]
...
诸如此类
示例 3：
输入：tasks = ["A","A","A","A","A","A","B","C","D","E","F","G"], n = 2
输出：16
解释：一种可能的解决方案是：
A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> (待命) -> (待命) -> A -> (待命) -> (待命) -> A
Leetcode题目 : https://leetcode.com/problems/task-scheduler/

给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。
回文字符串 是正着读和倒过来读一样的字符串。
子字符串 是字符串中的由连续字符组成的一个序列。
具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。
示例 1：
输入：s = "abc"
输出：3
解释：三个回文子串: "a", "b", "c"
示例 2：
输入：s = "aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
提示：
1 <= s.length <= 1000
s 由小写英文字母组成
Leetcode题目 : https://leetcode.com/problems/palindromic-substrings/

请根据每日 气温 列表 temperatures ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。
示例 1:
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
示例 2:
输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
示例 3:
输入: temperatures = [30,60,90]
输出: [1,1,0]
提示：
1 <= temperatures.length <= 10^5
30 <= temperatures[i] <= 100
Leetcode题目 : https://leetcode.com/problems/daily-temperatures/

字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。
示例：
输入：S = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca", "defegde", "hijhklij"。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。
提示：
S的长度在[1, 500]之间。
S只包含小写字母 'a' 到 'z' 。
Leetcode题目 : https://leetcode.com/problems/partition-labels/

来自字节
给定两个数a和b
第1轮，把1选择给a或者b
第2轮，把2选择给a或者b
...
第i轮，把i选择给a或者b
想让a和b的值一样大，请问至少需要多少轮？

360笔试题
长城守卫军
题目描述：
长城上有连成一排的n个烽火台，每个烽火台都有士兵驻守。
第i个烽火台驻守着ai个士兵，相邻峰火台的距离为1。另外，有m位将军，
每位将军可以驻守一个峰火台，每个烽火台可以有多个将军驻守，
将军可以影响所有距离他驻守的峰火台小于等于x的烽火台。
每个烽火台的基础战斗力为士兵数，另外，每个能影响此烽火台的将军都能使这个烽火台的战斗力提升k。
长城的战斗力为所有烽火台的战斗力的最小值。
请问长城的最大战斗力可以是多少？
输入描述
第一行四个正整数n,m,x,k(1<=x<=n<=10^5,0<=m<=10^5,1<=k<=10^5)
第二行n个整数ai(0<=ai<=10^5)
输出描述 仅一行，一个整数，表示长城的最大战斗力
样例输入
5 2 1 2
4 4 2 4 4
样例输出
6



39 大厂高频算法和数据结构面试题39

来自腾讯
给定一个只由0和1组成的字符串S，假设下标从1开始，规定i位置的字符价值V[i]计算方式如下:
1) i == 1时，V[i] = 1
2) i > 1时，如果S[i] != S[i-1]，V[i] = 1
3) i > 1时，如果S[i] == S[i-1]，V[i] = V[i-1] + 1
你可以随意删除S中的字符，返回整个S的最大价值
字符串长度<=5000

来自腾讯
给定一个长度为n的数组arr，求有多少个子数组满足:
子数组两端的值，是这个子数组的最小值和次小值，最小值和次小值谁在最左和最右无所谓
n<=100000

来自百度
给定一个字符串str，和一个正数k
str子序列的字符种数必须是k种，返回有多少子序列满足这个条件
已知str中都是小写字母

来自京东
给定一个二维数组matrix，matrix[i][j] = k代表:
从(i,j)位置可以随意往右跳<=k步，或者从(i,j)位置可以随意往下跳<=k步
如果matrix[i][j] = 0，代表来到(i,j)位置必须停止
返回从matrix左上角到右下角，至少要跳几次
已知matrix中行数n <= 5000, 列数m <= 5000
matrix中的值 <= 1000

真实笔试，忘了哪个公司，但是绝对大厂
一个子序列的消除规则如下:
1) 在某一个子序列中，如果'1'的左边有'0'，那么这两个字符->"01"可以消除
2) 在某一个子序列中，如果'3'的左边有'2'，那么这两个字符->"23"可以消除
3) 当这个子序列的某个部分消除之后，认为其他字符会自动贴在一起，可以继续寻找消除的机会
比如，某个子序列"0231"，先消除掉"23"，那么剩下的字符贴在一起变成"01"，继续消除就没有字符了
如果某个子序列通过最优良的方式，可以都消掉，那么这样的子序列叫做“全消子序列”
一个只由'0'、'1'、'2'、'3'四种字符组成的字符串str，可以生成很多子序列，返回“全消子序列”的最大长度
字符串str长度 <= 200



40 大厂高频算法和数据结构面试题40

腾讯
分裂问题
一个数n，可以分裂成一个数组[n/2, n%2, n/2]
这个数组中哪个数不是1或者0，就继续分裂下去
比如 n = 5，一开始分裂成[2, 1, 2]
[2, 1, 2]这个数组中不是1或者0的数，会继续分裂下去，比如两个2就继续分裂
[2, 1, 2] -> [1, 0, 1, 1, 1, 0, 1]
那么我们说，5最后分裂成[1, 0, 1, 1, 1, 0, 1]
每一个数都可以这么分裂，在最终分裂的数组中，假设下标从1开始
给定三个数n、l、r，返回n的最终分裂数组里[l,r]范围上有几个1
n <= 2 ^ 50，n是long类型
r - l <= 50000，l和r是int类型
我们的课加个码:
n是long类型随意多大都行
l和r也是long类型随意多大都行，但要保证l<=r

来自去哪儿网
给定一个arr，里面的数字都是0~9
你可以随意使用arr中的数字，哪怕打乱顺序也行
请拼出一个能被3整除的，最大的数字，用str形式返回

给定int[][] meetings，比如
{
   {66, 70}   0号会议截止时间66，获得收益70
   {25, 90}   1号会议截止时间25，获得收益90
   {50, 30}   2号会议截止时间50，获得收益30
 }
一开始的时间是0，任何会议都持续10的时间，但是一个会议一定要在该会议截止时间之前开始
只有一个会议室，任何会议不能共用会议室，一旦一个会议被正确安排，将获得这个会议的收益
请返回最大的收益

给定两个数组A和B，长度都是N
A[i]不可以在A中和其他数交换，只可以选择和B[i]交换(0<=i<n)
你的目的是让A有序，返回你能不能做到

来自腾讯
比如arr = {3,1,2,4}
下标对应是：0 1 2 3
你最开始选择一个下标进行操作，一旦最开始确定了是哪个下标，以后都只能在这个下标上进行操作
比如你选定1下标，1下标上面的数字是1，你可以选择变化这个数字，比如你让这个数字变成2
那么arr = {3,2,2,4}
下标对应是：0 1 2 3
因为你最开始确定了1这个下标，所以你以后都只能对这个下标进行操作，
但是，和你此时下标上的数字一样的、且位置连成一片的数字，会跟着一起变
比如你选择让此时下标1的数字2变成3，
那么arr = {3,3,3,4} 可以看到下标1和下标2的数字一起变成3，这是规则！一定会一起变
下标对应是：0 1 2 3
接下来，你还是只能对1下标进行操作，那么数字一样的、且位置连成一片的数字(arr[0~2]这个范围)都会一起变
决定变成4
那么arr = {4,4,4,4}
下标对应是：0 1 2 3
至此，所有数都成一样的了，你在下标1上做了3个决定(第一次变成2，第二次变成3，第三次变成4)，
因为联动规则，arr全刷成一种数字了
给定一个数组arr，最开始选择哪个下标，你随意
你的目的是一定要让arr都成为一种数字，注意联动效果会一直生效
返回最小的变化数
arr长度 <= 200, arr中的值 <= 10^6



41 大厂高频算法和数据结构面试题41

来自小红书
一个无序数组长度为n，所有数字都不一样，并且值都在[0...n-1]范围上
返回让这个无序数组变成有序数组的最小交换次数

来自小红书
有四种诗的韵律分别为: AABB、ABAB、ABBA、AAAA
比如 : 1 1 3 3就属于AABB型的韵律、6 6 6 6就属于AAAA型的韵律等等
一个数组arr，当然可以生成很多的子序列，如果某个子序列一直以韵律的方式连接起来，我们称这样的子序列是有效的
比如, arr = { 1, 1, 15, 1, 34, 1, 2, 67, 3, 3, 2, 4, 15, 3, 17, 4, 3, 7, 52, 7, 81, 9, 9 }
arr的一个子序列为{1, 1, 1, 1, 2, 3, 3, 2, 4, 3, 4, 3, 7, 7, 9, 9}
其中1, 1, 1, 1是AAAA、2, 3, 3, 2是ABBA、4, 3, 4, 3是ABAB、7, 7, 9, 9是AABB
可以看到，整个子序列一直以韵律的方式连接起来，所以这个子序列是有效的
 给定一个数组arr, 返回最长的有效子序列长度
题目限制 : arr长度 <= 4000, arr中的值<= 10^9

来自网易互娱
N个结点之间，表世界存在双向通行的道路，里世界存在双向通行的传送门.
若走表世界的道路，花费一分钟.
若走里世界的传送门，不花费时间，但是接下来一分钟不能走传送门.
输入： T为测试用例的组数，对于每组数据:
第一行：N M1 M2 N代表结点的个数1到N
接下来M1行 每行两个数，u和v，表示表世界u和v之间存在道路
接下来M2行 每行两个数，u和v，表示里世界u和v之间存在传送门
现在处于1号结点，最终要到达N号结点，求最小的到达时间 保证所有输入均有效，不存在环等情况

实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。
如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
必须 原地 修改，只允许使用额外常数空间。
示例 1：
输入：nums = [1,2,3]
输出：[1,3,2]
示例 2：
输入：nums = [3,2,1]
输出：[1,2,3]
示例 3：
输入：nums = [1,1,5]
输出：[1,5,1]
示例 4：
输入：nums = [1]
输出：[1]
leetcode题目 : https://leetcode.com/problems/next-permutation/



42 大厂高频算法和数据结构面试题42

给定一个二维数组cost[N][K], 
N表示有0...N-1这么多房子，所有房子排成一条直线，i号房子和i-1号房子相邻、也和i+1号房子相邻
K表示有0...K-1这么多颜色，每个房子都必须选择一种颜色
cost[i][j]表示i号房子涂上j颜色的花费，并且要求相邻的房子不能是一种颜色
返回所有房子都涂上颜色，最小的总花费
leetcode题目 : https://leetcode.com/problems/paint-house-ii/

给定一棵搜索二叉树的头节点root，搜索二叉树默认是没有重复值的，给定一个double类型的数target，给定一个正数k
请返回在这棵二叉树里最接近target的k个值，作为链表返回
要求：如果二叉树的节点个数为n，而k相比于n较小的话，实现时间复杂度低于O(n)的方法
leetcode题目 : https://leetcode.com/problems/closest-binary-search-tree-value-ii/

给定一个整数num，返回一个字符串str，是num的英文表达
leetcode题目 : https://leetcode.com/problems/integer-to-english-words/

二维矩阵中只有0和1，每个1可以上、下、左、右的移动
想让所有的1汇聚在一个点上开会，请返回所有1移动的最小距离和
leetcode题目 : https://leetcode.com/problems/best-meeting-point/

给定一个含有 n 个正数的数组 x。从点 (0,0) 开始，先向北移动 x[0] 米，然后向西移动 x[1] 米，向南移动 x[2] 米，向东移动 x[3] 米，持续移动
也就是说，每次移动后你的方位会发生逆时针变化
编写一个 O(1) 空间复杂度的一趟扫描算法，判断你所经过的路径是否相交。
leetcode题目 : https://leetcode.com/problems/self-crossing/



43 大厂高频算法和数据结构面试题43

来自微软面试
给定一个正数数组arr长度为n、正数x、正数y
你的目标是让arr整体的累加和<=0
你可以对数组中的数num执行以下三种操作中的一种，且每个数最多能执行一次操作 : 
1）不变
2）可以选择让num变成0，承担x的代价
3）可以选择让num变成-num，承担y的代价
返回你达到目标的最小代价
数据规模 : 面试时面试官没有说数据规模

来自360笔试
给定一个正数数组arr，长度为n，下标0~n-1
arr中的0、n-1位置不需要达标，它们分别是最左、最右的位置
中间位置i需要达标，达标的条件是 : arr[i-1] > arr[i] 或者 arr[i+1] > arr[i]哪个都可以
你每一步可以进行如下操作：对任何位置的数让其-1
你的目的是让arr[1~n-2]都达标，这时arr称之为yeah！数组
返回至少要多少步可以让arr变成yeah！数组
数据规模 : 数组长度 <= 10000，数组中的值<=500



44 大厂高频算法和数据结构面试题44

给定两个字符串low和high，它们只由数字字符组成，代表两个数字并且low<=high，返回在[low, high]范围上旋转有效串的数量
旋转有效串：一个字符串以中心点为支点，旋转180度之后依然是原来字符串，叫做旋转有效串，比如：
181旋转之后还是181，是旋转有效串
8008旋转之后还是8008，是旋转有效串
689旋转之后还是689，是旋转有效串
而6816就不是旋转有效串，因为旋转之后是9189
leetcode题目 : https://leetcode.com/problems/strobogrammatic-number-iii/

给定一个二维矩阵，其中的值0代表路，1代表人，2代表障碍
每个人都可以上下左右移动，但是只能走值为0的格子
想把所有的人聚集在某个值为0的地方开会，希望所有人到会议点的总距离最短
返回最短的开会总距离
如果无论如何都无法让所有的人聚集到一起，返回-1
leetcode题目 : https://leetcode.com/problems/shortest-distance-from-all-buildings/

给定一个正整数数组arr，和正数k
如果arr的某个子数组中含有k种不同的数，称这个子数组为有效子数组
返回arr中有效子数组的数量
leetcode题目 : https://leetcode.com/problems/subarrays-with-k-different-integers/



45 大厂高频算法和数据结构面试题45

来自京东笔试
小明手中有n块积木，并且小明知道每块积木的重量。现在小明希望将这些积木堆起来
要求是任意一块积木如果想堆在另一块积木上面，那么要求：
1) 上面的积木重量不能小于下面的积木重量
2) 上面积木的重量减去下面积木的重量不能超过x
3) 每堆中最下面的积木没有重量要求
现在小明有一个机会，除了这n块积木，还可以获得k块任意重量的积木。
小明希望将积木堆在一起，同时希望积木堆的数量越少越好，你能帮他找到最好的方案么？
输入描述:
第一行三个整数n,k,x，1<=n<=200000，0<=x,k<=1000000000
第二行n个整数，表示积木的重量，任意整数范围都在[1,1000000000]
样例输出：
n = 13 k = 1 x = 38
arr : 20 20 80 70 70 70 420 5 1 5 1 60 90
输出：2
解释：
两堆分别是
1 1 5 5 20 20 x 60 70 70 70 80 90
420
其中x是一个任意重量的积木，夹在20和60之间可以让积木继续往上搭

给定两个字符串pattern和s，返回s是否符合pattern的规定
这里的符合是指，pattern里的每个字母和字符串s中子串，存在着单一映射双向连接的对应
例子1：
输入：pattern = "abab", s = "redblueredblue"
输出：true
解释：
映射如下
'a' -> "red"
'b' -> "blue"
例子2
输入：pattern = "aaaa", s = "asdasdasdasd"
输出：true
解释:
映射如下
'a' -> "asd"
例子3
输入: pattern = "abab", s = "asdasdasdasd"
输出: true
解释:
映射如下
'a' -> "a"
'b' -> "sdasd"
例子4
输入：pattern = "aabb", s = "xyzabcxzyabc"
输出：false
Leetcode题目 : https://leetcode.com/problems/word-pattern-ii/

一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中
给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）
开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2 ）
如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃
示例 1：
输入：stones = [0,1,3,5,6,8,12,17]
输出：true
解释：青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。
示例 2：
输入：stones = [0,1,2,3,4,8,9,11]
输出：false
解释：这是因为第 5 和第 6 个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。
leetcode题目：https://leetcode.com/problems/frog-jump/

给你一个长度为 2 * n 的整数数组。你需要将 nums 分成 两个 长度为 n 的数组，分别求出两个数组的和，并 最小化 两个数组和之 差的绝对值 。nums 中每个元素都需要放入两个数组之一。
请你返回 最小 的数组和之差。
数据范围：
1 <= n <= 15
nums.length == 2 * n
-10^7 <= nums[i] <= 10^7
leetcode题目：https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/



46 大厂高频算法和数据结构面试题46

给你一个 m x n 的矩阵 matrix 和一个整数 k ，找出并返回矩阵内部矩形区域的不超过 k 的最大数值和。
题目数据保证总会存在一个数值和不超过 k 的矩形区域。
leetcode题目：https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/

我们有 N 个与坐标轴对齐的矩形, 其中 N > 0, 判断它们是否能精确地覆盖一个矩形区域。
每个矩形用左下角的点和右上角的点的坐标来表示。例如， 一个单位正方形可以表示为 [1,1,2,2]。 ( 左下角的点的坐标为 (1, 1) 以及右上角的点的坐标为 (2, 2) )。
示例 1:
rectangles = [
  [1,1,3,3],
  [3,1,4,2],
  [3,2,4,4],
  [1,3,2,4],
  [2,3,3,4]
]
返回 true。5个矩形一起可以精确地覆盖一个矩形区域。
示例 2:
rectangles = [
  [1,1,2,3],
  [1,3,2,4],
  [3,1,4,2],
  [3,2,4,4]
]
返回 false。两个矩形之间有间隔，无法覆盖成一个矩形。
示例 3:
rectangles = [
  [1,1,3,3],
  [3,1,4,2],
  [1,3,2,4],
  [3,2,4,4]
]
返回 false。图形顶端留有间隔，无法覆盖成一个矩形。
示例 4:
rectangles = [
  [1,1,3,3],
  [3,1,4,2],
  [1,3,2,4],
  [2,2,4,4]
]
返回 false。因为中间有相交区域，虽然形成了矩形，但不是精确覆盖。
leetcode题目：https://leetcode.com/problems/perfect-rectangle/

一个字符串可以用缩写的形式来代替，比如单词"substitution"，可以有以下几种缩写：
"s10n" ("s+省略10个字符+n")
"sub4u4" ("sub+省略4个字符+u+省略4个字符")
"12" ("省略12个字符")
等等还有很多
给定一个字符串target、给定一个字符串数组作为字典dictionary，要求把target缩写成长度最短的形式，但是又不会和dictionary中任何单词混淆
返回缩写最短形式的一种结果就可以
例子1：
输入：target = "apple", dictionary = ["blade"]
输出: "a4"
解释：
"apple"最短的缩写是"5"，但是字典中"blade"长度也是5，所以会混淆
"apple"第二短的缩写，有一种是"4e"，但是"4e"也可以是字典中"blade"，所以会混淆
"apple"第二短的缩写，有一种是"a4"，字典中"blade"不以a开头，所以不会混淆
例子2：
输入: target = "apple", dictionary = ["blade","plain","amber"]
输出: "1p3"
leetcode题目：https://leetcode.com/problems/minimum-unique-word-abbreviation/

给定n个字符串，并且每个字符串长度一定是n，请组成单词方阵，比如：
给定4个字符串，长度都是4，["ball","area","lead","lady"]
可以组成如下的方阵：
b a l l
a r e a
l e a d
l a d y
什么叫单词方阵？如上的方阵可以看到，第1行和第1列都是"ball"，第2行和第2列都是"area"，第3行和第3列都是"lead"，第4行和第4列都是"lady"
所以如果有N个单词，单词方阵是指，一个N*N的二维矩阵，并且i行和i列都是某个单词，不要求全部N个单词都在这个方阵里。
请返回所有可能的单词方阵。
示例：
输入: words = ["abat","baba","atan","atal"]
输出: [["baba","abat","baba","atal"],["baba","abat","baba","atan"]]
解释：
可以看到输出里，有两个链表，代表两个单词方阵
第一个如下：
b a b a
a b a t
b a b a
a t a l
这个方阵里没有atan，因为不要求全部单词都在方阵里
第二个如下：
b a b a
a b a t
b a b a
a t a n
这个方阵里没有atal，因为不要求全部单词都在方阵里
leetcode题目：https://leetcode.com/problems/word-squares/



47 大厂高频算法和数据结构面试题47

动态开点线段树详解

给你一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。
输入：nums = [5,2,6,1]
输出：[2,1,1,0] 
解释：
5 的右侧有 2 个更小的元素 (2 和 1)
2 的右侧仅有 1 个更小的元素 (1)
6 的右侧有 1 个更小的元素 (1)
1 的右侧有 0 个更小的元素
leetcode题目：https://leetcode.com/problems/count-of-smaller-numbers-after-self/

给定一个字符串s和一个正数k，重新组织s使得每一种相同的字符距离至少有k，如果无法做到返回空字符串
示例1：
输入：s = "aabbcc", k = 3
输出："abcabc"
示例2：
输入：s = "aaabc", k = 3
输出：""
示例3：
输入：s = "aaadbbcc", k = 2
输出： "abacabcd"
leetcode题目：https://leetcode.com/problems/rearrange-string-k-distance-apart/

设计多叉树的序列化和反序列化方案
序列化：给定一棵多叉树的头节点，把整棵二叉树变成一个字符串返回
反序列化：给定一个字符串，一定是某棵多叉树的序列化结果，生成整棵多叉树并返回头节点
leetcode题目：https://leetcode.com/problems/serialize-and-deserialize-n-ary-tree/

一开始所有人手上都是0元钱，[a,b,c]代表，a给b了c元钱。有很多这样的转账记录
那么所有转账完成后，有的人剩余的钱是正数，有的人剩余的钱是负数
现在想重新让所有人的钱都是0元，也就是回到初始状态，请问最少多少笔转账可以做到这一点
例子1：
输入：[[0,1,10],[2,0,5]]
输出：2
解释：0号转给1号10元，2号转给0号5元。上面所有转账完成后：0号-5，1号10，2号-5
所以如果想所有人的钱都是0元，1号需要分别给0号和2号转账5元。所以最少2笔转账。
例子2：
输入：[[0,1,10],[1,0,1],[1,2,5],[2,0,5]]
输出：1
解释：如上的转账完成后，0号-4元，1号4元，2号0元，所以如果想所有人的钱都是0元，1号需要给0号转账4元。所以最少1比交易。
leetcode题目：https://leetcode.com/problems/optimal-account-balancing/

冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。
在加热器的加热半径范围内的每个房屋都可以获得供暖。
现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。
说明：所有供暖器都遵循你的半径标准，加热的半径也一样。
示例 1:
输入: houses = [1,2,3], heaters = [2]
输出: 1
解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。
示例 2:
输入: houses = [1,2,3,4], heaters = [1,4]
输出: 1
解释: 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。
示例 3：
输入：houses = [1,5], heaters = [2]
输出：3
leetcode题目：https://leetcode.com/problems/heaters/



48 大厂高频算法和数据结构面试题48

来自学员问题
比如{ 5, 3, 1, 4 }
全部数字对是：(5,3)、(5,1)、(5,4)、(3,1)、(3,4)、(1,4)
数字对的差值绝对值： 2、4、1、2、1、3
差值绝对值排序后：1、1、2、2、3、4
给定一个数组arr，和一个正数k
返回arr中所有数字对差值的绝对值，第k小的是多少
arr = { 5, 3, 1, 4 }, k = 4
返回2

给定一个 不含重复 单词的字符串数组 words ，编写一个程序，返回 words 中的所有 连接词 。
连接词 的定义为：一个字符串完全是由至少两个给定数组中的单词组成的。
示例 1：
输入：words = ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]
输出：["catsdogcats","dogcatsdog","ratcatdogcat"]
解释："catsdogcats"由"cats", "dog" 和 "cats"组成; 
     "dogcatsdog"由"dog", "cats"和"dog"组成; 
     "ratcatdogcat"由"rat", "cat", "dog"和"cat"组成。
示例 2：
输入：words = ["cat","dog","catdog"]
输出：["catdog"]
leetcode题目：https://leetcode.com/problems/concatenated-words/

对于给定的整数 n, 如果n的k（k>=2）进制数的所有数位全为1，则称 k（k>=2）是 n 的一个好进制。
以字符串的形式给出 n, 以字符串的形式返回 n 的最小好进制。
示例 1：
输入："13"
输出："3"
解释：13 的 3 进制是 111。
示例 2：
输入："4681"
输出："8"
解释：4681 的 8 进制是 11111。
示例 3：
输入："1000000000000000000"
输出："999999999999999999"
解释：1000000000000000000 的 999999999999999999 进制是 11。
leetcode题目：https://leetcode.com/problems/smallest-good-base/

给定一个二维数组代表迷宫，0代表路，1代表障碍
给定一个球的位置，给定一个洞的位置
你每次可以拨动球往上、下、左、右四个方向中的一个移动，但是球只有撞倒边界或者障碍才会停，只有球停了，你才能再次拨动球。
你的目标是让球进洞，球在移动的过程中只要来到洞的位置，就认为球直接掉进洞里。你需要先保证球进洞的过程中，球移动的距离最短
如果只有一种方案，直接返回这种方案的决定。
如果有多个距离最短的方案，你需要返回其中字典序最小的决定。
比如，假设如下两个方案，球的移动距离都是最小的:
先往左拨动，球撞了墙之后，再往上拨，结果球进洞了，那么决定就是"lu" -> left up
先往上拨动，球撞了墙之后，再往左拨，结果球进洞了，那么决定就是"ul" -> up left
这两个方案如果都是移动距离最小的，那么应该返回lu，因为ul的字典序大
leetcode题目：https://leetcode.com/problems/the-maze-iii/



49 大厂高频算法和数据结构面试题49

给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。
题目数据保证答案符合 32 位整数范围。
leetcode题目：https://leetcode.com/problems/combination-sum-iv

给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字。
注意：1 ≤ k ≤ n ≤ 10^9。
示例 :
输入:
n: 13   k: 2
输出:
10
解释:
字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。
leetcode题目：https://leetcode.com/problems/k-th-smallest-in-lexicographical-order/

给你一个整数数组 nums ，返回 nums 中所有 等差子序列 的数目。
如果一个序列中 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该序列为等差序列。
例如，[1, 3, 5, 7, 9]、[7, 7, 7, 7] 和 [3, -1, -5, -9] 都是等差序列。
再例如，[1, 1, 2, 5, 7] 不是等差序列。
数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。
例如，[2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。
题目数据保证答案是一个 32-bit 整数。
示例 1：
输入：nums = [2,4,6,8,10]
输出：7
解释：所有的等差子序列为：
[2,4,6]
[4,6,8]
[6,8,10]
[2,4,6,8]
[4,6,8,10]
[2,4,6,8,10]
[2,6,10]
示例 2：
输入：nums = [7,7,7,7,7]
输出：16
解释：数组中的任意子序列都是等差子序列。
leetcode题目：https://leetcode.com/problems/arithmetic-slices-ii-subsequence/

如下是机器人的类
interface Robot {
  // 如果机器人面朝的方向没有障碍，那么机器人将移动一步，并且返回true
  // 如果机器人面朝的方向有障碍，那么机器人将停在原地，并且返回false
  boolean move();
  //机器人面朝的方向向左转动90度
  void turnLeft();
  //机器人面朝的方向向右转动90度
  void turnRight();
  // 机器人执行原地打扫的动作
  void clean();
}
机器人将空降在房屋的某个地点，这一片局域会有障碍物，房屋的整片区域也一定有边界，边界等同于障碍
房屋的整片区域假设是由1*1的格子拼成的，并且机器人自己占地也是1*1的格子
但是你只能通过机器人的move方法，来让机器人移动并且探知障碍
当然也可以让机器人通过turnLeft或者turnRight方法，来改变面朝的方向
你如何只通过调用上面提到的方法，就控制机器人打扫房间的每个格子
请实现如下的这个方法：
public void cleanRoom(Robot robot) 
leetcode题目：https://leetcode.com/problems/robot-room-cleaner/

规定单词一定要遵循如下的缩写规则：
1）一个单词保留若干长度的前缀，以及保留最后一个字符，中间用数字代表长度的方式来缩写
2）如果缩写后的长度没有原始长度小，则该缩写依然保持原始串的样子
比如:
apple可以缩写成"a3e"，表示保留长度为1的前缀"a"，以及保留最后一个字符"e"，中间用3来代表"ppl"的长度。
apple也可以缩写成"ap2e"，表示保留长度为2的前缀"ap"，以及保留最后一个字符"e"，中间用2来代表"pl"的长度。
apple也可以缩写成"app1e"，但是因为"app1e"没有原始长度小，所以该缩写不能写成"app1e"，应该写成"apple"
也就是说，你可以去选择保留前缀的长度，一旦前缀确定，那么缩写剩下的内容也就都决定了。因为一定要保留最后一个字符，以及中间部分用数字代表长度。
理解了缩写规定之后，请理解对几个字符串都做缩写，但是不能混淆的规定。
比如："abkkf"和"abcde"
"abkkf"缩写为"a3f"，"abcde"缩写为"a3e"，两个字符串的缩写都能变得最短，且不会混淆。因为最后的字符不一样，所以可以区分开
比如："abkkkkc"和"abkskkc"
"abkkkkc"缩写为"a5c"，"abkskkc"缩写为"a5c"，此时发现会混淆，因为缩写之后完全一样
"abkkkkc"缩写为"abkk2c"，"abkskkc"缩写为"abks2c"，这是两个字符串缩写都尽可能短，且不会混淆的缩写。
给你一个字符串数组arr，请完成对每个字符串的缩写，要求任意两个字符串都不会混淆，且每个字符串的缩写都尽可能的短。
例子一
输入：["like","god","internal","me","internet","interval","intension","face","intrusion"]
输出：["l2e","god","internal","me","i6t","interval","inte4n","f2e","intr4n"]
例子二
输入: words = ["aa","aaa"]
输出: ["aa","aaa"]
leetcode题目：https://leetcode.com/problems/word-abbreviation/

给定一个数组nums，请将nums切三刀，切出四个部分，被切的数字不算，要求每个部分累加和都一样大，返回能不能做到
比如
输入：nums = [1,2,1,2,1,2,1]
输出：true
解释：
三刀的位置分别为，i = 1, j = 3, k = 5，切完后这三个位置的数不算
所以切出的四个部分为(1) (1) (1) (1)，所以能做到返回true
leetcode题目：https://leetcode.com/problems/split-array-with-equal-sum/

给定一个整数 n ，你需要找到与它最近的回文数（不包括自身）。
“最近的”定义为两个整数差的绝对值最小。
示例 1:
输入: "123"
输出: "121"注意:
n 是由字符串表示的正整数，其长度不超过18。
如果有多个结果，返回最小的那个。
leetcode题目：https://leetcode.com/problems/find-the-closest-palindrome/



50 大厂高频算法和数据结构面试题50

力扣想让一个最优秀的员工在 N 个城市间旅行来收集算法问题。
但只工作不玩耍，聪明的孩子也会变傻，所以您可以在某些特定的城市和星期休假。
您的工作就是安排旅行使得最大化你可以休假的天数，但是您需要遵守一些规则和限制。
规则和限制：
您只能在 N 个城市之间旅行，用 0 到 N-1 的索引表示。一开始，您在索引为0的城市，并且那天是星期一。
这些城市通过航班相连。这些航班用 N*N 矩阵 flights（不一定是对称的）表示，flights[i][j] 代表城市i到城市j的航空状态。如果没有城市i到城市j的航班，
flights[i][j] = 0；否则，flights[i][j] = 1。同时，对于所有的 i，flights[i][i] = 0。
您总共有 K 周（每周7天）的时间旅行。您每天最多只能乘坐一次航班，并且只能在每周的星期一上午乘坐航班。由于飞行时间很短，我们不考虑飞行时间的影响。
对于每个城市，不同的星期您休假天数是不同的，给定一个 N*K 矩阵 days 代表这种限制，days[i][j] 代表您在第j个星期在城市i能休假的最长天数。
给定 flights 矩阵和 days 矩阵，您需要输出 K 周内可以休假的最长天数。
leetcode题目：https://leetcode.com/problems/maximum-vacation-days/

凸包问题经典题
在一个二维的花园中，有一些用 (x, y) 坐标表示的树。由于安装费用十分昂贵，你的任务是先用最短的绳子围起所有的树。只有当所有的树都被绳子包围时，花园才能围好栅栏。你需要找到正好位于栅栏边界上的树的坐标。
leetcode题目：https://leetcode.com/problems/erect-the-fence/

设计一个数据结构，和文件系统很像
类中的方法如下：
FileSystem()：初始化这个数据结构
List<String> ls(String path)：如果根据路径path找到的是文件，列出这个文件的名字，如果path找到的是文件夹，列出这个文件夹里的所有文件夹和文件名。（就像ls命令一样）
void mkdir(String path)：根据path路径建出文件夹，如果中间的文件夹缺失，一路都建立出来。
void addContentToFile(String filePath, String content)：根据filePath路径找到文件，如果不存在就新建。然后把内容content加在这个文件的尾部。
String readContentFromFile(String filePath)：根据filePath读出文件内容并返回。
leetcode题目：https://leetcode.com/problems/design-in-memory-file-system/

给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含 连续的1 的个数。
示例 1:
输入: 5
输出: 5
解释: 
下面是带有相应二进制表示的非负整数<= 5：
0 : 0
1 : 1
2 : 10
3 : 11
4 : 100
5 : 101
其中，只有整数3违反规则（有两个连续的1），其他5个满足规则。
说明：1 <= n <= 10^9
leetcode题目：https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/



51 大厂高频算法和数据结构面试题51

力扣团队买了一个可编程机器人，机器人初始位置在原点(0, 0)。小伙伴事先给机器人输入一串指令command，机器人就会无限循环这条指令的步骤进行移动。指令有两种：
U: 向y轴正方向移动一格
R: 向x轴正方向移动一格。
不幸的是，在 xy 平面上还有一些障碍物，他们的坐标用obstacles表示。机器人一旦碰到障碍物就会被损毁。
给定终点坐标(x, y)，返回机器人能否完好地到达终点。如果能，返回true；否则返回false。
示例 1：
输入：command = "URR", obstacles = [], x = 3, y = 2
输出：true
解释：U(0, 1) -> R(1, 1) -> R(2, 1) -> U(2, 2) -> R(3, 2)。
示例 2：
输入：command = "URR", obstacles = [[2, 2]], x = 3, y = 2
输出：false
解释：机器人在到达终点前会碰到(2, 2)的障碍物。
示例 3：
输入：command = "URR", obstacles = [[4, 2]], x = 3, y = 2
输出：true
解释：到达终点后，再碰到障碍物也不影响返回结果。
限制：
2 <= command的长度 <= 1000
command由U，R构成，且至少有一个U，至少有一个R
0 <= x <= 1e9, 0 <= y <= 1e9
0 <= obstacles的长度 <= 1000
obstacles[i]不为原点或者终点
链接：https://leetcode-cn.com/problems/programmable-robot/

这里有 n 门不同的在线课程，他们按从 1 到 n 编号。每一门课程有一定的持续上课时间（课程时间）t 以及关闭时间第 d 天。一门课要持续学习 t 天直到第 d 天时要完成，你将会从第 1 天开始。
给出 n 个在线课程用 (t, d) 对表示。你的任务是找出最多可以修几门课。
示例：
输入: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]
输出: 3
解释: 
这里一共有 4 门课程, 但是你最多可以修 3 门:
首先, 修第一门课时, 它要耗费 100 天，你会在第 100 天完成, 在第 101 天准备下门课。
第二, 修第三门课时, 它会耗费 1000 天，所以你将在第 1100 天的时候完成它, 以及在第 1101 天开始准备下门课程。
第三, 修第二门课时, 它会耗时 200 天，所以你将会在第 1300 天时完成它。
第四门课现在不能修，因为你将会在第 3300 天完成它，这已经超出了关闭日期。
提示:
整数 1 <= d, t, n <= 10,000 。
你不能同时修两门课程。
leetcode题目：https://leetcode.com/problems/course-schedule-iii/

为搜索引擎设计一个搜索自动完成系统。用户可以输入一个句子(至少一个单词，并以一个特殊的字符'#'结尾)。
对于除'#'之外的每个字符，您需要返回与已输入的句子部分前缀相同的前3个历史热门句子。具体规则如下:
一个句子的热度定义为用户输入完全相同句子的次数。 返回的前3个热门句子应该按照热门程度排序(第一个是最热的)。
如果几个句子的热度相同，则需要使用ascii代码顺序(先显示较小的一个)。 如果少于3个热门句子，那么就尽可能多地返回。 
当输入是一个特殊字符时，它意味着句子结束，在这种情况下，您需要返回一个空列表。 您的工作是实现以下功能:
构造函数:
AutocompleteSystem(String[] sentence, int[] times):这是构造函数。输入是历史数据。
句子是由之前输入的句子组成的字符串数组。Times是输入一个句子的相应次数。您的系统应该记录这些历史数据。
现在，用户想要输入一个新句子。下面的函数将提供用户类型的下一个字符:
List input(char c)：输入c是用户输入的下一个字符。字符只能是小写字母(“a”到“z”)、空格(“”)或特殊字符(“#”)。
另外，前面输入的句子应该记录在系统中。输出将是前3个历史热门句子，它们的前缀与已经输入的句子部分相同。
例子: 
操作:AutocompleteSystem(["i love you"， "island"，"ironman"， "i love leetcode"]， [5,3,2,2]) 系统已经追踪到以下句子及其对应的时间:
"i love you" : 5 times 
"island" : 3 times 
"ironman" : 2 times 
"i love leetcode" : 2 times
现在，用户开始另一个搜索:
操作:输入(“i”) 输出:["i love you"， "island"，"i love leetcode"]
解释: 有四个句子有前缀“i”。其中，《ironman》和《i love leetcode》有着相同的热度。既然“ ” ASCII码为32，“r”ASCII码为114，
那么“i love leetcode”应该在“ironman”前面。此外，我们只需要输出前3个热门句子，所以“ironman”将被忽略。
操作:输入(' ') 输出:[“i love you”，“i love leetcode”] 解释: 只有两个句子有前缀“i”。
操作:输入(' a ') 输出:[] 解释: 没有以“i a”为前缀的句子。
操作:输入(“#”) 输出:[] 解释: 用户完成输入后，在系统中将句子“i a”保存为历史句。下面的输入将被计算为新的搜索。
注意:
输入的句子总是以字母开头，以“#”结尾，两个单词之间只有一个空格。 
要搜索的完整句子不会超过100个。包括历史数据在内的每句话的长度不会超过100句。
设计一个搜索自动补全系统，它需要包含如下两个方法：
构造方法：
AutocompleteSystem(String[] sentences, int[] times): 输入句子sentences，及其出现次数times
输入方法：
List input(char c): 输入字符c可以是26个小写英文字母，也可以是空格，以'#'结尾。返回输入字符前缀对应频率最高的至多3个句子，频率相等时按字典序排列。
leetcode题目：https://leetcode.com/problems/design-search-autocomplete-system/

珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。
珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  
珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。
返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。
示例 1：
输入: piles = [3,6,7,11], H = 8
输出: 4
示例 2：
输入: piles = [30,11,23,4,20], H = 5
输出: 30
示例 3：
输入: piles = [30,11,23,4,20], H = 6
输出: 23
leetcode题目：https://leetcode.com/problems/koko-eating-bananas/

在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。
现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：
nums1[i] == nums2[j]
且绘制的直线不与任何其他连线（非水平线）相交。
请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。
以这种方法绘制线条，并返回可以绘制的最大连线数。
leetcode题目：https://leetcode.com/problems/uncrossed-lines/



52 大厂高频算法和数据结构面试题52

给定一个数组arr，arr[i] = j，表示来到i位置需要承受j的代价。给定一个正数jump，表示任何位置都可以随意往右跳<=jump步。
要求你从1位置开始，跳到数组最后位置n，在保证最小代价的前提下，返回字典序最小的路径
leetcode题目：https://leetcode.com/problems/coin-path/

给定一个数组bulbs，bulds[i] = j，表示第i天亮起的灯是j。任何一天只会亮一盏灯，如果天数有1~i天，那么灯也一定只有1~i号。
给定一个正数k，如果两盏亮起的灯之间有正好k个不亮的灯，那么说这个是达标情况。
返回最早在哪一天，会出现达标情况，如果不存在达标情况，返回-1
leetcode题目：https://leetcode.com/problems/k-empty-slots/

你的国家有无数个湖泊，所有湖泊一开始都是空的。当第 n 个湖泊下雨的时候，如果第 n 个湖泊是空的，那么它就会装满水，否则这个湖泊会发生洪水。你的目标是避免任意一个湖泊发生洪水。
给你一个整数数组 rains ，其中：
rains[i] > 0 表示第 i 天时，第 rains[i] 个湖泊会下雨。
rains[i] == 0 表示第 i 天没有湖泊会下雨，你可以选择 一个 湖泊并 抽干 这个湖泊的水。
请返回一个数组 ans ，满足：
ans.length == rains.length
如果 rains[i] > 0 ，那么ans[i] == -1 。
如果 rains[i] == 0 ，ans[i] 是你第 i 天选择抽干的湖泊。
如果有多种可行解，请返回它们中的 任意一个 。如果没办法阻止洪水，请返回一个 空的数组 。
leetcode题目：https://leetcode.com/problems/avoid-flood-in-the-city/


