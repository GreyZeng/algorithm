# 二叉树递归套路 O(N)

## 是否完全二叉树

LeetCode_0958_CheckCompletenessOfABinaryTree.java

## 是否为平衡二叉树

LeetCode_0110_BalancedBinaryTree.java

## 是否为搜索二叉树

LeetCode_0098_ValidateBinarySearchTree.java

## 二叉树的最大距离

边代表距离 LeetCode_0543_DiameterOfBinaryTree

节点数代表距离 Code_0042_MaxDistance

边 = 节点 - 1

## 是否为满二叉树

Code_0046_IsFull.java

## 二叉树中最大的二叉搜索子树的大小

Code_0079_MaxSubBSTSize.java

## 二叉树中最大的二叉搜索子树的头节点

Code_0043_MaxSubBSTHead.java

## 给定一棵二叉树的头节点head，和另外两个节点a和b, 返回a和b的最低公共祖先

> 常规方法：遍历二叉树，遍历的节点把父节点记录到Map中，然后找所有父节点，用Set来判断

LeetCode_0236_LowestCommonAncestorOfBinaryTree.java

## 派对最大快乐值问题

Code_0080_MaxHappy.java

---

## 给定一棵二叉搜索树的头节点head,和另外两个节点a和b，返回a和b的最低公共祖先

LeetCode_0235_LowestCommonAncestorOfABinarySearchTree.java

## 二叉树最大路径和

LeetCode_0124_BinaryTreeMaximumPathSum.java
