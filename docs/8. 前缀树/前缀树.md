## 前缀树

p: 某个字符经过几次
e: 以某个字符结尾有几次
头节点开始

- 所有字符串有多少以某几个字符作为前缀
- 某个字符串是否包含在其中

Code_0030_TrieTree.java

两种实现，如果字符固定， 可以用数组，如果字符不固定Hash表实现


需要注意前缀树的删除节点操作，有可能删除的节点后续的路没用了。（防止内存泄露）
ab
abcvdk
这两个字符串
如果要删掉abcvdk这个字符串，那么通向c v d k节点的路可以全部删除（p=0以下的节点都没有了）

LeetCode_0208_Trie
LeetCode_0139_WordBreak
LeetCode_0140_WordBreakII



最大子数组的异或和
NowCoder_MaxXorSubArray.java
tips:
方法1：暴力解O(N^3)
方法2：O(N^2) 前缀异或和 辅助数组
方法3：前缀树
[11,1,15,10,13,4]
e[-1] = 0000
e[0..0] = 11 = 1011
e[0..1] = 11^1 = 1010
e[0..2] = 0101
e[0..3] = 1111
e[0..4] = 0010
e[0..5] = 0110
这些数构造成前缀树
最高位（符合位）期待一样，紧着高位要期待不一样的

类似题目：
NowCoder_MostZeroSplitEor.java
数组划分的部分进行异或和生成的0最多
[321 | 0 | 4 | 321 | 0 | 0 | 312 | 0 | 213]
tips:
假设答案法（子数组的最大累加和也用到了这个方法），
假设[0..i]异或和为sum
sum上次出现的位置j，
dp[i] = max{dp[i-1] , dp[j] + 1}


假设所有字符都是小写字母.   长字符串是str
arr是去重的单词表, 每个单词都不是空字符串且可以使用任意次
使用arr中的单词有多少种拼接str的方式，返回方法数.
LeetCode_0140_WordBreakII.java
tips:
前缀树