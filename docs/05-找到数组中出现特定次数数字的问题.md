# 找到数组中出现特定次数数字的问题

## 问题一：一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数

[牛客-NowCoder_EvenOddTimes](https://www.nowcoder.com/questionTerminal/d0ef3e33e63a49dd99c90aeef306b0fc)

[LeetCode_0136_SingleNumber](https://leetcode-cn.com/problems/single-number/)

### 问题一解题思路

因为`a ^ a = 0`, 所以出现过偶次的数异或结果都是`0`，又因为`0^a=a`，所以把数组中所有的数做`异或`以后的结果，就是出现了奇数次的那个数。

### 问题一完整代码

```java
public class LeetCode_0136_SingleNumber {

    public static int singleNumber(int[] nums) {
        int ans = nums[0];
        for (int i = 1; i < nums.length; i++) {
            ans ^= nums[i];
        }
        return ans;
    }
}
```

## 问题二：一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数

[LeetCode_0260_SingleNumberIII](https://leetcode-cn.com/problems/single-number-iii/)

### 问题二解题思路

根据问题一的结论，假设数组中`a`和`b`这两个数出现了奇数次，这个数组中的所有数字异或以后得到的结果一定`a^b`

因为`a`和`b`是两种不同的数，所以`a^b`的结果一定不等于0。

所以，`a^b`的结果如果转换成二进制的话，一定有某位是1。我们假设`a^b`转换成二进制后最右侧位置的1在i位置，由此可以得出一个结论：**a和b的二进制在i位置一定一个为0，一个为1**

不妨假设`a`的`i`位置为`0`，`b`的`i`位置为`1`。

此外，容易得知，整个数组中的数，`i`位置为`0`的数除了`a`以外，其他数一定有偶数个， `i`位置为`1`的数除了`b`之外，其他数一定有偶数个。

那么我们可以**只对**`i`位置为`1`的数求异或，最后得到的值一定是`b`，然后通过`b^(a^b) = a`，可以得到`a`的值。

最后只剩下一个问题：

**如何求一个数最右侧的1呢?**

假设 某个数x二进制为：`00010010`, 其最右侧的1是：`00000010`。

算法是：对于一个数`x`来说，它最右侧的`1`等于`x & ((~x) + 1)`或者`x & (-x)`

所以，如果一个数是`a^b`，那么它最右侧的`1`就是`(a^b) & (~(a^b) + 1)`

我们用`(a^b) & (~(a^b) + 1)`这个值去和数组中每个值数做与运算(&)，如果与完以后的结果是`0`，说明这个数`i`位置是`0`，否则说明这个数`i`位置是`1`。我们前面已经得到一个结论，`i`位置为`0`的数除了`a`以外，其他数一定有偶数个。所以，用`(a^b) & (~(a^b) + 1)`这个值和每个`i`位置是`0`的数组元素做与运算以后，最后的结果一定是`a`。 得到`a`以后，然后通过`a^(a^b) = b`，可以得到`b`的值。

### 问题二完整代码

```java
public class LeetCode_0260_SingleNumberIII {
    public static int[] singleNumber(int[] arr) {
        int eor = 0;
        for (int n : arr) {
            eor ^= n;
        }
        // 假设出现奇数次的两种数为 a和b
        // eor = a ^ b
        // 获取最右侧的1
        int a = 0;
        int rightOne = eor & ((~eor) + 1);
        for (int n : arr) {
            if ((n & rightOne) == 0) {
                a ^= n;
            }
        }
        int b = a ^ eor;
        return new int[]{a, b};
    }
}
```

当有如下公式计算一个数最右侧的`1`以后

```text
x & ((~x) + 1)
```

我们还可以解决如下问题：

[LeetCode_0191_NumberOfOneBits](https://leetcode-cn.com/problems/number-of-1-bits/)

思路：即提取出最右侧的`1`以后，与目标数进行与运算(&), 得到一个新的目标数，然后继续提取新目标数的最右侧的`1`，如此往复，即可把所有位置的`1`都提取出来。

## 问题三 一个数组中有一种数出现k次，其他数都出现了m次，m > 1,  k < m, 找到出现了k次的数

要求：**假设数组中所有数都是int类型，额外空间复杂度O(1)，时间复杂度O(N)**

[LeetCode_0137_SingleNumberII](https://leetcode-cn.com/problems/single-number-ii/)

[NowCoder_FindOneInK](https://www.nowcoder.com/practice/26e46f1f5e0d48c4b9ba13fe3e8d0ec6)

### 问题三解题思路

我们可以这样考虑，设置一个32位的数组，

```java
int[] help = new int[32];
```

遍历原始数组中每个数num的每一个二进制位, 伪代码如下：

```java
for (int num : arr) {
  for (int i = 0; i < 32; i++) {
    help[i] += num的二进制中i位置的值(只能是0或者1)
  }
}
```

经过以上循环，`help`数组就把数组中的所有数的二进制位上的信息累加起来了。

`help[0]`表示数组中所有数二进制中0位置的值之和；

`help[1]`表示数组中所有数二进制中1位置的值之和；

......

`help[31]`表示数组中所有数二进制中31位置的值之和。

然后`i`从`0`位置开始拿出`help[i]`的值，假设`help[i]=x`，用`x % m`, 如果结果是`k`，说明出现`k`次的元素在这个位置上是`1`, 否则，这个出现了`k`次的数在`i`位置上是`0`, 遍历完`help`数组，出现`k`次元素的每一位信息都拿到了，然后还原出来即可。

### 问题三关键代码

```java
public static int km(int[] arr, int k, int m) {
  int[] helper = new int[32];
  for (int i = 0; i < arr.length; i++) {
   for (int j = 0; j < 32; j++) {
    helper[j] += ((arr[i] >> j) & 1);
   }
  }
  int ans = 0;
  for (int i = 0; i < 32; i++) {
   if (helper[i] % m == k) {
    ans |= (1 << i);
   }
  }
  return ans;
 }
```

## 更多

[算法和数据结构笔记](https://github.com/GreyZeng/algorithm)

## 参考资料

- [程序员代码面试指南（第2版）](https://book.douban.com/subject/30422021/)
- [算法和数据结构基础班-左程云](https://ke.qq.com/course/2145184)
- [极客时间-数据结构与算法之美-王争](https://time.geekbang.org/column/intro/126)
- [算法(第四版)](https://book.douban.com/subject/19952400/)
