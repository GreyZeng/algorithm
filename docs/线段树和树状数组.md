## 线段树

某个区间内的元素修改增加和求和

void add(L, R, V, arr) ---> L..R上都加V void update(L, R, V, arr)---> L..R上都变成V void getSum(L, R, arr)---> L..R上求和
以上方法都要达到log(N)的水平

以上方法可以任意调用可以正确

arr是2的n次方 arr如果不满足2的n次方，要变成满二叉树，补0，比如1-6，7和8补0

如果N满足2的某次方，则仅需要2N个区间就可以装下，如果不满足2的某次方，则仅需要4N个区间就可以装下

线段树这里的下标都用1开始，0位置弃而不用 任意位置：i，左孩子对应的下标是2i（就是：i<<1），右孩子对应的下标是：2i+1
(就是：(i<<1)|1)

准备4N个数 MAXN << 2

懒更新机制

add 方法 如果节点包括任务，就不需要下发，存在lazy信息中，如果没有包住，就要下发 ---》 log（N） 当新的任务到的时候，如果自己原先有懒信息的时候，则当前节点把懒信息发给左孩子和右孩子，然后把懒的信息置为0

update 方法 change[] update[] 配合使用  
如果一个节点收到一个update方法，假设更新为C（存在change数组中），则这个节点的所有lazy失效，sum直接变成 ： 个数C

query方法 返回sum

## 树状数组

数组在不变的情况下 前缀和数组 可以加速生成i-j位置的累加和信息

如果数组要单点修改，则以上的情况不适用

树状数组就是解决这个问题 log（N)

线段树是树状数组的升级版 （奇数）二进制最后一位是1：则只管自己这个位置的内容 偶数 0010 管 0001 ~ 0010 00100 管 00001 ~ 00100 0110 管 0101 ~ 0110

一般地 1010111000 管 1010110001 ~ 1010111000

单点更新的时候，改了某个值，要关心到底哪些位置受到了牵连

单点的二进制最末尾的1+1，依次到数组结尾，都是受到牵连的 一个数最右侧的1 ： index & (-index)  或者 index & (~index + 1)

只支持单点修改，如果多次修改，一个一个调用

index tree方便改成二维和三维的index tree

单调栈 可以用来解决最大仰角问题     
炮弹炸数组问题 考虑炸边界 + 线段树

根据数据范围选择分治策略

## 线段树和树状数组题目

https://www.cnblogs.com/zhangwanying/p/9964023.html