## 滑动窗口

R++
新数从右侧进入

L++
旧数从左侧出去

L <= R 

窗口的最大值/最小值的更新结构
单调双端队列，从头到尾是从大到小的（放每个节点的位置）
每次加入的数从右边进，左边出
加入的数和头的值相比，如果小，就直接进入队列
如果大（或相等），就依次弹出，直到这个数可以进入队列
头部位置就是最大值
调整双端队列的平均复杂度是O（1）


题目一

假设一个固定大小为W的窗口，依次划过arr，
返回每一次滑出状况的最大值
例如，arr = [4,3,5,4,3,3,6,7], W = 3
返回：[5,5,5,4,6,7]
LeetCode_0239_SlidingWindowMaximum

题目二
给定一个整型数组arr，和一个整数num
某个arr中的子数组sub，如果想达标，必须满足：
sub中最大值 – sub中最小值 <= num，
返回arr中达标子数组的数量
NowCoder_AllLessNumSubArray.java

arr[L..R]达标，则arr中内部的任何一个子数组都达标
arr[L..R]不达标，则arr扩充后肯定也不达标

问题本身和范围建立单调性
1。开头符合窗口逻辑，结尾到窗口的结尾截止
2。首尾指针（首指针右走，尾指针左走）

题目三

LeetCode_0713_SubarrayProductLessThanK.java


## 双指针
给定一个数组arr，已知其中所有的值都是非负的，将这个数组看作一个容器， 请返回容器能装多少水
比如，arr = {3，1，2，5，2，4}，根据值画出的直方图就是容器形状，该容 器可以装下5格水
再比如，arr = {4，5，1，3，2}，该容器可以装下2格水

case 1
预处理数组
i位置，Math.max{Math.min(左边部分的最大值 左边部分的最大值) - [i], 0}

case 2 （最优解）
双指针
L,R,max左，max右
LeetCode_0042_TrappingRainWater



给定一个有序数组arr，从左到右依次表示X轴上从左往右点的位置
给定一个正整数K，返回如果有一根长度为K的绳子，最多能盖住几个点
绳子的边缘点碰到X轴上的点，也算盖住
Code_0065_CoverMax.java
tips：
暴力方法：
贪心，绳子边缘没必要不压中某个点
以每个位置作为结尾来找，假设某个位置是103，长度是5，
其实就是找[0，102]范围内>=98的最左的点
O(N*logN)
最优解
长度和范围有单调性 -> 滑动窗口，左右指针
在牛客上，[类似题目](https://www.nowcoder.com/questionTerminal/2b2567c9b95743f19c167bb1ec644b43)
和这题有点差别，牛客上的题目是不算边缘压中的情况的


给定一个数组arr，长度为N且每个值都是正数，代表N个人的体重。再给定一个正数 limit，代表一艘船的载重。
以下是坐船规则，
1)每艘船最多只能做两人;
2)乘客 的体重和不能超过limit
返回如果同时让这N个人过河最少需要几条船。
LeetCode_0881_BoatsToSavePeople.java
tips:
排序双指针
找到小于等于limit/2 的最右边的位置
双指针
[1,3,3,3,4,5,5,5, | 6,6,6,7,7,7,8,9,9]
               L    R
L往左 搭配 R 往右 凑一艘船
考虑 L + R 和 limit的关系，左右先耗尽的情况具体分析


给定字符串str1和str2，求str1的子串中含有str2所有字符的最小子串长度
LeetCode_0076_MinimumWindowSubstring
【举例】
str1="abcde"，str2="ac"
因为"abc"包含 str2 所有的字符，并且在满足这一条件的str1的所有子串中，"abc"是 最短的，返回3。
str1="12345"，str2="344" 最小包含子串不存在，返回0。
tips:
滑动窗口
欠帐表 map 存str2的字符
all 总的欠账多少
有效还款才对all--
all 到0的时候 L开始移动

