# 线段树

## 要解决的问题

数组任意区间内的元素修改，增加，求和，时间复杂度都要达到O(logN)水平, 方法说明如下

`L...R`上都加`V`

```java
void add(L, R, V, arr) 
```

`L...R`上的值都更新成`V`

```java
void update(L, R, V, arr)
```

`L...R`上求和并返回求和信息

```java
int query(L, R, arr) 
```

## 预处理

线段树要求数组长度必须是`2^N`次方，如果不满足，则通过补0的方式来变成`2^N`次方。

将数组划分成一个个的区间，区间大小分别为: `1，2，4，8.... 2^N`。

例如：数组的长度为8，我们将数组下标从1开始编号到8，则每个下标构成的区间是一个满二叉树，如下图

```text
        1~8
    /        \
  1~4        5~8
 /  \       /   \
1~2 3~4    5~6  7~8
/ \  / \   / \  / \
1 2  3 4   5 6  7  8
```

如果不满足2的n次方，要变成满二叉树，需要通过补0的方式，比如数组只有6个元素，编号为`1~6`，那么7位置和8位置补0。

如果N满足2的某次方，则仅需要2N个区间就可以装下所有区间，如果不满足2的某次方，则仅需要4N个区间就可以装下。

线段树这里的下标都用1开始，0位置弃而不用 就是为了在任意位置（假设位置为i）有：

左孩子对应的下标是`2*i` ，即：`i<<1`

右孩子对应的下标是`2*i+1`，即：`(i<<1)|1`

所以，假设原始数组长度为`N`，线段树需要将这个数组做如下预处理：

第一步，准备一个`N+1`长度的数组`arr`，arr的`0`位置弃而不用，其他位置依次存原始数组的值。

第二步，准备四个数组，数组长度均为：`4*(N+1)`，每个数组的含义如下

`sum`数组用来模拟维护区间和

`lazy`数组为累加和懒惰标记

`change`数组为更新的值数组

`update`数组存放更新慵懒标记

## 线段树初始化

线段树在初始化阶段，会把每个区间的和先计算出来，放入`sum`数组中，初始化代码如下

```java
public void build(int l, int r, int rt) {
  if (l == r) {
   sum[rt] = arr[l];
   return;
  }
  int mid = (l + r) >> 1;
  build(l, mid, rt << 1);
  build(mid + 1, r, rt << 1 | 1);
  pushUp(rt);
}

private void pushUp(int rt) {
  sum[rt] = sum[rt << 1] + sum[rt << 1 | 1];
}
```

`pushUp`方法很容易理解，即：每个区间的和等于它左右两个区间的和相加得到。前面提到，对于`rt`位置来说，左右孩子分别为`rt << 1`和`rt << 1 | 1`。所以`sum[rt] = sum[rt << 1] + sum[rt << 1 | 1];`。

`build`方法用了递归，根据[master公式](https://blog.csdn.net/qq_32595453/article/details/79516787)可以计算其复杂度为`O(logN)`。

## 懒更新机制

add 方法 如果节点包括任务，就不需要下发，存在lazy信息中，如果没有包住，就要下发  
当新的任务到的时候，如果自己原先有懒信息的时候，则当前节点把懒信息发给左孩子和右孩子(下发一层)，然后把懒的信息置为0, 这一步的操作是log（N）

update 方法 change[] update[] 配合使用  
如果一个节点收到一个update方法，假设更新为C（存在change数组中），则这个节点的所有lazy失效，sum直接变成 ： 个数 * C

query方法 返回sum

父节点如果可以通过左右简单加工得到，就可以用线段树

什么时候不能用线段树呢？
比如：要求某个区间出现次数最多的值（这个无法用线段树，因为出现次数最多的值可以既不是左边出现最多的值，也不是右边出现最多的值）

## 线段树源码

Code_0007_SegmentTree.java

## 区域和检索 - 数组可修改

LeetCode_0307_RangeSumQuery.java

## 区域和检索 - 数组不可变

LeetCode_0303_RangeSumQueryImmutable.java

## 落方块问题

LeetCode_0699_FallingSquares.java

[TODO]
矩形最大重合位置
矩形的遍历顺序，按底从小到大，矩形放list，重合区域必以某个底为底
遍历list的时候，如果某个矩形的上顶都比底更低，那么就可以剔除掉，
此时得到一堆矩形，这堆矩形的左边和右边抽取出来，看线段重合最多的即为答案

至少移除多少个区间后可以保证线段不重合
LeetCode_0435_NonOverlappingIntervals.java

字符串尽可能分割成多个片段，每个字符最多出现在一个片段中
LeetCode_0763_PartitionLabels

# 树状数组

[TODO]

数组在不变的情况下 前缀和数组 可以加速生成i-j位置的累加和信息

如果数组要单点修改，则以上的情况不适用

树状数组就是解决这个问题 log（N)

线段树是树状数组的升级版
 奇数
 二进制最后一位是1：则只管自己这个位置的内容
 偶数
   0010 管 0001 ~ 0010
  00100 管 00001 ~ 00100 0110 管 0101 ~ 0110

一般地 1010111000 管 1010110001 ~ 1010111000

单点更新的时候，改了某个值，要关心到底哪些位置受到了牵连

单点的二进制最末尾的1+1，依次到数组结尾，都是受到牵连的 一个数最右侧的1 ： index & (-index)  或者 index & (~index + 1)

只支持单点修改，如果多次修改，一个一个调用

index tree方便改成二维和三维的index tree

炮弹炸数组问题 考虑炸边界 + 线段树

根据数据范围选择分治策略

## 线段树和树状数组题目

[segment-tree](https://leetcode.com/tag/segment-tree/)

[binary-indexed-tree](https://leetcode.com/tag/binary-indexed-tree/)
