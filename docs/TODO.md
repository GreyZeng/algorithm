[TODO]
AVL, SBT, 红黑树
AC自动机



[TODO]
有一些排成一行的正方形。每个正方形已经被染成红色或者绿色。现在可以选择任意一个正方形然后用这两种颜色的任意一种进行染色,这个正方形的颜色将 会被覆盖。目标是在完成染色之后,每个红色R都比每个绿色G距离最左侧近。 返回最少需要涂染几个正方形。
如样例所示: s = RGRGR 我们涂染之后变成RRRGG满足要求了,涂染的个数为2,没有比这个更好的涂染方案。
tips
预处理数组
左边R的数量
左边G的数量


[TODO]
给定一个N*N的矩阵matrix，只有0和1两种值，返回边框全是1的最大正方形的边长长度。
例如:
01111
01001
01001
01111
01011 
其中边框全是1的最大正方形的大小为4*4，所以返回4
N*N 正方形 有N^4长方形 有N^3正方形
长方形需要两个点确定
正方形一个点+边长确定
r[i][j] 右侧有多少个连续的1
d[i][j] 下方有多少个连续的1


[TODO]
给定一个正整数M，请构造出一个长度为M的数组arr，要求
对任意的i、j、k三个位置，如果i<j<k，都有arr[i] + arr[k] != 2*arr[j]
返回构造出的arr
tips:
长度为1，满足
假设 a + b != 2*c
-> 2 * a - 1 + 2 * b - 1 != 2 * c - 1
2 * a + 2 * b != 2 * c

[a,b,c]
->[2 * a - 1, 2 * b - 1, 2 * c - 1, 2 * a, 2 * b, 2 * c]

[1,5,3]
->[1,9,5,2,10,6]

长度为M，只需要一个(M + 1)/2长度的种子

复杂度估计
T(N) = T(N/2) + O(N)

空间复杂度可以做到O(1)


[TODO]
在行也有序、列也有序的二维数组中，找num，找到返回true，否则false
tips: 从右上角开始 或者 左下角开始


[TODO]
有n个打包机器从左到右一字排开，上方有一个自动装置会抓取一批放物品到每个打 包机上，放到每个机器上的这些物品数量有多有少，由于物品数量不相同，需要工人 将每个机器上的物品进行移动从而到达物品数量相等才能打包。每个物品重量太大、 每次只能搬一个物品进行移动，为了省力，只在相邻的机器上移动。请计算在搬动最 小轮数的前提下，使每个机器上的物品数量相等。如果不能使每个机器上的物品相同， 返回-1。 例如[1,0,5]表示有3个机器，每个机器上分别有1、0、5个物品，经过这些轮后: 
第一轮:1    0 <- 5 => 1 1 4
第二轮:1 <- 1 <- 4 => 2 1 3
第三轮:2    1 <- 3 => 2 2 2 
移动了3轮，每个机器上的物品相等，所以返回3
例如[2,2,3]表示有3个机器，每个机器上分别有2、2、3个物品， 这些物品不管怎么移动，都不能使三个机器上物品数量相等，返回-1
tips: 所有数的累加和 % N != 0, 怎么都无法做到

考虑i位置，
左有 ，左余
右有，右余
预处理数组，累加和

[TODO]
给定一个数组arr，已知其中所有的值都是非负的，将这个数组看作一个容器， 请返回容器能装多少水
比如，arr = {3，1，2，5，2，4}，根据值画出的直方图就是容器形状，该容 器可以装下5格水
再比如，arr = {4，5，1，3，2}，该容器可以装下2格水

case 1
预处理数组
i位置，Math.max{Math.min(左边部分的最大值 左边部分的最大值) - [i], 0}

case 2 （最优解）
双指针
L,R,max左，max右

[TODO]
如果给你一个二维数组，每一个值表示这一块地形的高度，
求整块地形能装下多少水。

1. 边沿每个数放入小根堆（num,col,row）
2. heap中弹出堆顶num，
3.  num的上下左右放入小根堆(isEnter设置为true)，放入后，开始结算邻居的水量
   max - num > 0 ，累加到water, < 0 就不累加
    num是否可以更新max
实质：
heap第一次弹出就是边缘的最薄弱点
更新max，换一片湖来接水
复杂度
O(N*M*logK)

[TODO]
给定一个数组arr长度为N，你可以把任意长度大于0且小于N的前缀作为左部分，剩下的 作为右部分。

但是每种划分下都有左部分的最大值和右部分的最大值，请返回最大的， 左部分最大值减去右部分最大值的绝对值。
tips: 全局的max，0位置的数和N-1位置的数谁小，用max减谁




[TODO]
给定一个有序数组arr，给定一个正数aim

1）返回累加和为aim的，所有不同二元组
双指针
[L] + [R] > aim
[L] + [R] < aim
[L] + [R] = aim
   L - 1 和 L 位置的数不等于的时候 收集答案
2）返回累加和为aim的，所有不同三元组
遍历每个位置，剩余位置 根据 找二元组的算法找出aim — [i] 的所有二元组


[TODO]
长度为N的数组arr，一定可以组成N^2个数值对。
例如arr = [3,1,2]，
数值对有(3,3) (3,1) (3,2) (1,3) (1,1) (1,2) (2,3) (2,1) (2,2)，
也就是任意两个数都有数值对，而且自己和自己也算数值对。
数值对怎么排序？规定，第一维数据从小到大，第一维数据一样的，第二维数组也从小到大。所以上面的数值对排序的结果为：
(1,1)(1,2)(1,3)(2,1)(2,2)(2,3)(3,1)(3,2)(3,3)

给定一个数组arr，和整数k，返回第k小的数值对。

tips:
第一个数字定位
第二个数字定位
无序数组求第K小 bfprt和快排改进


[TODO]
给定一个有序数组arr，从左到右依次表示X轴上从左往右点的位置
给定一个正整数K，返回如果有一根长度为K的绳子，最多能盖住几个点
绳子的边缘点碰到X轴上的点，也算盖住

tips：
暴力方法：
贪心，绳子边缘没必要不压中某个点
以每个位置作为结尾来找，假设某个位置是103，长度是5，
其实就是找[0，102]范围内>=98的最左的点
O(N*logN)
最优解
长度和范围有单调性 -> 滑动窗口，左右指针


[TODO]
给定一个二叉树的头节点head，路径的规定有以下三种不同的规定：

1）路径必须是头节点出发，到叶节点为止，返回最大路径和 

2）路径可以从任何节点出发，但必须往下走到达任何节点，返回最大路径和

3）路径可以从任何节点出发，到任何节点，返回最大路径和

Leetcode 845 最长山脉问题 【单调栈】
Leetcode 683 K个空花盆
Leetcode 568 最大休假天数


[TODO]
括号有效配对是指：
1）任何一个左括号都能找到和其正确配对的右括号
2）任何一个右括号都能找到和其正确配对的左括号
有效的：    (())  ()()   (()())  等
无效的：     (()   )(     等
问题一：怎么判断一个括号字符串有效？
问题二：如果一个括号字符串无效，返回至少填几个字符能让其整体有效

问题1，用一个count变量
遇到左括号 count++
遇到右括号 count--
如果过程中count<0 直接返回无效
最后count==0 返回有效

问题2，用一个count和need变量
如果count == -1， need++， count恢复成0
到最后count == 0 ， 返回need，到最后count不等于0，返回need + count


[TODO]
括号有效配对是指：
1）任何一个左括号都能找到和其正确配对的右括号
2）任何一个右括号都能找到和其正确配对的左括号
返回一个括号字符串中，最长的括号有效子串的长度
tips:
枚举每个位置结尾的答案

[TODO]
括号最大嵌套层数


相关题目
LeetCode

1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target

LintCode
406. 和大于S的最小子数组
https://www.lintcode.com/problem/minimum-size-subarray-sum/description