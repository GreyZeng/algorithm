

[TODO] 编辑距离问题
给定两个字符串str1和str2，再给定三个整数ic、dc和rc，分别代表插入、删 除和替换一个字符的代价，返回将str1编辑成str2的最小代价。
【举例】
str1="abc"，str2="adc"，ic=5，dc=3，rc=2 从"abc"编辑成"adc"，把'b'替换成'd'是代价最小的，所以返回2
str1="abc"，str2="adc"，ic=5，dc=3，rc=100 从"abc"编辑成"adc"，先删除'b'，然后插入'd'是代价最小的，所以返回8
str1="abc"，str2="abc"，ic=5，dc=3，rc=2 不用编辑了，本来就是一样的字符串，所以返回0

一个样本做行，一个样本做列的
str1 前i个，str2 前j个 最小编辑代价是多少

[TODO]
给定两个字符串s1和s2，问s2最少删除多少字符可以成为s1的子串？
比如 s1 = "abcde"，s2 = "axbc"
返回1。s2删掉'x'就是s1的子串了。

tips:
case 1 如果s2很短，那么生成s2的所有子序列(2^M)，如果是s1的子串（kmp），直接删除s1 - s2 个字符就可以了 O(N*2^M)
case 2 如果s1和s2都很长，那么就生成s1的所有字串，然后和s2求编辑距离（只有插入代价或者删除行为，删除和代替的代价无穷大） O(N^2 * M)


[TODO]
给定两个字符串，记为start和to，再给定一个字符串列表list，list中一定包含to list中没有重复字符串，所有的字符串都是小写的。
规定: start每次只能改变一个字符，最终的目标是彻底变成to，但是每次变成的新字符串必须在list 中存在。
请返回所有最短的变换路径。
【举例】 
start="abc",end="cab",list={"cab","acc","cbc","ccc","cac","cbb","aab","abb"}
转换路径的方法有很多种，但所有最短的转换路径如下: 
abc -> abb -> aab -> cab
abc -> abb -> cbb -> cab
abc -> cbc -> cac -> cab
abc -> cbc -> cbb -> cab

tips:
构造一个图，只改一个位置可以变到，这两个点就有一个边

构造邻居表
map -> key: string value : 邻居
这一步的复杂度：O(N^2*k) k为字符串的平均长度

构造邻居表可以加速
HashSet中有可能的所有邻居（只变动一个位置的字符）都放入进去 O(K^2) k是字符串的长度


宽度优先遍历 + 深度优先遍历


[TODO]
给定一个正数数组arr，返回该数组能不能分成4个部分，并且每个部分的累加和相等，切分位置的数不要。
例如:
arr=[3, 2, 4, 1, 4, 9, 5, 10, 1, 2, 2] 返回true
三个切割点下标为2, 5, 7. 切出的四个子数组为[3,2], [1,4], [5], [1,2,2]，
累加和都是5

tips:
数组长度一定要大于7
前缀和加入map中
第一刀 1 .... N - 6
第一刀确定后，第二刀的位置



[TODO] 数组中最小不可组成和
给定一个正数数组 arr，其中所有的值都为整数，以下是最小不可组成和的概念:
把 arr 每个子集内的所有元素加起来会出现很多值，其中最小的记为 min，最大的记为max 在区间[min,max]上，如果有数不可以被arr某一个子集相加得到，那么其中最小的那个数是arr 的最小不可组成和 在区间[min,max]上，如果所有的数都可以被arr的某一个子集相加得到，那么max+1是arr的最 小不可组成和
请写函数返回正数数组 arr 的最小不可组成和。
【举例】
arr=[3,2,5]。子集{2}相加产生 2 为 min，子集{3,2,5}相加产生 10 为 max。在区间[2,10] 上，4、 6 和 9 不能被任何子集相加得到，其中 4 是 arr 的最小不可组成和。 arr=[1,2,4]。子集{1}相加产生 1 为 min，子集{1,2,4}相加产生 7 为 max。在区间[1,7]上， 任何 数都可以被子集相加得到，所以 8 是 arr 的最小不可组成和。
tips:
背包方法可以解 dp[i][j] 0..i位置能否组成j 

【进阶】
如果已知正数数组 arr 中肯定有 1 这个数，是否能更快地得到最小不可组成和?
tips: 
先排序
range = 1
1 ~ range所有的数都可以加出来
i位置的数是a
a > range + 1  -> return range + 1
a <= range + 1 --> range = range + a 如果都满足，return range + 1

[TODO]
一个数组中，如果两个数的最小公共因子大于1，则认为这两个数之间有通路
返回数组中，有多少个独立的域
tips:
并查集 不优化的话是O(N^2)
如果每个值都不是特别大，可以把这个值拆分出其质数因子 
map中存 key: 质数因子 value: 下标
O(N*V)
O(N*N)
还可以优化成O(N*根号V)
质数因子可以转换成代表因子
比如100
质数因子很多，但是代表因子只有：
2，50
4，25
5，20
10，10

最大公约数





[TODO]
int[] d，d[i]：i号怪兽的能力
int[] p，p[i]：i号怪兽要求的钱
开始时你的能力是0，你的目标是从0号怪兽开始，通过所有的怪兽。
如果你当前的能力，小于i号怪兽的能力，你必须付出p[i]的钱，贿赂这个怪兽，然后怪兽就会加入你，他的能力直接累加到你的能力上；如果你当前的能力，大于等于i号怪兽的能力，你可以选择直接通过，你的能力并不会下降，你也可以选择贿赂这个怪兽，然后怪兽就会加入你，他的能力直接累加到你的能力上。
返回通过所有的怪兽，需要花的最小钱数。
tips:
方法1：  如果怪兽能力值不大的情况，二维表 能力 + index 达到的最小钱数
方法2： 如果怪兽能力值比较大的情况，二维表  钱数 + index 达到的最大能力  严格花某个钱

[TODO]
一种消息接收并打印的结构设计
已知一个消息流会不断地吐出整数 1到N，但不一定按照顺序吐出。如果上次打印的数为 i， 那么当 i+1 出现时，请打印 i+1 及其之后接收过的并且连续的所有数，直到 1到N 全部接收 并打印完，请设计这种接收并打印的结构。
初始时默认i==0

tips:
hashmap
head表 和 tail表
和链表配合

[TODO]
现有n1+n2种面值的硬币，其中前n1种为普通币，可以取任意枚，后n2种为纪念币， 每种最多只能取一枚(可能有重复值)，每种硬币有一个面值，问能用多少种方法拼出m的面值?
tips:
两个动态规划
普通 + 钱数 i,j 可以斜率优化 --> 只需要最后一行的数据
纪念 + 钱数 i,j 经典背包问题 --> 
假设是10元
普通 0 纪念 10
普通 1 纪念 9
...
普通 10 纪念 0  

[TODO]
给定一个正数N，表示你在纸上写下1~N所有的数字

返回在书写的过程中，一共写下了多少个1

tips:
打表法不行

数位dp的问题
最高位是1 不是1
最高位开始有几个1
其次高位置上有几个1

f(13625) -> 3626 ~ f(3625)
N = 1到k位  
最高位是1
N%10^(k-1) + 1    
+
10^(k-2) * (k - 1)

最高位不是1
10^(k-1) + 10^(k-2) * a * (k - 1) 


复杂度
O(log10(N) * log10(N))

[TODO]
先给出可整合数组的定义:如果一个数组在排序之后，每相邻两个数差的绝对值 都为 1， 则该数组为可整合数组。
例如，[5,3,4,6,2]排序之后为[2,3,4,5,6]， 符合每相邻两个数差的绝对值 都为 1，所以这个数组为可整合数组。 
给定一个整型数组 arr，请返回其中最大可整合子数组的长度。例如， [5,5,3,2,6,4,3]的最大 可整合子数组为[5,3,2,6,4]，所以返回 5。

tips:
hashset, 最大-最小 和 个数之间的关系


[TODO] 
[卡特兰数](卡特兰数.md)

[TODO]
股票问题四连

[TODO]
给定一个数组arr，再给定一个k值
返回累加和小于等于k，但是离k最近的子数组累加和
tips:

TreeSet
前缀和 加入有序表
某个位置结尾的情况下，收集一下答案
如果数组全是正数，可以用窗口

类似：
数组三连的第三个O(N*logN)解法
tips: 采用前缀和
[3,-1,6,-4,2,3,4]
help
[3,2,8,4,6,9, ]
help' 维持一个只升不降的数组
[3,3,8,8,8,9,]
二分查找

[TODO]
给定一个二维数组matrix，再给定一个k值
返回累加和小于等于k，但是离k最近的子矩阵累加和
tips:
通过压缩数组来处理

[TODO]
给定一个二维数组matrix，可以从任何位置出发，每一步可以走向上、下、左、右，四个方向。返回最大递增链的长度。
例子：
matrix = 
5  4  3
3  1  2
2  1  3
从最中心的1出发，是可以走出1 2 3 4 5的链的，而且这是最长的递增链。所以返回长度5
tips:
记忆化搜索  -> O(N*M)

[TODO] 练习递归的能力
给定一个字符类型的二维数组board，和一个字符串组成的列表words。
可以从board任何位置出发，每一步可以走向上、下、左、右，四个方向，
但是一条路径已经走过的位置，不能重复走。
返回words哪些单词可以被走出来。
例子 
board = [
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]
words = ["oath","pea","eat","rain"]
输出：["eat","oath"]
tips:
0. 把words做成前缀树，加速
1. 不能重复走，置为0，然后要恢复现场
2. 深度优先



[TODO]
给定两个字符串S和T，返回S子序列等于T的不同子序列个数有多少个? 如果得到子序列A删除的位置与得到子序列B删除的位置不同，那么认为A和B就是不同的。
【例子】
S = "rabbbit", T = "rabbit"
返回: 3 
是以下三个S的不同子序列，没有^的位置表示删除的位置，因为删除的位置不同，所以这三 个子序列是不一样的
rabbbit
II IIII 
rabbbit
III III 
rabbbit
IIII II 

tips:
样本做行 样本做列 
dp[i][j] : 表示s[0..i] 任意删除的方案，能组成 T[0..j] 这个前缀字符串


[TODO]
给定一个二维数组 map，含义是一张地图，例如，如下矩阵: 
-2 -3   3
-5 -10  1
 0  30 -5
游戏的规则如下: 
骑士从左上角出发，每次只能向右或向下走，最后到达右下角见到公主。
地图中每个位置的值代表骑士要遭遇的事情。
如果是负数，说明此处有怪兽，要让骑士损失血量。
如果是非负数，代表此处有血瓶，能让骑士回血。
骑士从左上角到右下角的过程中，走到任何一个位置时，血量都不能少于1。
为了保证骑士能见到公主，初始血量至少是多少?根据map，返回至少的初始血量。


[TODO]
给定一个矩阵matrix，先从左上角开始，每一步只能往右或者往下走，走到右下角。然后从右下角出发，每一步只能往上或者往左走，再回到左上角。任何一个位置的数字，只能获得一遍。返回最大路径和。
tips:
设置两个小人，走到同一位置的时候，只算一份，路径和，就是来回的最大路径和

[TODO]
给定一个无序数组arr，返回如果排序之后，相邻数之间的最大差值

{3,1,7,9}，如果排序后{1,3,7,9}，相邻数之间的最大差值来自3和7，返回4

要求：不能真的进行排序，并且要求在时间复杂度O(N)内解决

tips:
求最大值和最小值，然后把数分为N+1份，每个桶只装可以进这个桶的最小值和最大值
遍历时，把每个数分到每个桶里面，其中肯定有个桶是空的
桶之间的数取最大差值即可
设置空桶的目的是杀死桶内数据的差值

[TODO]
假设所有字符都是小写字母.   长字符串是str
arr是去重的单词表, 每个单词都不是空字符串且可以使用任意次
使用arr中的单词有多少种拼接str的方式，返回方法数.
tips:
前缀树

[TODO]
给定一棵二叉树的头节点head，和一个数K
路径的定义: 
可以从任何一个点开始，但是只能往下走，往下可以走到任何节点停止
返回路径累加和为K的所有路径中，最长的路径最多有几个节点？
tips:
累加和为K的最长子数组（数组三连问题）
从头节点到当前节点的前缀和 放在一个map里面，这个map只维持具体的某一条支路
存前缀和最早出现的位置

[TODO]
给定一个数组arr，已知除了一种数只出现1次之外，剩下所有的数都出现了k次，如何使用O(1)的额外空间，找到这个数。
tips:
k进制异或
准备一个32长度的数组
每个数转成k进制，累加到数组中，最后把数组中每个位上的数%k后，转成十进制，就是那个出现了一次的数


[TODO]
给定一个数组arr，如果有某个数出现次数超过了数组长度的一半，打印这个数，如果没有不打印
tips:
每次删掉两个不同的数，这个数最后会剩下来，

扩展：投票问题

给定一个数组arr和整数k，arr长度为N，如果有某些数出现次数超过了N/K，打印这些数，如果没有不打印
tips:
最多只有k-1个候选
一次删掉k个不同的数，
准备一个map，里面最多三条数据

[TODO] 业务限制的模型
arr中记录咖啡机制造一杯咖啡的时间，假设有m个人，都在0号时间点开始排队，返回一个数组
最后一个得到咖啡的人的时间尽可能短
tips:
小根堆 时间点+制造咖啡的时间 
弹出，制造，修改咖啡机的开始时间，再加入小根堆

[TODO]
给定两个整数数组A和B
A是长度为m、元素从小到大排好序了
B是长度为n、元素从小到大排好序了
希望从A和B数组中，找出最大的k个数字
tips:
最优解复杂度 O(log2(min(M,N)))
方法1：m数组中二分的值x，拿到n中去定位
方法2： 两个等长排序数组的上中位数，
中间位置的数据对比，奇数和偶数有区别
讨论k的取值范围

[TODO]
约瑟夫环问题
O(N)
tips
公式，f(留下后的编号) = 杀之前的编号
号= （数-1)%i + 1
旧：1234567
新：56X1234
然后画图找规律
旧 = （新+ S-1）%i+1
S->杀的号 S = (M-1)%i+1
i->杀之前的长度

--> (新 + (m-1)) % i + 1


[TODO]
给定一个 N×3 的矩阵 matrix，对于每一个长度为 3 的小数组 arr，都表示一个大楼的三个数据。arr[0]表示大楼的左边界，
arr[1]表示大楼的右边界，arr[2]表示大楼的高度(一定大于 0)。 每座大楼的地基都在 X 轴上，大楼之间可能会有重叠，请返回整体的轮廓线数组。
【举例】 
matrix ={{2,5,6}, {1,7,4}, {4,6,7}, {3,6,5}, {10,13,2}, {9,11,3}, {12,14,4},{10,12,5} }
返回: {{1,2,4},{2,4,6}, {4,6,7}, {6,7,4}, {9,10,3}, {10,12,5}, {12,14,4}}

tips:
最大高度的变化
开始变化的时候，最高高度开始变化，结算前一次的轮廓线
建立一组记录：
每个大楼的开始和结束点对应的最大高度
离散化处理

封装对象：
[3,7,6]  -> 3 + 6 , 7 - 6

第一个有序表 记录次数
第二个有序表 记录轮廓
为了防止纸片大楼，在排序的时候，把+放在-之前

[TODO] 
Nim博弈问题
给定一个非负数组，每一个值代表该位置上有几个铜板。a和b玩游戏，a先手，b后手， 轮到某个人的时候，只能在一个位置上拿任意数量的铜板，但是不能不拿。谁最先把铜 板拿完谁赢。假设a和b都极度聪明，请返回获胜者的名字

tips：
异或和如果是0的话，先手输
不是0的话，先手赢

先手总是可以让选择后的数据异或和为0

[TODO]
给定一个数组arr，长度为N且每个值都是正数，代表N个人的体重。再给定一个正数 limit，代表一艘船的载重。
以下是坐船规则，
1)每艘船最多只能做两人;
2)乘客 的体重和不能超过limit
返回如果同时让这N个人过河最少需要几条船。
tips:
排序双指针
找到小于等于limit/2 的最右边的位置
双指针
[1,3,3,3,4,5,5,5, | 6,6,6,7,7,7,8,9,9]
               L    R
L往左 搭配 R 往右 凑一艘船
考虑 L + R 和 limit的关系，左右先耗尽的情况具体分析

[TODO]
给定一个字符串str，求最长回文子序列长度
tips:
方法1：str和逆序串的最长公共子序列
方法2： 范围内的尝试 L...R

[TODO]
给定一个二维数组matrix，每个单元都是一个整数，有正有负。最开始的时候小Q操纵 一条长度为0的蛇,
从矩阵最左侧任选一个单元格进入地图，蛇每次只能够到达当前位 置的右上相邻，右侧相邻和右下相邻的单元格。
蛇到达一个单元格后，自身的长度会 瞬间加上该单元格的数值，任何情况下长度为负则游戏结束。
小Q是个天才，他拥有一 个超能力，
可以在游戏开始的时候把地图中的某一个节点的值变为其相反数(注:最多 只能改变一个节点).问在小Q游戏过程中，他的蛇最长长度可以到多少?
比如:
1 -4  10
3 -2 -1
2 -1  0
0  5 -2
最优路径为从最左侧的3开始，3 -> -4(利用能力变成4) -> 10。所以返回17。

tips:
业务限制的模型

[TODO]
给定一个字符串str，str表示一个公式，公式里可能有整数、加减乘除符号和左右 括号，返回公式的计算结果。
【举例】
str="48*((70-65)-43)+8*1"，返回-1816。
str="3+1*4"，返回7。
str="3+(1*4)"，返回7。
【说明】 
1.可以认为给定的字符串一定是正确的公式，即不需要对str做公式有效性检查。 
2.如果是负数，就需要用括号括起来，比如"4*(-3)"。但如果负数作为公式的开头 或括号部分的开头，则可以没有括号，比如"-3*4"和"(-3*4)"都是合法的。 
3.不用考虑计算过程中会发生溢出的情况。
tips:
int[] f(i)
返回两个值：
从i往后获取到的合适的位置（终止位置或者右括号）
计算的结果

补充：如果整个字符串不包括括号，可以直接用栈来计算
双端队列

[TODO]
1)"1AB23CD21"，你可以选择删除A、B、C、D，然后剩下子序列{1,2,3,2,1}，只要剩下的子序列是同一个，那 么就只算1种方法，和A、B、C、D选择什么样的删除顺序没有关系。
2)"121A1"，其中有两个{1,2,1}的子序列，第一个{1,2,1}是由{位置0，位置1，位置2}构成，第二个{1,2,1} 是由{位置0，位置1，位置4}构成。这两个子序列被认为是不同的子序列。也就是说在本题中，认为字面值一样 但是位置不同的字符就是不同的。 
3)其实这道题是想求，str中有多少个不同的子序列，每一种子序列只对应一种删除方法，那就是把多余的东 西去掉，而和去掉的顺序无关。
4)也许你觉得我的解释很荒谬，但真的是这样，不然解释不了为什么，XXY 4种 ABA 5种，而且其他的测 试用例都印证了这一点。
tips:
范围模型
L x  R x   a
L v  R x   b
L x  R v   c
L v  R v   d

dp[L][R]

dp[L+1][R] = a + c
dp[L][R-1] = a + b

加工 a + b + c
d = a + 1  (考虑空串，所以要加1)

[TODO]
给定一个正数1，裂开的方法有一种，(1) 给定一个正数2，裂开的方法有两种，(1和1)、(2) 给定一个正数3，裂开的方法有三种，(1、1、1)、(1、2)、(3) 给定一个正数4，
裂开的方法有五种，(1、1、1、1)、(1、1、2)、(1、3)、(2、2)、 (4)
给定一个正数n，求裂开的方法数。 动态规划优化状态依赖的技巧
f(int pre, int rest)

可以优化枚举行为（前面有：分硬币方法，股票问题3）

[TODO]
给定一个整数N，代表你有1～N这些数字。在给定一个整数K。你可以随意排列这些数字，但是每一种排列都有若干个逆序对。返回有多少种排列，正好有K个逆序对

例子1:
Input: n = 3, k = 0
Output: 1
解释：
只有[1,2,3]这一个排列有0个逆序对。

例子2:
Input: n = 3, k = 1
Output: 2
解释
[3,2,1]有(3,2)、(3,1)、(2,1)三个逆序对，所以不达标。
达标的只有：
[1,3,2]只有(3,2)这一个逆序对，所以达标。
[2,1,3]只有(2,1)这一个逆序对，所以达标。
tips:
一个做行，一个做列（关注结尾）
dp[i][j] 要分情况 i>j  i<=j
有枚举行为，可以优化


[TODO]
给定一棵二叉树的头节点head，已知所有节点的值都不一样，返回其中最大的且符 合搜索二叉树条件的最大拓扑结构的大小。
拓扑结构：不是子树，只要能连起来的结构都算。
tips:

二叉树的递归套路，每个位置的贡献记录，左树的最右节点，右树的最左节点
复杂度 O(N)

[TODO]
一个不含有负数的数组可以代表一圈环形山，每个位置的值代表山的高度。比如， {3,1,2,4,5}、{4,5,3,1,2}或{1,2,4,5,3}都代表同样结构的环形山。 
山峰A和山峰B能够相互看见的条件为: 
1.如果A和B是同一座山，认为不能相互看见。 
2.如果A和B是不同的山，并且在环中相邻，认为可以相互看见。 
3.如果A和B是不同的山，并且在环中不相邻，假设两座山高度的最小值为min。
1)如果A通过顺时针方向到B的途中没有高度比min大的山峰，认为A和B可以相互 看见
2)如果A通过逆时针方向到B的途中没有高度比min大的山峰，认为A和B可以相互 看见
3)两个方向只要有一个能看见，就算A和B可以相互看见 给定一个不含有负数且没有重复值的数组 arr，请返回有多少对山峰能够相互看见。
进阶: 给定一个不含有负数但可能含有重复值的数组arr，返回有多少对山峰能够相互看见。

tips:
无重复值 可以打表
除去最大值，次大值，其余的数都可以找到两对 2 * (N - 2) + 1
有重复值

包装一个（值，次数）的对象
单调栈 
循环遍历  栈由小到大 
弹出就结算

注意清算的时候，计算逻辑
最大值的结算

扩展
Leetcode 845 最长山脉问题 【单调栈】

[TODO]
一棵二叉树原本是搜索二叉树，但是其中有两个节点调换了位置，使得这棵二叉树不再 是搜索二叉树，请找到这两个错误节点并返回。 
已知二叉树中所有节点的值都不一样，给定二叉树的头节点 head，
返回一个长度为2的 二叉树节点类型的数组errs，errs[0]表示一个错误节点， errs[1]表示另一个错误节点。

进阶: 如果在原问题中得到了这两个错误节点，我们当然可以通过交换两个节点的节点值的方式让整棵二叉树重新成为搜索二叉树。 
但现在要求你不能这么做，而是在结构上完全交换两个节点的位置，请实现调整的函数

tips:
中序遍历 第一次降序的头节点，第二次降序的尾节点
e1,e2 可能是同一个头
e1,e2与其父是什么关系
e1,e2是否挨着


[TODO]
给定一个非负数组arr，和一个正数m
返回arr的所有子序列中累加和%m之后的最大值。
tips:
方法1：
二维表(n*sum)
方法2：
二维表（n*m）：列是数组下标，行0...m-1
0到i上随意组合，在i%m后能否组成j
方法3（分治）：
二维表(n*m（真实的余数）):如果n很小，可以分解两半，暴力求每一半的所有可能子数组的累加和，放入一个List中，List加工出每个值模m后的List‘
左边部分的数量 + 右边部分的数量 + 左边和右边整合的List



[TODO]
判定一个由[a-z]字符构成的字符串和一个包含'.'和'*'通配符的字符串是否匹配。 通配符'.'匹配任意单一字符,'*'匹配前一个字符的任意多个字符(包括0个字符)。 
字符串长度不会超过100，字符串不为空。
输入描述:
字符串 str 和包含通配符的字符串 pattern。1 <= 字符串长度 <= 100输出描述: true 表示匹配，false 表示不匹配
tips:
一个样本做行，一个样本做列尝试模型
f(si,ei)  -> si... 能否 匹配 ei...
有效性检查
可以改动态规划，但是没办法做斜率优化

[TODO]
https://leetcode.com/problems/freedom-trail/
tips:
f(i,j) -> i拨动到j怎么走最省
map记录哪些位置拥有某个字符
深度优先遍历

[TODO]
给定一个数组 arr，代表一排有分数的气球。每打爆一个气球都能获得分数，假设打爆气 球 的分数为 X，获得分数的规则如下: 
1)如果被打爆气球的左边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 L;如果被打爆气球的右边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 R。 获得分数为 L*X*R。 
2)如果被打爆气球的左边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 L;如果被打爆气球的右边所有气球都已经被打爆。获得分数为 L*X。 
3)如果被打爆气球的左边所有的气球都已经被打爆;如果被打爆气球的右边有没被打爆的 气球，找到离被打爆气球最近的气球，假设分数为 R;如果被打爆气球的右边所有气球都 已经 被打爆。获得分数为 X*R。 
4)如果被打爆气球的左边和右边所有的气球都已经被打爆。获得分数为 X。
目标是打爆所有气球，获得每次打爆的分数。通过选择打爆气球的顺序，可以得到不同的总分，请返回能获得的最大分数。
【举例】
arr = {3,2,5} 
如果先打爆3，获得3*2;再打爆2，获得2*5;最后打爆5，获得5;最后总分21 
如果先打爆3，获得3*2;再打爆5，获得2*5;最后打爆2，获得2;最后总分18 
如果先打爆2，获得3*2*5;再打爆3，获得3*5;最后打爆5，获得5;最后总分50 
如果先打爆2，获得3*2*5;再打爆5，获得3*5;最后打爆3，获得3;最后总分48 
如果先打爆5，获得2*5;再打爆3，获得3*2;最后打爆2，获得2;最后总分18 
如果先打爆5，获得2*5;再打爆2，获得3*2;最后打爆3，获得3;最后总分19 
返回能获得的最大分数为50

tips:

[3,2,5] -> [1,3,2,5,1]
f(1,3) -> 0位置和4位置永远不爆

[TODO]
汉诺塔游戏的要求把所有的圆盘从左边都移到右边的柱子上，给定一个整型数组arr， 其中只含有1、2和3，代表所有圆盘目前的状态，1代表左柱，2代表中柱，
3代表右柱， arr[i]的值代表第i+1个圆盘的位置。 
比如，arr=[3,3,2,1]，代表第1个圆盘在右柱上、第2个圆盘在右柱上、第3个圆盘在中 柱上、第4个圆盘在左柱上 
如果arr代表的状态是最优移动轨迹过程中出现的状态，返回arr这种状态是最优移动轨迹中的第几个状态;
如果arr代表的状态不是最优移动轨迹过程中出现的状态，则返回- 1。
tips:
当前位置i没必要走到other
2^N + 1
一二两步走的是 2^(i-1)次方

[TODO]
给定一个数组arr，和一个整数k。
这代表你可以把相邻的k个数字合成一个数字，每一次合并的代价是这些数字的累加和。
最终你的目标是把arr中所有数字合成一个，返回最小代价。

Input: stones = [3,2,4,1], K = 2
Output: 20
解释:
一开始是[3, 2, 4, 1]，只能相邻的2个数字合成一个数字。
先合并[3, 2]变成5，代价是5。 那么就得到了[5, 4, 1]。
先合并[4, 1]变成5，代价是5。 那么就得到了[5, 5]。
先合并[5, 5]变成10，代价是10。 那么就得到了一个数字10。
总代价是20，而且这种方案是最省的。

Input: stones = [3,2,4,1], K = 3
Output: -1
解释：
只能相邻的3个数字合成一个数字，那么合并一次，数字就不够了。所以返回-1。

Input: stones = [3,5,1,2,6], K = 3
Output: 25
解释
开始是[3, 5, 1, 2, 6]，只能相邻的3个数字合成一个数字。
先合并[5, 1, 2]变成8，代价是8, 就变成了[3, 8, 6]
再合并[3, 8, 6]变成17，代价17，就变成了[17]
总代价是25，而且是所有方案中最小的。
tips:
k和数组长度先做一次过滤
f(L,R,part) -> L..R范围上一定要合成出part个数，最小代价是多少

[TODO]
给定字符串str1和str2，求str1的子串中含有str2所有字符的最小子串长度
【举例】
str1="abcde"，str2="ac"
因为"abc"包含 str2 所有的字符，并且在满足这一条件的str1的所有子串中，"abc"是 最短的，返回3。
str1="12345"，str2="344" 最小包含子串不存在，返回0。
tips:
滑动窗口
欠帐表 map 存str2的字符
all 总的欠账多少
有效还款才对all--
all 到0的时候 L开始移动

[TODO]
https://leetcode.com/problems/scramble-string/
tips:
范围上的尝试
f(str1,L1,R1,str2,L2,R2) --> 是否为旋变串
--> f(str1,str2, L1, L2, k)
第一刀可能性，考虑交换和不交换的情况

[TODO]
N个加油站组成一个环形，给定两个长度都是N的非负数组 oil和dis(N>1)，
oil[i]代表 第i个加油站存的油可以跑多少千米，
dis[i]代表第i个加油站到环中下一个加油站相隔 多少千米。 
假设你有一辆油箱足够大的车，初始时车里没有油。如果车从第i个加油站出发，
最终 可以回到这个加油站，那么第i个加油站就算良好出发点，否则就不算。 
请返回长度为N的boolean型数组res，res[i]代表第 i 个加油站是不是良好出发点。
tips:
方法1：
oil(i) - dis(i) -> h(i) 纯能职数组
h(i) 往后累加，不出现负数，就是良好出发点 O(N^2)
生成h(i) 的累加和数组
纯能职数组[1,-1,0,3,-1]
--> 累加和数组 [1,0,0,3,2]
---> 再累加一次 [1,0,0,3,2,3,2,2,5,4]
然后滑动窗口最小值，减去L-1位置的数，如果<0,则L不是良好出发点

方法2：
时间O(n) 空间O(1)
1. 复用oil数组
2. int need  接上头需要多少 
   int rest 剩余油多少
   int start 联通区开始
   int end 联通区结束下一个位置
   [start, end)
   进入联通区，还没有满足的，联通区里面的点都不满足
   找到良好出发点以后，只要能连上良好出发点的都满足条件（只需要关注need）


[TODO]
一个缓存结构需要实现如下功能
void set(int key, int value):加入或修改key对应的value
int get(int key):查询key对应的value值
但是缓存中最多放K条记录，如果新的第K+1条记录要加入，就需要根据策略删掉一条记录，然后才能把新记录加入。
这个策略为:
在缓存结构的K条记录中，哪一个key从进入缓存结构的时刻开始，被调用set或者get的次数最少，就删掉这个key的记录;
如果调用次数最少的key有多个，上次调用发生最早的key被删除。
这就是LFU缓存替换算法。实现这个结构，K作为参数给出。
tips:
Put/Get方法都用O(1)
二维双向链表
map1 : str->node
map2:  node->bucket(频度为n的桶)

[TODO]
给定一个数组arr，给定一个正数k。选出3个不重叠的子数组，每个子数组长度都是k，返回最大的三子数组的最大和。

tips:
dpi  dp反i 包括k个数的最大累加和

[TODO]
一群孩子做游戏，现在请你根据游戏得分来发糖果，要求如下: 
1.每个孩子不管得分多少， 起码分到 1 个糖果。 
2.任意两个相邻的孩子之间，得分较多的孩子必须拿多一些的糖果。 给定一个数组 arr 代表得分数组，请返回最少需要多少糖果。 例如:arr=[1,2,2]，糖果 分配为[1,2,1]，即可满足要求且数量最少，所以返回 4。
【进阶】
原题目中的两个规则不变，再加一条规则: 3.任意两个相邻的孩子之间如果得分一样，糖 果数必须相同。
给定一个数组 arr 代表得分数组，返回最少需要多少糖果。 例如:arr=[1,2,2]，糖果分 配为[1,2,2]，即可满足要求且数量最少，所以返回 5。
【要求】
arr 长度为 N，原题与进阶题都要求时间复杂度为 O(N)，额外空间复杂度为 O(1)。
tips:
画图，
left数组->左边比当前位置小，当前位置+1，左边比当前位置大，当前位置置回1

right数组->右边比当前位置小，当前位置+1，右边比当前位置大，当前位置置回1
每个位置糖果,max(left(i),right(i))

[TODO]
给定一棵二叉树的头节点head，如果在某一个节点x上放置相机，那么x的父节点、x的所 有子节点以及x都可以被覆盖。返回如果要把所有数都覆盖，至少需要多少个相机。
tips:
二叉树递归套路
1. x位置有相机
2. x没相机，但是被覆盖
3. x没相机，也没被覆盖
也可以贪心
   

[TODO]
给定一个路径数组 paths，表示一张图。paths[i]==j 代表城市 i 连向城市 j，如果 paths[i]==i， 则表示 i 城市是首都，一张图里只会有一个首都且图中除首都指向自己之 外不会有环。
例如， paths=[9,1,4,9,0,4,8,9,0,1]，
由数组表示的图可以知道，城市 1 是首都，所以距离为 0，离首都距离为 1 的城市只有城 市 9，离首都距离为 2 的城市有城市 0、3 和 7，离首都距离为 3 的城市有城市 4 和 8， 离首都 距离为 4 的城市有城市 2、5 和 6。所以距离为 0 的城市有 1 座，距离为 1 的 城市有 1 座，距离 为 2 的城市有 3 座，距离为 3 的城市有 2 座，距离为 4 的城市有
3 座。那么统计数组为nums=[1,1,3,2,3,0,0,0,0,0]，nums[i]==j 代表距离为 i 的城市有 j 座。要求实现一个 void 类型的函 数，输入一个路径数组 paths，直接在原数组上调整， 使之变为 nums 数组，即 paths=[9,1,4,9,0,4,8,9,0,1]经过这个函数处理后变成 [1,1,3,2,3,0,0,0,0,0]。
【要求】
如果 paths 长度为 N，请达到时间复杂度为 O(N)，额外空间复杂度为 O(1)。
tips:
方法1 宽度优先遍历
进阶方法：O(N) 空间O(1)
下标循环怼
int next 
int last
怼到首都节点的时候，往回蹦，更新arr 变成负数（表示已经更新过了）
如果怼到负数节点，可以直接回去更新了
首都最后改成0即可

每个位置到首都的距离
[-2,-1,-2,-1,0,-3,-2]
--> 正数变成统计学含义

[TODO]
[四边形不等式](四边形不等式.md)

[TODO]
牛牛和15个朋友来玩打土豪分田地的游戏，牛牛决定让你来分田地，地主的田地可以看成是一个矩形，每个位置有一个价值。分割田地的方法是横竖各切三刀，分成 16 份，作为领导干部，牛牛总是会选择其中总 价值最小的一份田地， 作为牛牛最好的朋友，你希望牛牛取得的田地的价值和尽可能大，你知道这个值最大 可以是多少吗?
输入描述:
每个输入包含 1 个测试用例。每个测试用例的第一行包含两个整数 n 和 m(1 <= n, m <= 75)，表示田地 的大小，接下来的 n 行，每行包含 m 个 0-9 之间的数字，表示每块位置的价值。
输出描述: 输出一行表示牛牛所能取得的最大的价值。
输入例子: 4 4
3 3 3 2
3 2 3 3
3 3 3 2
2 3 2 3
输出例子: 2
tips:
长方形中，求出任意矩阵的累加和
二维前缀和
help[i][j] = help[i-1][j] + help[i][j-1] - arr[i-1][j-1] + arr[i]][j]

假设竖着三刀已经确定，横着切一刀，怎么让八块最小值尽量大
0...i 怎么切一刀最好 up[i]
N-1...0 怎么切一刀最好 down[i]
枚举每一行
0..i行最优一刀在k位置，0...i+1行最优一刀不需要在k之前去试 -> 差(好(S1,S2)) 模型
1） 子矩阵的累加和 O(1) -> help
2) 枚举所有可能的竖三刀
3） up/down  中间位置 O(N)
   O(N^4) 最优解

[TODO]
给定一个只含0和1二维数组matrix，第0行表示天花板。每个位置认为与上、下、左、右四个方向有粘性，比如：
matrix =
1 0 0 1 0
1 0 0 1 1
1 1 0 1 1
1 0 0 0 0
0 0 1 1 0
注意到0行0列是1，然后能延伸出5个1的一片。同理0行3列也是1，也能延伸出5个1的一片。注意到4行2列是1，然后能延伸出2个1的一片。其中有两片1是粘在天花板上的，而4行2列延伸出来的这片，认为粘不住就掉下来了。
在给定一个二维数组bomb，表示炸弹的位置，比如：
bomb =
2 0
1 3
1 4
0 3
根据matrix和bomb，返回结果[2,3,0,0]。
tips:
并查集
炮弹有1，1变成2，如果是0就维持0
然后看接在天花板上1的数量
按打炮弹的顺序的相反顺序去求
遇到2就变成1，然后以2作为分割点
在看接到天花板1的数量，接在天花板的炮弹数量
然后逆着求(看2的位置），再看接到天花板上炮弹的数量（不包括被炸的砖块）
如果增加了数量 则增加数量 - 1就是掉落的数量

用并查集的时候，
需要查看是否接在天花板上，连在天花板上的一是多少
接在同一个天花板上的1 
用一个Dot类来区分每个点（内存地址不同，点就不同）也可以用数组优化空间

注意：
两个同为天花板集合，合并后，天花板上集合数量不会有变化

[TODO]
给定一个数组arr，如果其中有两个集合的累加和相等，并且两个集合使用的数没有相容 的部分(也就是arr中某数不能同时进这个两个集合)，那么这两个集合叫作等累加和集 合对。返回等累加和集合对中，最大的累加和。
举例:
arr={1,2,3,6} {1,2}和{3}，是等累加和集合对 {1,2,3}和{6}，也是等累加和集合对 返回6
tips:
map:
key：可能的所有差值
value：差值较大的那一对中较小的数
1，2 两个数，差值1
1) 1,0
2) 2,1 
差值较大的那一对中较小的数 第二对中的1

map -> map' 按如上规则不断更新
求最后差值为0的那条记录

[TODO]
字面值不同的子序列
tips：
考虑不重复的情况：
所有不同字面值的子序列中，以
a结尾的有多少..
..
z结尾的有多少..
all记录总的字面值子序列有多少
如果有重复值
那么all的更新需要 all — [重复的字符]原有的数量 
是否考虑空集？

[TODO]
给定整数power，给定一个数组arr，给定一个数组reverse。
含义如下：
arr的长度一定是2的power次方，
reverse中的每个值一定都在0~power范围。
例如power = 2, arr = {3, 1, 4, 2}，reverse = {0, 1, 0, 2}
任何一个在前的数字可以和任何一个在后的数组，构成一对数。
可能是升序关系、相等关系或者降序关系。
arr开始时有如下的降序对：(3,1)、(3,2)、(4,2)，一共3个。
接下来根据reverse对arr进行调整：
reverse[0] = 0, 表示在arr中，划分每1(2的0次方)个数一组，然后每个小组内部逆序，
那么arr变成[3,1,4,2]，此时有3个逆序对
 reverse[1] = 1, 表示在arr中，划分每2(2的1次方)个数一组，然后每个小组内部逆序，
那么arr变成[1,3,2,4]，此时有1个逆序对
reverse[2] = 0, 表示在arr中，划分每1(2的0次方)个数一组，然后每个小组内部逆序，
那么arr变成[1,3,2,4]，此时有1个逆序对。
reverse[3] = 2, 表示在arr中，划分每4(2的2次方)个数一组，然后每个小组内部逆序，
那么arr变成[4,2,3,1]，此时有4个逆序对。
所以返回[3,1,1,4]，表示每次调整之后的逆序对数量。

tips:
dp[i]: 如果2的i次方个数内部有几个逆序对
从dp[2]开始，
假设[3,0,6,2,7,8,6,5]
不是说前面四个中有几个降序对，而是：前面四个中，必须一个来自前两个，一个来自后两个有几个降序对。以这个例子为例：
dp[2] 表示：
3，0，6，2这组中，必须一个来自3，0，一个来自6，2有几个降序对，假设为a
7，8，6，5这组中，必须一个来自7，8，一个来自6，5有几个降序对，假设为b
那么dp[2] = a + b
dp数组建好后，
在建立dp'数组
dp'数组就是求正序对的数量

每次reverse后，其实就是dp[i]和dp'[i]交换即可
dp累加和就是答案

逆序对怎么求？小和问题
归并排序

[TODO]
矩阵中达标正方形（里面全是1）
达标正方形最大值（含有1最多的个数）
tips:
dp[i][j] 必须以i,j为右下角的点，向右上方最多能扩多大

[TODO]
给定一个二维数组matrix，其中的值不是0就是1，
其中，
内部全是1的所有子矩阵中，含有最多1的子矩阵中，含有几个1？
tips:
压缩数组+单调栈 O(M*N)

单调栈
类似的一个题目：一维数组直方图中，最大矩形
左右两边比我小的离我最近的位置


[TODO]
给定字符串数组words，其中所有字符串都不同，如果words[i]+words[j]是回文串就记 录(i,j)，找到所有记录并返回
例子一:
输入：["abcd","dcba","lls","s","sssll"]
输出：[[0,1],[1,0],[3,2],[2,4]]
解释：输出的每一组数组，两个下标代表字符串拼接在一起，都是回文串
abcddcba、 dcbaabcd 、 slls 、 llssssll
tips:
暴力方法O(N^2 * K)

所有字符串放hashset
假设某个str为aabaaccacc
看前缀
拿出第一个a，是否是回文串
然后看剩下的字符串abaaccacc的逆序在set中有没有，
如果有，就把这个字符串拿出来拼接在str前面
拿出 aa,依次处理
然后同理，看后缀
前缀 + 后缀 + 看自己的逆序有没有 就是最后的结果
O(N*K^2)

检查回文串这件事，在这个算法中的复杂度可以忽略

[TODO]
给定一个字符串，判断这个字符串中哪些前缀/后缀是回文
tips:
manacher算法，回文半径数组

[TODO]
给定无序数组arr，返回其中最长的连续序列的长度
比如：arr=[100,4,200,1,3,2],最长的连续序列为[1,2,3,4],返回4
tips:
最优解 可以做到O(N)
头map key:值 value：长度
尾map key:值 value：长度
依次看能否合并

还可以优化
只需要一张map
key所在的连续区间，一共有多少长度
key不需要删数据，遇到重复值不处理
不区分开头和结尾
脏数据不用管，也不需要删除，不会影响最后的解，只保证开头和结尾即可

[TODO]
public class Query {
    public Node o1;
    public Node o2;
    public Query(Node o1, Node o2) { 
        this.o1 = o1;
        this.o2 = o2; }
}

一个 Query 类的实例表示一条查询语句，表示想要查询 o1 节点和 o2 节点的最近公共 祖先 节点。
给定一棵二叉树的头节点 head，并给定所有的查询语句，即一个 Query 类型的数组 Query[] ques，请返回Node类型的数组Node[] ans，ans[i]代表ques[i]这条查询的答案， 即ques[i].o1和 ques[i].o2 的最近公共祖先。
【要求】
如果二叉树的节点数为 N，查询语句的条数为 M，整个处理过程的时间复杂度要求达到 O(N+M)。

tips：
如果查询一次的话，就用二叉树的递归套路

map:
记录每个节点的父节点
用并查集
父节点+代表节点的包装
第一步，清洗数据
第二步，两个表
问题map 
key：节点  value: 列表，哪些节点和key节点有关系
填写map
见代码

代表节点打上tag即可

[TODO] 状态压缩的动态规划
TSP问题 有N个城市，任何两个城市之间的都有距离，任何一座城市到自己的距离都为0。所有点到点的距 离都存在一个N*N的二维数组matrix里，也就是整张图由邻接矩阵表示。现要求一旅行商从k城市 出发必须经过每一个城市且只在一个城市逗留一次，最后回到出发的k城，返回总距离最短的路的 距离。参数给定一个matrix，给定k。
tips:
f(List A, start)
集合，出发点
通过出发点，把集合A中的所有信息联通后，回到源出发点最优的总距离
有重复解
用位状态替换List
N座城市 (1 << N) - 1 表示N个城市都在
最右侧的1

动态规划
行依次+1
O(2^N * N^2)

[TODO] 
状态压缩的动态规划
贴瓷砖问题你有无限的1*2的砖块，要铺满2*N的区域，不同的铺法有多少种? 
tips:
f(6) = f(5) + f(4) 斐波那契问题

你有无限的1*2的砖块，要铺满M*N的区域，不同的铺法有多少种?
tips:
f(int[] , i)
第i行无瓷砖，限制瓷砖的摆法限制往右边和上面摆
int[] 表示上一行的状态
01110110
0表示无，1表示有
i到后面所有的行都是空白的
i-1行以上全摆满了


[TODO]
https://leetcode.com/problems/remove-boxes
tips:
int f(arr, L,R,K)
arr L..R 消消乐 L前面跟着K个[L]位置上的数，都消掉要多少？

[TODO]
https://leetcode.com/problems/strange-printer/
tips:
范围上尝试
int f(L,R)
贪心：边缘处只能让第一转生成，不会影响最优解
L确定
R的确定


[TODO]
整型数组arr长度为n(3 <= n <= 10^4)，最初每个数字是<=200的正数且满足如下条件： 
1. 0位置的要求：arr[0] <=arr[1] 
2. n-1位置的要求：arr[n-1] <= arr[n-2] 
3. 中间i位置的要求：arr[i] <= max(arr[i-1],arr[i+1]) 但是在arr有些数字丢失了，比如k位置的数字之前是正数，丢失之后k位置的数字为0。 
请你根据上述条件，计算可能有多少种不同的arr可以满足以上条件。 
比如 [6,0,9] 只有还原成 [6,9,9]满足全部三个条件，所以返回1种。 
[6,9,9] 达标

tips:
int f(v,i,s)
如果i位置的数字变成了v，s是右边的数和v的关系
在这种设定下，0....i 有几种有效的变法
假设N-1位置的数不是0，是a
那么只需要调用f(a,N-1,2)
如果N-1位置是0，
那么需要调用f(1,N-1,2) +....+f(200,N-1,2)
三维表

可以优化枚举行为

预处理 
O(600N)

[TODO]
找钱的最小张数问题
用滑动窗口做斜率优化

[TODO]
AVL, SBT, 红黑树
AC自动机
资源限制类的题目



Leetcode 683 K个空花盆
Leetcode 568 最大休假天数

相关题目
LeetCode

1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target

LintCode
406. 和大于S的最小子数组
https://www.lintcode.com/problem/minimum-size-subarray-sum/description