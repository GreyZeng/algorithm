[TODO]
给定一个二叉树的头节点head
2）路径可以从任何节点出发，但必须往下走到达任何节点，返回最大路径和

[TODO]

给定一个有序数组arr，给定一个正数aim
1）返回累加和为aim的，所有不同二元组
// leetcode 类似题目，简单一些，题目中限制了无重复元素
LeetCode_0167_TwoSumII.java
双指针
[L] + [R] > aim
[L] + [R] < aim
[L] + [R] = aim
L - 1 和 L 位置的数不等于的时候 收集答案
2）返回累加和为aim的，所有不同三元组
LeetCode_0015_3Sum.java
遍历每个位置，剩余位置 根据 找二元组的算法找出aim — [i] 的所有二元组
 

[TODO]
每种工作有难度和报酬，规定如下
class Job {
public int money;// 该工作的报酬
public int hard; // 该工作的难度
}
给定一个Job类型的数组jobarr，表示所有岗位，每个岗位都可以提供任意份工作
选工作的标准是在难度不超过自身能力值的情况下，选择报酬最高的岗位
给定一个int类型的数组arr，表示所有人的能力
返回int类型的数组，表示每个人按照标准选工作后所能获得的最高报酬

排序
难度一样，只保留最高报酬的
难度更大，报酬却更小的也删掉
然后加入有序表，找离自己最近的最大的值

[TODO]
背包容量为w
一共有n袋零食, 第i袋零食体积为v[i] 
总体积不超过背包容量的情况下，
一共有多少种零食放法？(总体积为0也算一种放法)。

[TODO]
1. 给定一个二维数组matrix，其中每个数都是正数，要求从左上到右下
每一步只能向右或者向下，沿途经过的数字要累加起来
最后请返回最小的路径和

2. 最长公共子序列问题

3. 最长公共子串问题（空间压缩极致用法，二维的非最优解，最优解来自后缀数组）

tips:
动态规划的空间压缩技巧！

[TODO]
给定一个由字符串组成的数组String[] strs，给定一个正数K

返回词频最大的前K个字符串，假设结果是唯一的
tips:
Hash表+小根堆
更优化：用bfprt和快排改进


[TODO]
请实现如下结构：
TopRecord{
public TopRecord(int K)  :  构造时事先指定好K的大小，构造后就固定不变了
public  void add(String str)  :   向该结构中加入一个字符串，可以重复加入
public  List<String> top() : 返回之前加入的所有字符串中，词频最大的K个
}
要求： 
add方法，复杂度O(log K);
top方法，复杂度O(K)

tips:
手写堆



[TODO]
给定一个正整数M，请构造出一个长度为M的数组arr，要求
对任意的i、j、k三个位置，如果i<j<k，都有arr[i] + arr[k] != 2*arr[j]
返回构造出的arr
tips:
长度为1，满足
假设 a + b != 2*c
-> 2 * a - 1 + 2 * b - 1 != 2 * c - 1
2 * a + 2 * b != 2 * c

[a,b,c]
->[2 * a - 1, 2 * b - 1, 2 * c - 1, 2 * a, 2 * b, 2 * c]

[1,5,3]
->[1,9,5,2,10,6]

长度为M，只需要一个(M + 1)/2长度的种子

复杂度估计
T(N) = T(N/2) + O(N)

空间复杂度可以做到O(1)


[TODO]
有n个打包机器从左到右一字排开，上方有一个自动装置会抓取一批放物品到每个打 包机上，放到每个机器上的这些物品数量有多有少，由于物品数量不相同，需要工人 将每个机器上的物品进行移动从而到达物品数量相等才能打包。每个物品重量太大、 每次只能搬一个物品进行移动，为了省力，只在相邻的机器上移动。请计算在搬动最 小轮数的前提下，使每个机器上的物品数量相等。如果不能使每个机器上的物品相同， 返回-1。 例如[1,0,5]表示有3个机器，每个机器上分别有1、0、5个物品，经过这些轮后:
第一轮:1    0 <- 5 => 1 1 4
第二轮:1 <- 1 <- 4 => 2 1 3
第三轮:2    1 <- 3 => 2 2 2
移动了3轮，每个机器上的物品相等，所以返回3
例如[2,2,3]表示有3个机器，每个机器上分别有2、2、3个物品， 这些物品不管怎么移动，都不能使三个机器上物品数量相等，返回-1
tips: 所有数的累加和 % N != 0, 怎么都无法做到

考虑i位置，
左有 ，左余
右有，右余
预处理数组，累加和



[TODO]
长度为N的数组arr，一定可以组成N^2个数值对。
例如arr = [3,1,2]，
数值对有(3,3) (3,1) (3,2) (1,3) (1,1) (1,2) (2,3) (2,1) (2,2)，
也就是任意两个数都有数值对，而且自己和自己也算数值对。
数值对怎么排序？规定，第一维数据从小到大，第一维数据一样的，第二维数组也从小到大。所以上面的数值对排序的结果为：
(1,1)(1,2)(1,3)(2,1)(2,2)(2,3)(3,1)(3,2)(3,3)

给定一个数组arr，和整数k，返回第k小的数值对。

tips:
第一个数字定位
第二个数字定位
无序数组求第K小 bfprt和快排改进

[TODO]
给你一个字符串类型的数组arr，譬如:
String[] arr = { "b\st", "d\", "a\d\e", "a\b\c" };
把这些路径中蕴含的目录结构给打印出来，子目录直接列在父目录下面，并比父目录向右进两格，同一级的需要按字母顺序排列不能乱。
```
a
  b
    c
  d
    e
b
  cst
d
```
tips:
前缀树 + TreeMap + 深度优先遍历

[TODO]
已知一棵二叉树中没有重复节点，并且给定了这棵树的中序遍历数组和先序遍历 数组，返回后序遍历数组。
比如给定:
int[] pre = { 1, 2, 4, 5, 3, 6, 7 };
int[] in = { 4, 2, 5, 1, 6, 3, 7 }; 返回:
{4,5,2,6,7,3,1}

[TODO] 

**非常重要！！！！**
最长递增子序列问题的O(N*logN)的解法
tips:
dp数组和ends数组配合

ends数组：找到的所有长度为i+1的递增子序列中最小结尾是啥
ends的有效区必须有序[需要证明]
任何一个当前数，
去有效区找大于等于cur的最左边的位置，
找到，填进去，然后看下这个位置包括自己在内左边一共有几个数，就是cur此时的dp值
没有找到，扩充有效区，一直到把所有dp都生成


嵌套信封问题的原型就是最长递增子序列
一维从小到大，二维从大到小，二维数据拿出来，最长递增子序列就是嵌套层数

二维穿过点最多的曲线问题

[TODO]
子数组的最大累加和
tips：
cur 依次累加，小于0则重置为0
max，cur和max比较，可以更新则更新max
证明：假设答案法
i...j 是最大累加和 且最长
[i...k]的前缀和>=0
[k.. i-1]的累加和一定< 0

[TODO]
子矩阵的最大累加和(就相当于求长方形的数量)
必须含有
0行且只含有0行
0~1行且只含有0~1行
0~2行且只含有0~2行
...
1 行 且只含有1行
...

压缩数组技巧
O(N^2 * M) --> 考虑一下N和M的长度

[TODO]
双向链表节点结构和二叉树节点结构是一样的，如果你把last认为是left，next认为是next的话。
给定一个搜索二叉树的头节点head，请转化成一条有序的双向链表，并返回链表的头节点。

tips:
case1 中序遍历
case2 二叉树的递归套路
case3 morris遍历

[TODO] 编辑距离问题
给定两个字符串str1和str2，再给定三个整数ic、dc和rc，分别代表插入、删 除和替换一个字符的代价，返回将str1编辑成str2的最小代价。
【举例】
str1="abc"，str2="adc"，ic=5，dc=3，rc=2 从"abc"编辑成"adc"，把'b'替换成'd'是代价最小的，所以返回2
str1="abc"，str2="adc"，ic=5，dc=3，rc=100 从"abc"编辑成"adc"，先删除'b'，然后插入'd'是代价最小的，所以返回8
str1="abc"，str2="abc"，ic=5，dc=3，rc=2 不用编辑了，本来就是一样的字符串，所以返回0

一个样本做行，一个样本做列的
str1 前i个，str2 前j个 最小编辑代价是多少

[TODO]
给定两个字符串s1和s2，问s2最少删除多少字符可以成为s1的子串？
比如 s1 = "abcde"，s2 = "axbc"
返回1。s2删掉'x'就是s1的子串了。

tips:
case 1 如果s2很短，那么生成s2的所有子序列(2^M)，如果是s1的子串（kmp），直接删除s1 - s2 个字符就可以了 O(N*2^M)
case 2 如果s1和s2都很长，那么就生成s1的所有字串，然后和s2求编辑距离（只有插入代价或者删除行为，删除和代替的代价无穷大） O(N^2 * M)


[TODO]
完全二叉树节点的个数 ，要求复杂度低于O(N)
tips:
求总深度，左边扎到最深
右树的最左节点可以扎到最深处，则左树一定是满的
右树的最左节点不能扎到最深处，则右树一定是满的 
O(h^2) -> O((logN)^2)

[TODO]
LRU内存替换算法的实现
put和get每次调用都是O(1)
tips:
HashMap + 双向链表


数据结构的设计题 -> careerup



[TODO]
给定两个字符串，记为start和to，再给定一个字符串列表list，list中一定包含to list中没有重复字符串，所有的字符串都是小写的。
规定: start每次只能改变一个字符，最终的目标是彻底变成to，但是每次变成的新字符串必须在list 中存在。
请返回所有最短的变换路径。
【举例】 
start="abc",end="cab",list={"cab","acc","cbc","ccc","cac","cbb","aab","abb"}
转换路径的方法有很多种，但所有最短的转换路径如下: 
abc -> abb -> aab -> cab
abc -> abb -> cbb -> cab
abc -> cbc -> cac -> cab
abc -> cbc -> cbb -> cab

tips:
构造一个图，只改一个位置可以变到，这两个点就有一个边

构造邻居表
map -> key: string value : 邻居
这一步的复杂度：O(N^2*k) k为字符串的平均长度

构造邻居表可以加速
HashSet中有可能的所有邻居（只变动一个位置的字符）都放入进去 O(K^2) k是字符串的长度


宽度优先遍历 + 深度优先遍历




[TODO]
AVL, SBT, 红黑树
AC自动机



Leetcode 845 最长山脉问题 【单调栈】
Leetcode 683 K个空花盆
Leetcode 568 最大休假天数

相关题目
LeetCode

1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target

LintCode
406. 和大于S的最小子数组
https://www.lintcode.com/problem/minimum-size-subarray-sum/description


题目链接
https://www.nowcoder.com/practice/26e46f1f5e0d48c4b9ba13fe3e8d0ec6?tpId=101&&tqId=33216&rp=5&ru=/activity/oj&qru=/ta/programmer-code-interview-guide/question-ranking

题目描述
给定一个整型数组arr和一个大于1的整数k。已知arr中只有1个数出现了一次，其他的数出现k次，请返回出现了1次的数。