[TODO]
给定一个二叉树的头节点head
2）路径可以从任何节点出发，但必须往下走到达任何节点，返回最大路径和

[TODO]

给定一个有序数组arr，给定一个正数aim
1）返回累加和为aim的，所有不同二元组
// leetcode 类似题目，简单一些，题目中限制了无重复元素
LeetCode_0167_TwoSumII.java
双指针
[L] + [R] > aim
[L] + [R] < aim
[L] + [R] = aim
L - 1 和 L 位置的数不等于的时候 收集答案
2）返回累加和为aim的，所有不同三元组
LeetCode_0015_3Sum.java
遍历每个位置，剩余位置 根据 找二元组的算法找出aim — [i] 的所有二元组

 

[TODO]
1. 给定一个二维数组matrix，其中每个数都是正数，要求从左上到右下
每一步只能向右或者向下，沿途经过的数字要累加起来
最后请返回最小的路径和

2. 最长公共子序列问题

3. 最长公共子串问题（空间压缩极致用法，二维的非最优解，最优解来自后缀数组）

tips:
动态规划的空间压缩技巧！

[TODO]
给定一个由字符串组成的数组String[] strs，给定一个正数K

返回词频最大的前K个字符串，假设结果是唯一的
tips:
Hash表+小根堆
更优化：用bfprt和快排改进


[TODO]
请实现如下结构：
TopRecord{
public TopRecord(int K)  :  构造时事先指定好K的大小，构造后就固定不变了
public  void add(String str)  :   向该结构中加入一个字符串，可以重复加入
public  List<String> top() : 返回之前加入的所有字符串中，词频最大的K个
}
要求： 
add方法，复杂度O(log K);
top方法，复杂度O(K)

tips:
手写堆



[TODO]
给定一个正整数M，请构造出一个长度为M的数组arr，要求
对任意的i、j、k三个位置，如果i<j<k，都有arr[i] + arr[k] != 2*arr[j]
返回构造出的arr
tips:
长度为1，满足
假设 a + b != 2*c
-> 2 * a - 1 + 2 * b - 1 != 2 * c - 1
2 * a + 2 * b != 2 * c

[a,b,c]
->[2 * a - 1, 2 * b - 1, 2 * c - 1, 2 * a, 2 * b, 2 * c]

[1,5,3]
->[1,9,5,2,10,6]

长度为M，只需要一个(M + 1)/2长度的种子

复杂度估计
T(N) = T(N/2) + O(N)

空间复杂度可以做到O(1)


[TODO]
有n个打包机器从左到右一字排开，上方有一个自动装置会抓取一批放物品到每个打 包机上，放到每个机器上的这些物品数量有多有少，由于物品数量不相同，需要工人 将每个机器上的物品进行移动从而到达物品数量相等才能打包。每个物品重量太大、 每次只能搬一个物品进行移动，为了省力，只在相邻的机器上移动。请计算在搬动最 小轮数的前提下，使每个机器上的物品数量相等。如果不能使每个机器上的物品相同， 返回-1。 例如[1,0,5]表示有3个机器，每个机器上分别有1、0、5个物品，经过这些轮后:
第一轮:1    0 <- 5 => 1 1 4
第二轮:1 <- 1 <- 4 => 2 1 3
第三轮:2    1 <- 3 => 2 2 2
移动了3轮，每个机器上的物品相等，所以返回3
例如[2,2,3]表示有3个机器，每个机器上分别有2、2、3个物品， 这些物品不管怎么移动，都不能使三个机器上物品数量相等，返回-1
tips: 所有数的累加和 % N != 0, 怎么都无法做到

考虑i位置，
左有 ，左余
右有，右余
预处理数组，累加和



[TODO]
长度为N的数组arr，一定可以组成N^2个数值对。
例如arr = [3,1,2]，
数值对有(3,3) (3,1) (3,2) (1,3) (1,1) (1,2) (2,3) (2,1) (2,2)，
也就是任意两个数都有数值对，而且自己和自己也算数值对。
数值对怎么排序？规定，第一维数据从小到大，第一维数据一样的，第二维数组也从小到大。所以上面的数值对排序的结果为：
(1,1)(1,2)(1,3)(2,1)(2,2)(2,3)(3,1)(3,2)(3,3)

给定一个数组arr，和整数k，返回第k小的数值对。

tips:
第一个数字定位
第二个数字定位
无序数组求第K小 bfprt和快排改进

[TODO]
给你一个字符串类型的数组arr，譬如:
String[] arr = { "b\st", "d\", "a\d\e", "a\b\c" };
把这些路径中蕴含的目录结构给打印出来，子目录直接列在父目录下面，并比父目录向右进两格，同一级的需要按字母顺序排列不能乱。
```
a
  b
    c
  d
    e
b
  cst
d
```
tips:
前缀树 + TreeMap + 深度优先遍历

[TODO]
已知一棵二叉树中没有重复节点，并且给定了这棵树的中序遍历数组和先序遍历 数组，返回后序遍历数组。
比如给定:
int[] pre = { 1, 2, 4, 5, 3, 6, 7 };
int[] in = { 4, 2, 5, 1, 6, 3, 7 }; 返回:
{4,5,2,6,7,3,1}

[TODO] 

**非常重要！！！！**
最长递增子序列问题的O(N*logN)的解法
tips:
dp数组和ends数组配合

ends数组：找到的所有长度为i+1的递增子序列中最小结尾是啥
ends的有效区必须有序[需要证明]
任何一个当前数，
去有效区找大于等于cur的最左边的位置，
找到，填进去，然后看下这个位置包括自己在内左边一共有几个数，就是cur此时的dp值
没有找到，扩充有效区，一直到把所有dp都生成


嵌套信封问题的原型就是最长递增子序列
一维从小到大，二维从大到小，二维数据拿出来，最长递增子序列就是嵌套层数

二维穿过点最多的曲线问题

[TODO]
子数组的最大累加和
tips：
cur 依次累加，小于0则重置为0
max，cur和max比较，可以更新则更新max
证明：假设答案法
i...j 是最大累加和 且最长
[i...k]的前缀和>=0
[k.. i-1]的累加和一定< 0

[TODO]
子矩阵的最大累加和(就相当于求长方形的数量)
必须含有
0行且只含有0行
0 ~ 1行且只含有0 ~ 1行
0 ~ 2行且只含有0 ~ 2行
...
1 行 且只含有1行
...

压缩数组技巧
O(N^2 * M) --> 考虑一下N和M的长度

[TODO]
双向链表节点结构和二叉树节点结构是一样的，如果你把last认为是left，next认为是next的话。
给定一个搜索二叉树的头节点head，请转化成一条有序的双向链表，并返回链表的头节点。

tips:
case1 中序遍历
case2 二叉树的递归套路
case3 morris遍历

[TODO] 编辑距离问题
给定两个字符串str1和str2，再给定三个整数ic、dc和rc，分别代表插入、删 除和替换一个字符的代价，返回将str1编辑成str2的最小代价。
【举例】
str1="abc"，str2="adc"，ic=5，dc=3，rc=2 从"abc"编辑成"adc"，把'b'替换成'd'是代价最小的，所以返回2
str1="abc"，str2="adc"，ic=5，dc=3，rc=100 从"abc"编辑成"adc"，先删除'b'，然后插入'd'是代价最小的，所以返回8
str1="abc"，str2="abc"，ic=5，dc=3，rc=2 不用编辑了，本来就是一样的字符串，所以返回0

一个样本做行，一个样本做列的
str1 前i个，str2 前j个 最小编辑代价是多少

[TODO]
给定两个字符串s1和s2，问s2最少删除多少字符可以成为s1的子串？
比如 s1 = "abcde"，s2 = "axbc"
返回1。s2删掉'x'就是s1的子串了。

tips:
case 1 如果s2很短，那么生成s2的所有子序列(2^M)，如果是s1的子串（kmp），直接删除s1 - s2 个字符就可以了 O(N*2^M)
case 2 如果s1和s2都很长，那么就生成s1的所有字串，然后和s2求编辑距离（只有插入代价或者删除行为，删除和代替的代价无穷大） O(N^2 * M)


[TODO]
完全二叉树节点的个数 ，要求复杂度低于O(N)
tips:
求总深度，左边扎到最深
右树的最左节点可以扎到最深处，则左树一定是满的
右树的最左节点不能扎到最深处，则右树一定是满的 
O(h^2) -> O((logN)^2)

[TODO]
LRU内存替换算法的实现
put和get每次调用都是O(1)
tips:
HashMap + 双向链表


数据结构的设计题 -> careerup



[TODO]
给定两个字符串，记为start和to，再给定一个字符串列表list，list中一定包含to list中没有重复字符串，所有的字符串都是小写的。
规定: start每次只能改变一个字符，最终的目标是彻底变成to，但是每次变成的新字符串必须在list 中存在。
请返回所有最短的变换路径。
【举例】 
start="abc",end="cab",list={"cab","acc","cbc","ccc","cac","cbb","aab","abb"}
转换路径的方法有很多种，但所有最短的转换路径如下: 
abc -> abb -> aab -> cab
abc -> abb -> cbb -> cab
abc -> cbc -> cac -> cab
abc -> cbc -> cbb -> cab

tips:
构造一个图，只改一个位置可以变到，这两个点就有一个边

构造邻居表
map -> key: string value : 邻居
这一步的复杂度：O(N^2*k) k为字符串的平均长度

构造邻居表可以加速
HashSet中有可能的所有邻居（只变动一个位置的字符）都放入进去 O(K^2) k是字符串的长度


宽度优先遍历 + 深度优先遍历

[TODO]
最大子数组的异或和
tips:
方法1：暴力解O(N^3)
方法2：O(N^2) 前缀异或和 辅助数组
方法3：前缀树
[11,1,15,10,13,4]
e[-1] = 0000
e[0..0] = 11 = 1011
e[0..1] = 11^1 = 1010
e[0..2] = 0101
e[0..3] = 1111
e[0..4] = 0010
e[0..5] = 0110
这些数构造成前缀树
最高位（符合位）期待一样，紧着高位要期待不一样的

类似题目：
数组划分的部分进行异或和生成的0最多
[321 | 0 | 4 | 321 | 0 | 0 | 312 | 0 | 213]
tips:
假设答案法（子数组的最大累加和也用到了这个方法），
假设[0..i]异或和为sum
sum上次出现的位置j，
dp[i] = max{dp[i-1] , dp[j] + 1}


[TODO]
给定一个只由 0(假)、1(真)、&(逻辑与)、|(逻辑或)和^(异或)五种字符组成 的字符串express，再给定一个布尔值 desired。返回express能有多少种组合 方式，可以达到desired的结果。
【举例】
express="1^0|0|1"，desired=false
只有 1^((0|0)|1)和 1^(0|(0|1))的组合可以得到 false，返回 2。 express="1"，desired=false
无组合则可以得到false，返回0
tips:
范围上尝试的模型
f(L,R,期待)
优化：
两张二维表 T表，F表

[TODO]
给出一组正整数arr，你从第0个数向最后一个数，
每个数的值表示你从这个位置可以向右跳跃的最大长度
计算如何以最少的跳跃次数跳到最后一个数。
step: 目前跳了几步 ,初始0
curR：step步内，右边界到哪里，初始 0
next: 如果再跳一步，能跳到哪里 初始-1
从左往右的尝试模型

[TODO] 范围上的尝试模型 + 从左到右的尝试模型
str中，至少切几刀，保证每个部分都是回文串
f(str,i), 从i到后面，最多能且切多少个回文串
dp[i][j] 是否是回文 对角线是TRUE，
普遍位置：i == j && dp[i+1][j-1]

[TODO] 一个样本做行 一个样本做列
给定两个有序数组arr1和arr2，再给定一个正数K
求两个数累加和最大的前K个，两个数必须分别来自arr1和arr2
tips:
大根堆 sum来组织
右下角最大，先进大根堆，然后弹出，左边和上面的依次加入
不要重复加入
O(K*logK)

[TODO]
给定一个正数数组arr，返回该数组能不能分成4个部分，并且每个部分的累加和相等，切分位置的数不要。
例如:
arr=[3, 2, 4, 1, 4, 9, 5, 10, 1, 2, 2] 返回true
三个切割点下标为2, 5, 7. 切出的四个子数组为[3,2], [1,4], [5], [1,2,2]，
累加和都是5

tips:
数组长度一定要大于7
前缀和加入map中
第一刀 1 .... N - 6
第一刀确定后，第二刀的位置


[TODO]
给定三个字符串str1、str2和aim，如果aim包含且仅包含来自str1和str2的所有字符， 而且在aim中属于str1的字符之间保持原来在str1中的顺序，属于str2的字符之间保持 原来在str2中的顺序，那么称aim是str1和str2的交错组成。实现一个函数，判断aim是 否是str1和str2交错组成
【举例】 str1="AB"，str2="12"。那么"AB12"、"A1B2"、"A12B"、"1A2B"和"1AB2"等都是 str1 和 str2 的 交错组成

tips:
一个样本做行一个样本做列的模型
dp[i][j] str1 拿出前缀i长度，str2 拿出前缀j长度，能否交错组成str[i+j]


[TODO]
给定一个无序数组arr，如果只能再一个子数组上排序
返回如果让arr整体有序，需要排序的最短子数组长度

tips:
从左往右遍历i，i左边最大值maxleft maxleft <= a[i] v   maxleft > a[i] x
从右往左遍历i，i右边最大值minright minleft >= a[i] v   minleft < a[i] x

[TODO] 数组中最小不可组成和
给定一个正数数组 arr，其中所有的值都为整数，以下是最小不可组成和的概念:
把 arr 每个子集内的所有元素加起来会出现很多值，其中最小的记为 min，最大的记为max 在区间[min,max]上，如果有数不可以被arr某一个子集相加得到，那么其中最小的那个数是arr 的最小不可组成和 在区间[min,max]上，如果所有的数都可以被arr的某一个子集相加得到，那么max+1是arr的最 小不可组成和
请写函数返回正数数组 arr 的最小不可组成和。
【举例】
arr=[3,2,5]。子集{2}相加产生 2 为 min，子集{3,2,5}相加产生 10 为 max。在区间[2,10] 上，4、 6 和 9 不能被任何子集相加得到，其中 4 是 arr 的最小不可组成和。 arr=[1,2,4]。子集{1}相加产生 1 为 min，子集{1,2,4}相加产生 7 为 max。在区间[1,7]上， 任何 数都可以被子集相加得到，所以 8 是 arr 的最小不可组成和。
tips:
背包方法可以解 dp[i][j] 0..i位置能否组成j 

【进阶】
如果已知正数数组 arr 中肯定有 1 这个数，是否能更快地得到最小不可组成和?
tips: 
先排序
range = 1
1 ~ range所有的数都可以加出来
i位置的数是a
a > range + 1  -> return range + 1
a <= range + 1 --> range = range + a 如果都满足，return range + 1


[TODO]
给定一个有序的正数数组arr和一个正数range，如果可以自由选择arr中的数字，想累加得 到 1~range 范围上所有的数，返回arr最少还缺几个数。
【举例】
arr = {1,2,3,7}，range = 15
想累加得到 1~15 范围上所有的数，arr 还缺 14 这个数，所以返回1 arr = {1,5,7}，range = 15
想累加得到 1~15 范围上所有的数，arr 还缺 2 和 4，所以返回2
tips:
先排序

[TODO]
在一个字符串中找到没有重复字符子串中最长的长度。
例如:
abcabcbb没有重复字符的最长子串是abc，长度为3 
bbbbb，答案是b，长度为1
pwwkew，答案是wke，长度是3
要求:答案必须是子串，"pwke" 是一个子字符序列但不是一个子字符串。

tips：
必须以i位置结尾的情况下答案是多少
预处理数组：上次i位置出现的位置 用map
还依赖dp[i-1]的值

[TODO]
一个数组中，如果两个数的最小公共因子大于1，则认为这两个数之间有通路
返回数组中，有多少个独立的域
tips:
并查集 不优化的话是O(N^2)
如果每个值都不是特别大，可以把这个值拆分出其质数因子 
map中存 key: 质数因子 value: 下标
O(N*V)
O(N*N)
还可以优化成O(N*根号V)
质数因子可以转换成代表因子
比如100
质数因子很多，但是代表因子只有：
2，50
4，25
5，20
10，10

最大公约数

[TODO]
给定一个全是小写字母的字符串str，删除多余字符，使得每种字符只保留一个，并让 最终结果字符串的字典序最小
【举例】
str = "acbc"，删掉第一个'c'，得到"abc"，是所有结果字符串中字典序最小的。
str = "dbcacbca"，删掉第一个'b'、第一个'c'、第二个'c'、第二个'a'，得到"dabc"， 是所有结 果字符串中字典序最小的。
tips:
建立词频表，然后慢慢删除，当一个位置的词频删除到0的时候，这段中要选出第一个
删除数据可以转换为挑出数据

O(K*N)

[TODO]
给定两个数组arrx和arry，长度都为N。代表二维平面上有N个点，第i个点的x 坐标和y坐标分别为arrx[i]和arry[i]，返回求一条直线最多能穿过多少个点?

tips:
必须穿过某个点的直线
假设某个点是a
1. a 和 x 重合
2. a 和 x 共y
3. a 和 x 共x
4. a 和 x 有斜率 如何表示斜率？ 最大公约数以后用字符串拼接

[TODO]
int[] d，d[i]：i号怪兽的能力
int[] p，p[i]：i号怪兽要求的钱
开始时你的能力是0，你的目标是从0号怪兽开始，通过所有的怪兽。
如果你当前的能力，小于i号怪兽的能力，你必须付出p[i]的钱，贿赂这个怪兽，然后怪兽就会加入你，他的能力直接累加到你的能力上；如果你当前的能力，大于等于i号怪兽的能力，你可以选择直接通过，你的能力并不会下降，你也可以选择贿赂这个怪兽，然后怪兽就会加入你，他的能力直接累加到你的能力上。
返回通过所有的怪兽，需要花的最小钱数。
tips:
方法1：  如果怪兽能力值不大的情况，二维表 能力 + index 达到的最小钱数
方法2： 如果怪兽能力值比较大的情况，二维表  钱数 + index 达到的最大能力  严格花某个钱


[TODO] 范围上的尝试模型
给定一个字符串，如果能在任意位置添加字符，最少添加几个能让字符串整体都是回文串。
tips:
int f(L..R)

进阶：可以通过dp表反推出所有决策结果


[TODO]
一种消息接收并打印的结构设计
已知一个消息流会不断地吐出整数 1到N，但不一定按照顺序吐出。如果上次打印的数为 i， 那么当 i+1 出现时，请打印 i+1 及其之后接收过的并且连续的所有数，直到 1到N 全部接收 并打印完，请设计这种接收并打印的结构。
初始时默认i==0

tips:
hashmap
head表 和 tail表
和链表配合

[TODO]
现有n1+n2种面值的硬币，其中前n1种为普通币，可以取任意枚，后n2种为纪念币， 每种最多只能取一枚(可能有重复值)，每种硬币有一个面值，问能用多少种方法拼出m的面值?
tips:
两个动态规划
普通 + 钱数 i,j 可以斜率优化 --> 只需要最后一行的数据
纪念 + 钱数 i,j 经典背包问题 --> 
假设是10元
普通 0 纪念 10
普通 1 纪念 9
...
普通 10 纪念 0  

[TODO]
给定一个正数N，表示你在纸上写下1~N所有的数字

返回在书写的过程中，一共写下了多少个1

tips:
打表法不行

数位dp的问题
最高位是1 不是1
最高位开始有几个1
其次高位置上有几个1

f(13625) -> 3626 ~ f(3625)
N = 1到k位  
最高位是1
N%10^(k-1) + 1    
+
10^(k-2) * (k - 1)

最高位不是1
10^(k-1) + 10^(k-2) * a * (k - 1) 


复杂度
O(log10(N) * log10(N))

[TODO]
先给出可整合数组的定义:如果一个数组在排序之后，每相邻两个数差的绝对值 都为 1， 则该数组为可整合数组。
例如，[5,3,4,6,2]排序之后为[2,3,4,5,6]， 符合每相邻两个数差的绝对值 都为 1，所以这个数组为可整合数组。 
给定一个整型数组 arr，请返回其中最大可整合子数组的长度。例如， [5,5,3,2,6,4,3]的最大 可整合子数组为[5,3,2,6,4]，所以返回 5。

tips:
hashset, 最大-最小 和 个数之间的关系


[TODO] 
[卡特兰数](卡特兰数.md)

[TODO]
股票问题四连

[TODO]
给定一个数组arr，再给定一个k值
返回累加和小于等于k，但是离k最近的子数组累加和
tips:

TreeSet
前缀和 加入有序表
某个位置结尾的情况下，收集一下答案
如果数组全是正数，可以用窗口

类似：
数组三连的第三个O(N*logN)解法
tips: 采用前缀和
[3,-1,6,-4,2,3,4]
help
[3,2,8,4,6,9, ]
help' 维持一个只升不降的数组
[3,3,8,8,8,9,]
二分查找

[TODO]
给定一个二维数组matrix，再给定一个k值
返回累加和小于等于k，但是离k最近的子矩阵累加和
tips:
通过压缩数组来处理

[TODO]
给定一个二维数组matrix，可以从任何位置出发，每一步可以走向上、下、左、右，四个方向。返回最大递增链的长度。
例子：
matrix = 
5  4  3
3  1  2
2  1  3
从最中心的1出发，是可以走出1 2 3 4 5的链的，而且这是最长的递增链。所以返回长度5
tips:
记忆化搜索  -> O(N*M)

[TODO] 练习递归的能力
给定一个字符类型的二维数组board，和一个字符串组成的列表words。
可以从board任何位置出发，每一步可以走向上、下、左、右，四个方向，
但是一条路径已经走过的位置，不能重复走。
返回words哪些单词可以被走出来。
例子 
board = [
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]
words = ["oath","pea","eat","rain"]
输出：["eat","oath"]
tips:
0. 把words做成前缀树，加速
1. 不能重复走，置为0，然后要恢复现场
2. 深度优先



[TODO]
给定两个字符串S和T，返回S子序列等于T的不同子序列个数有多少个? 如果得到子序列A删除的位置与得到子序列B删除的位置不同，那么认为A和B就是不同的。
【例子】
S = "rabbbit", T = "rabbit"
返回: 3 
是以下三个S的不同子序列，没有^的位置表示删除的位置，因为删除的位置不同，所以这三 个子序列是不一样的
rabbbit
II IIII 
rabbbit
III III 
rabbbit
IIII II 

tips:
样本做行 样本做列 
dp[i][j] : 表示s[0..i] 任意删除的方案，能组成 T[0..j] 这个前缀字符串


[TODO]
给定一个二维数组 map，含义是一张地图，例如，如下矩阵: 
-2 -3   3
-5 -10  1
 0  30 -5
游戏的规则如下: 
骑士从左上角出发，每次只能向右或向下走，最后到达右下角见到公主。
地图中每个位置的值代表骑士要遭遇的事情。
如果是负数，说明此处有怪兽，要让骑士损失血量。
如果是非负数，代表此处有血瓶，能让骑士回血。
骑士从左上角到右下角的过程中，走到任何一个位置时，血量都不能少于1。
为了保证骑士能见到公主，初始血量至少是多少?根据map，返回至少的初始血量。


[TODO]
给定一个矩阵matrix，先从左上角开始，每一步只能往右或者往下走，走到右下角。然后从右下角出发，每一步只能往上或者往左走，再回到左上角。任何一个位置的数字，只能获得一遍。返回最大路径和。
tips:
设置两个小人，走到同一位置的时候，只算一份，路径和，就是来回的最大路径和

[TODO]
给定一个无序数组arr，返回如果排序之后，相邻数之间的最大差值

{3,1,7,9}，如果排序后{1,3,7,9}，相邻数之间的最大差值来自3和7，返回4

要求：不能真的进行排序，并且要求在时间复杂度O(N)内解决

tips:
求最大值和最小值，然后把数分为N+1份，每个桶只装可以进这个桶的最小值和最大值
遍历时，把每个数分到每个桶里面，其中肯定有个桶是空的
桶之间的数取最大差值即可
设置空桶的目的是杀死桶内数据的差值

[TODO]
假设所有字符都是小写字母.   长字符串是str
arr是去重的单词表, 每个单词都不是空字符串且可以使用任意次
使用arr中的单词有多少种拼接str的方式，返回方法数.
tips:
前缀树

[TODO]
给定一棵二叉树的头节点head，和一个数K
路径的定义: 
可以从任何一个点开始，但是只能往下走，往下可以走到任何节点停止
返回路径累加和为K的所有路径中，最长的路径最多有几个节点？
tips:
累加和为K的最长子数组（数组三连问题）
从头节点到当前节点的前缀和

[TODO]
AVL, SBT, 红黑树
AC自动机
资源限制类的题目


Leetcode 845 最长山脉问题 【单调栈】
Leetcode 683 K个空花盆
Leetcode 568 最大休假天数

相关题目
LeetCode

1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target

LintCode
406. 和大于S的最小子数组
https://www.lintcode.com/problem/minimum-size-subarray-sum/description


题目链接
https://www.nowcoder.com/practice/26e46f1f5e0d48c4b9ba13fe3e8d0ec6?tpId=101&&tqId=33216&rp=5&ru=/activity/oj&qru=/ta/programmer-code-interview-guide/question-ranking

题目描述
给定一个整型数组arr和一个大于1的整数k。已知arr中只有1个数出现了一次，其他的数出现k次，请返回出现了1次的数。