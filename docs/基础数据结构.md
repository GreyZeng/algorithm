# 基础数据结构

## 单链表和双向链表

### 单链表反转 && 双向链表反转

Code_0008_ReverseList.java

LeetCode_0206_ReverseLinkedList.java

### 链表中删除给定值的节点

LeetCode_0203_RemoveLinkedListElements.java

## 队列和栈

### 双向链表实现栈和队列

Code_0011_DoubleEndsToStackAndQueue.java

### 数组实现栈和队列

Code_0006_ArrayToStackAndQueue.java

### 最小栈

#### 方法1. 使用两个栈 空间复杂度O(N)

LeetCode_0155_MinStack.java

#### 方法2. 空间复杂度O(1) 但是需要限定值的范围

Code_0013_MinStackO1.java

### 怎么用数组实现不超过固定大小的队列和栈？

LeetCode_0622_DesignCircularQueue.java

LeetCode_0641_DesignCircularDeque.java

### 队列和栈的互相转换

LeetCode_0232_ImplementQueueUsingStacks.java

LeetCode_0225_ImplementStackUsingQueues.java

## 递归

Code08_GetMax 了解递归的原理

## master公式

子问题规模等量的情况下, 可以用master公式来计算递归函数的复杂度

```text
T(N) = a * T(N/b) + O(N^d)
```

其中的a、b、d都是常数

`T(N)`为父过程的数据规模
`T(N/b)`为子过程的数据规模
`a`为子过程的调用次数
`O(N ^ d)`为除了递归过程之外其他调用的时间复杂度

如果`log(b,a) < d`，则递归函数复杂度为`O(N^d)`
如果`log(b,a) > d`，则递归函数复杂度为`O(N^log(b,a))`
如果`log(b,a) == d`，则递归函数复杂度为`O(N^d  * logN)`

注：**该公式只适用子过程的调用都是数据规模相同的情况，**如果一个递归过程有多个子过程数据规模不一样，那么它不能用该公式进行时间复杂度的计算。
