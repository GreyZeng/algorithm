# 四边形不等式优化技巧

## 题目1

> 给定一个非负数组arr，长度为N，那么有N-1种方案可以把arr切成左右两部分, 每一种方案都有，min{左部分累加和，右部分累加和},求这么多方案中，min{左部分累加和，右部分累加和}的最大值是多少？

注：**整个过程要求时间复杂度O(N)**


tips: 先记录一个全局累加和，然后左右两部分扩散
Code_0065_BestSplitForAll

题目二
把题目一中提到的，
min{左部分累加和，右部分累加和}，定义为S(N-1)，也就是说：
S(N-1)：在arr[0…N-1]范围上，做最优划分所得到的min{左部分累加和，右部分累加和}的最大值
现在要求返回一个长度为N的s数组，
s[i] =在arr[0…i]范围上，做最优划分所得到的min{左部分累加和，右部分累加和}的最大值
得到整个s数组的过程，做到时间复杂度O(N)
tips:

1. sum和范围有单调性
2. 范式遵从 差(好(S左，S右))
   都有O(N)的优化
3. 前缀和加速（前缀和数组多加一位，不需要判断边界）

Code_0070_BestSplitForEveryPosition

差(好(S左，S右))
都有O(N)的优化

摆放着n堆石子。现要将石子有次序地合并成一堆
规定每次只能选相邻的2堆石子合并成新的一堆，
并将新的一堆石子数记为该次合并的得分
求出将n堆石子合并成一堆的最小得分（或最大得分）合并方案

eg: [1,4,2,3]

arr[L...R]怎么合并最优 范围上的尝试
dp N*N dp[i][j] --> 最优代价

Code_0071_StoneMerge
有枚举行为，可以优化

四边形不等式技巧特征
1，两个可变参数的区间划分问题
2，每个格子有枚举行为
3，当两个可变参数固定一个，另一个参数和答案之间存在单调性关系
4，而且两组单调关系是反向的：(升 升，降 降)  (升 降，降 升)
5，能否获得指导枚举优化的位置对：上+右，或者，左+下

[TODO]
给定一个整型数组 arr，数组中的每个值都为正数，表示完成一幅画作需要的时间，再 给定 一个整数 num，表示画匠的数量，每个画匠只能画连在一起的画作。所有的画家 并行工作，请 返回完成所有的画作需要的最少时间。
【举例】
arr=[3,1,4]，num=2。
最好的分配方式为第一个画匠画 3 和 1，所需时间为 4。第二个画匠画 4，所需时间 为 4。 因为并行工作，所以最少时间为 4。如果分配方式为第一个画匠画 3，所需时 间为 3。第二个画 匠画 1 和 4，所需的时间为 5。那么最少时间为 5，显然没有第一 种分配方式好。所以返回 4。
arr=[1,1,1,4,3]，num=3。
最好的分配方式为第一个画匠画前三个 1，所需时间为 3。第二个画匠画 4，所需时间 为 4。 第三个画匠画 3，所需时间为 3。返回 4。
LeetCode_0410_SplitArrayLargestSum.java
tips:
k块
min(max(s1,s2...sk))
四边形不等式不是最优解
O(N * K)

有一个最优解

1. 先定一个目标（比如定成累加和 为 0 ~ sum 之间的一个值） 看下需要划分几块
2. 二分 达标位置（取最左的位置）
   O(N*log2Sum)

-----

[TODO]
一条直线上有居民点，邮局只能建在居民点上。给定一个有序正数数组arr，每个值表示 居民点的一维坐标，再给定一个正数 num，表示邮局数量。选择num个居民点建立num个 邮局，使所有的居民点到最近邮局的总距离最短，返回最短的总距离
【举例】
arr=[1,2,3,4,5,1000]，num=2。
第一个邮局建立在 3 位置，第二个邮局建立在 1000 位置。那么 1 位置到邮局的距离 为 2， 2 位置到邮局距离为 1，3 位置到邮局的距离为 0，4 位置到邮局的距离为 1， 5 位置到邮局的距 离为 2，1000 位置到邮局的距离为 0。
这种方案下的总距离为 6， 其他任何方案的总距离都不会 比该方案的总距离更短，所以返回6

题目
arr有序(表示距离)
k=3 表示邮局
建在哪里，总距离最小是多少
暴力尝试 dp[i][j]
0..i位置上，建立j个邮局，总距离最小，放在dp中
一个样本做行，一个样本做列的模型
为了加速，我们需要生成如下结构：
record[i][j] -> 只有一个邮局的时候，总距离最小是多少？ 一个结论，如果必须只能建一座邮局，一定要建在中点的时候总距离最小
record[0][0] = 0
record[0][1] = [1] - [0]
record[0][2] = record[0][1] + [2] - [1]
record[0][3] = record[0][2] + [3] - [1]
....

然后用record去辅助我们的动态规划的尝试
O(N^2 * K) 有枚举行为
0....i给j个邮局m
考虑0...i-1给j个邮局的最优划分k
所以0...i给j个邮局 m>=k

0....i给j个邮局
考虑0...i给j+1个邮局的最优划分T
所以0...i给j个邮局 m<=T
所以    k<=m<=T

1. 有枚举行为
2. dp与i，j存在单调关系
3. 区间划分问题（上下左右的格子可以给当前格子提供上下界的限制）
4. 一个单独格子不会依赖本行和本列的某些值
--> dp[i][j]和临近位置关系来优化枚举行为
   生成choose和dp规模一样，存最优划分

相关习题

[TODO]
一座大楼有 0~N 层，地面算作第 0 层，最高的一层为第 N 层。已知棋子从第 0 层掉落肯定 不会摔碎，
从第 i 层掉落可能会摔碎，也可能不会摔碎(1≤i≤N)。
给定整数 N 作为楼层数， 再给定整数 K 作为棋子数，
返回如果想找到棋子不会摔碎的最高层数，即使在最差的情况下扔的最少次数。一次只能扔一个棋子。
【举例】
N=10，K=1。
返回 10。因为只有 1 棵棋子，所以不得不从第 1 层开始一直试到第 10 层，在最差的情况 下，即第 10 层 是不会摔坏的最高层，最少也要扔 10 次。
N=3，K=2。
返回 2。先在 2 层扔 1 棵棋子，如果碎了，试第 1 层，如果没碎，试第 3 层。 N=105，K=2
返回 14。
第一个棋子先在 14 层扔，碎了则用仅存的一个棋子试 1~13。 若没碎，第一个棋子继续在 27 层扔，碎了则 用仅存的一个棋子试 15~26。 若没碎，第一个棋子继续在 39 层扔，碎了则用仅存的一个棋子试 28~38。 若 没碎，第一个棋子继续在 50 层扔，碎了则用仅存的一个棋子试 40~49。 若没碎，第一个棋子继续在 60 层扔， 碎了则用仅存的一个棋子试 51~59。 若没碎，第一个棋子继续在 69 层扔，碎了则用仅存的一个棋子试 61~68。 若没碎，第一个棋子继续在 77 层扔，碎了则用仅存的一个棋子试 70~76。 若没碎，第一个棋子继续在 84 层 扔，碎了则用仅存的一个棋子试 78~83。 若没碎，第一个棋子继续在 90 层扔，碎了则用仅存的一个棋子试 85~89。 若没碎，第一个棋子继续在 95 层扔，碎了则用仅存的一个棋子试 91~94。 若没碎，第一个棋子继续 在 99 层扔，碎了则用仅存的一个棋子试 96~98。 若没碎，第一个棋子继续在 102 层扔，碎了则用仅存的一 个棋子试 100、101。 若没碎，第一个棋子继续在 104 层扔，碎了则用仅存的一个棋子试 103。 若没碎，第 一个棋子继续在 105 层扔，若到这一步还没碎，那么 105 便是结果。

tips:
如果 k > log2N 二分处理
int f(i,j) 剩余i层楼，还剩下j颗 最少需要多少次数
考虑最差情况

四边形不等式优化 非最优解

最优解
dp[i][j] : i是棋子数，j是扔的次数，假设有i个棋子，可以扔j次的情况下可以搞定多少层楼
dp[i][j] = dp[i-1][j-1] + dp[i][j-1] + 1
列的确定：用空间压缩的方法
O(K*S) S是客观上要解决的次数 K表示的棋子

可以继续优化（有可能转换成斐波那契问题）
