## 排序

### 选择排序

```
arr[0～N-1]范围上，找到最小值所在的位置，然后把最小值交换到0位置。

arr[1～N-1]范围上，找到最小值所在的位置，然后把最小值交换到1位置。

arr[2～N-1]范围上，找到最小值所在的位置，然后把最小值交换到2位置。

…

arr[N-1～N-1]范围上，找到最小值位置，然后把最小值交换到N-1位置。

所以选择排序的时间复杂度为O(N^2)。

Code_0002_SelectionSort.java

单链表的选择排序
LeetCode_0148_SortList.java
```

### 冒泡排序

```
在arr[0～N-1]范围上：

arr[0]和arr[1]，谁大谁来到1位置；

arr[1]和arr[2]，谁大谁来到2位置

…

arr[N-2]和arr[N-1]，谁大谁来到N-1位置

在arr[0～N-2]范围上，重复上面的过程，但最后一步是arr[N-3]和arr[N-2]
，谁大谁来到N-2位置

在arr[0～N-3]范围上，重复上面的过程，但最后一步是arr[N-4]和arr[N-3]，谁大谁来到N-3位置

…

最后在arr[0～1]范围上，重复上面的过程，但最后一步是arr[0]和arr[1]，谁大谁来到1位置

Code_0003_BubbleSort.java
```

### 插入排序


```
想让arr[0~0]上有序，这个范围只有一个数，当然是有序的。

想让arr[0~1]上有序，所以从arr[1]开始往前看，如果arr[1] < arr[0]，就交换。否则什么也不做。

…

想让arr[0~i]上有序，所以从arr[i]开始往前看，arr[i]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。

最后一步，想让arr[0~N-1]上有序， arr[N-1]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。


估算时发现这个算法流程的复杂程度，会因为数据状况的不同而不同。

Code_0001_InsertionSort.java
```

## 二分

### 在一个有序数组中，找某个数是否存在 

LeetCode_0704_BinarySearch.java

### 在一个有序数组中，找>=某个数最左侧的位置 

Code_0019_BinarySearch.java

### 在一个有序数组中，找<=某个数最右侧的位置 

Code_0019_BinarySearch.java

### 相关练习

LeetCode_0035_SearchInsertPosition.java

### 局部最大值问题 

LeetCode_0162_FindPeakElement.java


## 异或运算

### 不用额外变量交换两个值

```
a = a^b;
b = a^b;
a = a^b;
```


### 一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数 

NowCoder_EvenOddTimes.java

### 怎么把一个int类型的数，提取出最右侧的1来


```
i & (~i + 1)
```

### 一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数

```
1. 假设出现了奇数次的数字为a和b，我们对数组所有数做异或操作，得到的最后结果一定是：a^b，记这个值为：m = a^b
2. 将m的二进制数的最右侧的1所代表的数找到，假设这个数为n，最右侧1所在的位置为r
3. 那么整个数组中，一定分为两类数：r位置上为1和r位置上为0的数，且a和b一定分别位于这两类数中（a和b不可能在r位置上同时为0或者同时为1）
4. 我们可以通过n和数组中每个数字做与操作，如果为0，说明这个数字中的r位置为0
5. 然后将这些r位置中为0的数字做异或操作，得到最后得结果就是a和b中的一个，假设为a
6. 然后将a和m做异或，得到b

NowCoder_EvenOddTimesPlus.java
```

### 一个数字中有多少个1
LeetCode_0191_NumberOfOneBits.java


### 一个数组中有一种数出现K次，其他数都出现了M次，M > 1,  K < M找到，出现了K次的数，要求，额外空间复杂度O(1)，时间复杂度O(N)


## 单链表和双向链表

### 单链表和双链表如何反转

### 把给定值都删除

## 队列和栈

### 使用链表实现

### 使用数组实现 

注意：数组实现队列比较复杂, 需要三个变量控制，begin = 0, end = 0, size = 0

size控制是否可以取数或者加数
取从begin取，begin++
拿从end拿，end++


### 最小栈

实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能  
1）pop、push、getMin操作的时间复杂度都是 O(1)。 
2）设计的栈类型可以使用现成的栈结构。 


### 如何使用队列实现栈

pop stack + push stack
- 一次性导完
- 只有pop stack空了才能导数据
- pop stack不为空不用导数据

### 如何使用栈来实现队列


## 递归

### master公式

```
子问题规模等量的情况下：
master公式  
T(N) = a * T(N/b) + O(N^d)(其中的a、b、d都是常数)

T(N)为父过程的数据规模
T(N / b)为子过程的数据规模
a为子过程的调用次数
O(N ^ d)为除了递归过程之外其他调用的时间复杂度

如果 log(b,a) < d，复杂度为O(N^d)
如果 log(b,a) > d，复杂度为O(N^log(b,a))
如果 log(b,a) == d，复杂度为O(N^d  * logN)

该公式只适用子过程的调用都是数据规模相同的情况，如这个例子中两个子过程的数据规模都是T(N/2)。如果一个递归过程有多个子过程数据规模不一样，那么它不能用该公式进行时间复杂度的计算。

```

## 归并排序

使用master公式区分时间复杂度

 