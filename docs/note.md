## 排序

### 选择排序

```
arr[0～N-1]范围上，找到最小值所在的位置，然后把最小值交换到0位置。

arr[1～N-1]范围上，找到最小值所在的位置，然后把最小值交换到1位置。

arr[2～N-1]范围上，找到最小值所在的位置，然后把最小值交换到2位置。

…

arr[N-1～N-1]范围上，找到最小值位置，然后把最小值交换到N-1位置。

所以选择排序的时间复杂度为O(N^2)。

Code_0002_SelectionSort.java

单链表的选择排序
LeetCode_0148_SortList.java
```

### 冒泡排序

```
在arr[0～N-1]范围上：

arr[0]和arr[1]，谁大谁来到1位置；

arr[1]和arr[2]，谁大谁来到2位置

…

arr[N-2]和arr[N-1]，谁大谁来到N-1位置

在arr[0～N-2]范围上，重复上面的过程，但最后一步是arr[N-3]和arr[N-2]
，谁大谁来到N-2位置

在arr[0～N-3]范围上，重复上面的过程，但最后一步是arr[N-4]和arr[N-3]，谁大谁来到N-3位置

…

最后在arr[0～1]范围上，重复上面的过程，但最后一步是arr[0]和arr[1]，谁大谁来到1位置

Code_0003_BubbleSort.java
```

### 插入排序


```
想让arr[0~0]上有序，这个范围只有一个数，当然是有序的。

想让arr[0~1]上有序，所以从arr[1]开始往前看，如果arr[1] < arr[0]，就交换。否则什么也不做。

…

想让arr[0~i]上有序，所以从arr[i]开始往前看，arr[i]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。

最后一步，想让arr[0~N-1]上有序， arr[N-1]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。


估算时发现这个算法流程的复杂程度，会因为数据状况的不同而不同。

Code_0001_InsertionSort.java
```

## 二分

### 在一个有序数组中，找某个数是否存在 

### 在一个有序数组中，找>=某个数最左侧的位置 

### 在一个有序数组中，找<=某个数最右侧的位置 

### 局部最小值问题 

## 异或运算

### 如何不用额外变量交换两个数 

### 一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数 


### 怎么把一个int类型的数，提取出最右侧的1来


### 一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数 


### 一个数组中有一种数出现K次，其他数都出现了M次，M > 1,  K < M找到，出现了K次的数，要求，额外空间复杂度O(1)，时间复杂度O(N)


## 单链表和双向链表

### 单链表和双链表如何反转

### 把给定值都删除

## 队列和栈

### 使用链表实现

### 使用数组实现 

注意：数组实现队列比较复杂, 需要三个变量控制，begin = 0, end = 0, size = 0

size控制是否可以取数或者加数
取从begin取，begin++
拿从end拿，end++


### 最小栈

实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能  
1）pop、push、getMin操作的时间复杂度都是 O(1)。 
2）设计的栈类型可以使用现成的栈结构。 


### 如何使用队列实现栈

pop stack + push stack
- 一次性导完
- 只有pop stack空了才能导数据
- pop stack不为空不用导数据

### 如何使用栈来实现队列


## 递归

### master公式

```
子问题规模等量的情况下：
master公式  
T(N) = a * T(N/b) + O(N^d)(其中的a、b、d都是常数)

T(N)为父过程的数据规模
T(N / b)为子过程的数据规模
a为子过程的调用次数
O(N ^ d)为除了递归过程之外其他调用的时间复杂度

如果 log(b,a) < d，复杂度为O(N^d)
如果 log(b,a) > d，复杂度为O(N^log(b,a))
如果 log(b,a) == d，复杂度为O(N^d  * logN)

该公式只适用子过程的调用都是数据规模相同的情况，如这个例子中两个子过程的数据规模都是T(N/2)。如果一个递归过程有多个子过程数据规模不一样，那么它不能用该公式进行时间复杂度的计算。

```

## 归并排序

使用master公式区分时间复杂度

 