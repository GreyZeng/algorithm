## 选择排序

arr[0～N-1]范围上，找到最小值所在的位置，然后把最小值交换到0位置。

arr[1～N-1]范围上，找到最小值所在的位置，然后把最小值交换到1位置。

arr[2～N-1]范围上，找到最小值所在的位置，然后把最小值交换到2位置。

…

arr[N-1～N-1]范围上，找到最小值位置，然后把最小值交换到N-1位置。

所以选择排序的时间复杂度为O(N^2)。

Code_0002_SelectionSort.java



## 冒泡排序

在arr[0～N-1]范围上：

arr[0]和arr[1]，谁大谁来到1位置；

arr[1]和arr[2]，谁大谁来到2位置

…

arr[N-2]和arr[N-1]，谁大谁来到N-1位置

在arr[0～N-2]范围上，重复上面的过程，但最后一步是arr[N-3]和arr[N-2]
，谁大谁来到N-2位置

在arr[0～N-3]范围上，重复上面的过程，但最后一步是arr[N-4]和arr[N-3]，谁大谁来到N-3位置

…

最后在arr[0～1]范围上，重复上面的过程，但最后一步是arr[0]和arr[1]，谁大谁来到1位置

Code_0003_BubbleSort.java



## 插入排序

想让arr[0~0]上有序，这个范围只有一个数，当然是有序的。

想让arr[0~1]上有序，所以从arr[1]开始往前看，如果arr[1] < arr[0]，就交换。否则什么也不做。

…

想让arr[0~i]上有序，所以从arr[i]开始往前看，arr[i]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。

最后一步，想让arr[0~N-1]上有序， arr[N-1]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。


估算时发现这个算法流程的复杂程度，会因为数据状况的不同而不同。

Code_0001_InsertionSort.java


## 归并排序

递归方式

左部分排序

右部分排序

申请一个额外数组，进行merge操作，谁小拷贝谁进新的数组

复杂度估计：


非递归方式
分组进行排序，组的长度从2开始，下一个是4..8..直到N


Code_0022_MergeSort.java

小和问题

LeetCode_0315_CountOfSmallerNumbersAfterSelf.java

一个数组中所有的降序对

LeetCodeCN_0051_ReversePairs.java
LeetCode_0493_ReversePairs.java


## 随机快排

- Partition
- 荷兰国旗问题：LeetCode_0075_SortColors.java
- 快排实现 Code_0025_QuickSort.java
- 时间复杂度O(N*logN),空间复杂度O(logN)

找第K大/小的数
LeetCode_0215_KthLargestElementInAnArray.java
NowCoder_0088_FindKth.java

## 堆排序
[堆](堆.md)

## 不基于比较的排序
基于桶排序的两种排序
应用范围有限，需要样本的数据状况满足桶的划分 
- 计数排序
O(N) 词频表

- 基数排序
非负数，且每个数都是十进制的情况下
1. 找到最大值
2. 所有其他的值都补齐最大值的位数
3. 准备十个桶
4. 进桶的原则：按队列来 先根据个位数开始入桶，然后倒出来，然后十位数，继续倒出来....（从右向左）


## 排序总结

|          | 时间复杂度 | 额外空间复杂度 | 稳定性 |
| -------- | ---------- | -------------- | ------ |
| 选择排序 | O(N^2)     | O(1)           | 无     |
| 冒泡排序 | O(N^2)     | O(1)           | 有     |
| 插入排序 | O(N^2)     | O(1)           | 有     |
| 归并排序 | O(N*logN)  | O(N)           | 有     |
| 随机快排 | O(N*logN)  | O(logN)        | 无     |
| 堆排序   | O(N*logN)  | O(1)           | 无     |
| 计数排序 | O(N)       | O(M)           | 有     |
| 基数排序 | O(N)       | O(N)           | 有     |