## 归并排序

递归方式: 左部分排序 + 右部分排序 + merge

申请一个额外数组，进行merge操作，谁小拷贝谁进新的数组

复杂度估计, 使用master公式 O(N*logN)

非递归方式
分组进行排序，组的长度从2开始，下一个是4..8..直到N

```
Code_0022_MergeSort.java
LintCode_0006_MergeTwoSortedArrays.java
LintCode_0064_MergeTwoSortedArrays.java
LeetCode_0088_MergeSortedArray.java
NowCoder_MergeSort.java
```

### 小和问题

```
LeetCode_0315_CountOfSmallerNumbersAfterSelf.java
```

### 降序对问题

```
LintCode_0532_ReversePairs.java
LeetCodeCN_0051_ReversePairs.java
LeetCode_0493_ReversePairs.java
```

### 其他问题

给定一个数组arr，两个整数lower和upper，

返回arr中有多少个子数组的累加和在[lower,upper]范围上
LeetCode_0327_CountOfRangeSum

方法1：归并排序

1. 前缀和加速求区间和
2. 必须以i结尾的达标子数组有多少个

方法2：有序表方式 [TODO]