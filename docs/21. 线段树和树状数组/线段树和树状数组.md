# 线段树

某个区间内的元素修改,增加,求和

```java
// L..R上都加V
void add(L, R, V, arr) 
// L..R上都变成V 
void update(L, R, V, arr)
// L..R上求和
int getSum(L, R, arr) 
```

以上方法都要达到log(N)的水平, 以上方法可以任意时刻调用都正确。

数组长度必须是2的n次方 如果不满足2的n次方，要变成满二叉树，通过补0的方式，比如只有1-6，那么7和8补0

如果N满足2的某次方，则仅需要2N个区间就可以装下所有区间，如果不满足2的某次方，则仅需要4N个区间就可以装下

```java
     1-8
  /          \
 1-4         5-8
/  \       /    \
1-2 3-4   5-6  7-8
/ \  / \  / \  / \
1  2 3  4 5  6 7 8
```

线段树这里的下标都用1开始，0位置弃而不用 就是为了在任意位置（假设位置为i）有：

左孩子对应的下标是：2*i **即：i<<1**，
右孩子对应的下标是：2*i+1 **即：(i<<1)|1**

准备4N个数 MAXN << 2

懒更新机制

add 方法 如果节点包括任务，就不需要下发，存在lazy信息中，如果没有包住，就要下发  
当新的任务到的时候，如果自己原先有懒信息的时候，则当前节点把懒信息发给左孩子和右孩子(下发一层)，然后把懒的信息置为0, 这一步的操作是log（N）

update 方法 change[] update[] 配合使用  
如果一个节点收到一个update方法，假设更新为C（存在change数组中），则这个节点的所有lazy失效，sum直接变成 ： 个数 * C

query方法 返回sum

父节点如果可以通过左右简单加工得到，就可以用线段树

什么时候不能用线段树呢？
比如：要求某个区间出现次数最多的值（这个无法用线段树，因为出现次数最多的值可以既不是左边出现最多的值，也不是右边出现最多的值）

## 线段树源码

Code_0007_SegmentTree.java

## 区域和检索 - 数组可修改

LeetCode_0307_RangeSumQuery.java

## 区域和检索 - 数组不可变

LeetCode_0303_RangeSumQueryImmutable.java

## 落方块问题

LeetCode_0699_FallingSquares.java

[TODO]
矩形最大重合位置
矩形的遍历顺序，按底从小到大，矩形放list，重合区域必以某个底为底
遍历list的时候，如果某个矩形的上顶都比底更低，那么就可以剔除掉，
此时得到一堆矩形，这堆矩形的左边和右边抽取出来，看线段重合最多的即为答案

至少移除多少个区间后可以保证线段不重合
LeetCode_0435_NonOverlappingIntervals.java

字符串尽可能分割成多个片段，每个字符最多出现在一个片段中
LeetCode_0763_PartitionLabels
