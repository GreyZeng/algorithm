# 滑动窗口

使用双端队列, 在`L <= R`的条件下：`R++`新数从右侧进入, `L++`旧数从左侧出去

> 窗口的最大值/最小值的更新结构
单调双端队列，从头到尾是从大到小的（放每个节点的位置）
每次加入的数从右边进，左边出
加入的数和头的值相比，如果小，就直接进入队列
如果大（或相等），就依次弹出，直到这个数可以进入队列
头部位置就是最大值
调整双端队列的平均复杂度是O（1）

问题本身和范围建立单调性

1. 开头符合窗口逻辑，结尾到窗口的结尾截止
2. 首尾指针（首指针右走，尾指针左走）

## 滑动窗口最大值

LeetCode_0239_SlidingWindowMaximum.java
LintCode_0362_SlidingWindowMaximum.java

## 最大值减去最小值小于或等于num的子数组数量

NowCoder_AllLessNumSubArray.java

## 乘积小于K的子数组

LeetCode_0713_SubarrayProductLessThanK.java

## 加油站问题

LeetCode_0134_GasStation.md
LeetCode_0134_GasStation.java
LintCode_0187_GasStation.java

> TODO O(N)时间复杂度 + O(1)空间复杂度的解法 待理解!

## 双指针

### 接雨水问题

LeetCode_0042_TrappingRainWater.java
LintCode_0363_TrappingRainWater.java

### 绳子最多覆盖点数

Code_0065_CoverMax.java

给定一个数组arr，长度为N且每个值都是正数，代表N个人的体重。再给定一个正数 limit，代表一艘船的载重。
以下是坐船规则，
1)每艘船最多只能做两人;
2)乘客 的体重和不能超过limit
返回如果同时让这N个人过河最少需要几条船。
LeetCode_0881_BoatsToSavePeople.java
tips:
排序双指针
找到小于等于limit/2 的最右边的位置
双指针
[1,3,3,3,4,5,5,5, | 6,6,6,7,7,7,8,9,9]
               L    R
L往左 搭配 R 往右 凑一艘船
考虑 L + R 和 limit的关系，左右先耗尽的情况具体分析
