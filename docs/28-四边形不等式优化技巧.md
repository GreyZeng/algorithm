# 四边形不等式优化技巧

## 题目一

> 给定一个非负数组arr，长度为N，那么有N-1种方案可以把arr切成左右两部分, 每一种方案都有，min{左部分累加和，右部分累加和},求这么多方案中，min{左部分累加和，右部分累加和}的最大值是多少？

注：**整个过程要求时间复杂度O(N)**

代码见：Code_0065_BestSplitForAll.java

## 题目二

> 把题目一中提到的，min{左部分累加和，右部分累加和}，定义为S(N-1)，也就是说：`S(N-1)`表示在`arr[0…N-1]`范围上，
做最优划分所得到的`min{左部分累加和，右部分累加和}的最大值`, 现在要求返回一个长度为N的s数组, `s[i]`表示在`arr[0…i]`范围上，做最优划分所得到的min{左部分累加和，右部分累加和}的最大值, 得到整个s数组的过程，做到时间复杂度`O(N)`

代码见：Code_0070_BestSplitForEveryPosition.java

## 合并石子问题

代码见：NowCoder_StoneMerge.java

## LeetCode 410. 分割数组的最大值

代码：LeetCode_0410_SplitArrayLargestSum.java

最优解为二分

## 四边形不等式技巧特征

1. 两个可变参数的区间划分问题

2. 每个格子有枚举行为

3. 当两个可变参数固定一个，另一个参数和答案之间存在单调性关系

4. 而且两组单调关系是反向的：(升 升，降 降)  (升 降，降 升)

5. 能否获得指导枚举优化的位置对：上+右，或者，左+下

差(好(S左，S右))
都有O(N)的优化

## 邮局问题

Code_0071_PostOfficeProblem.java


相关习题

[TODO]
一座大楼有 0~N 层，地面算作第 0 层，最高的一层为第 N 层。已知棋子从第 0 层掉落肯定 不会摔碎，
从第 i 层掉落可能会摔碎，也可能不会摔碎(1≤i≤N)。
给定整数 N 作为楼层数， 再给定整数 K 作为棋子数，
返回如果想找到棋子不会摔碎的最高层数，即使在最差的情况下扔的最少次数。一次只能扔一个棋子。
【举例】
N=10，K=1。
返回 10。因为只有 1 棵棋子，所以不得不从第 1 层开始一直试到第 10 层，在最差的情况 下，即第 10 层 是不会摔坏的最高层，最少也要扔 10 次。
N=3，K=2。
返回 2。先在 2 层扔 1 棵棋子，如果碎了，试第 1 层，如果没碎，试第 3 层。 N=105，K=2
返回 14。
第一个棋子先在 14 层扔，碎了则用仅存的一个棋子试 1~13。 若没碎，第一个棋子继续在 27 层扔，碎了则 用仅存的一个棋子试 15~26。 若没碎，第一个棋子继续在 39 层扔，碎了则用仅存的一个棋子试 28~38。 若 没碎，第一个棋子继续在 50 层扔，碎了则用仅存的一个棋子试 40~49。 若没碎，第一个棋子继续在 60 层扔， 碎了则用仅存的一个棋子试 51~59。 若没碎，第一个棋子继续在 69 层扔，碎了则用仅存的一个棋子试 61~68。 若没碎，第一个棋子继续在 77 层扔，碎了则用仅存的一个棋子试 70~76。 若没碎，第一个棋子继续在 84 层 扔，碎了则用仅存的一个棋子试 78~83。 若没碎，第一个棋子继续在 90 层扔，碎了则用仅存的一个棋子试 85~89。 若没碎，第一个棋子继续在 95 层扔，碎了则用仅存的一个棋子试 91~94。 若没碎，第一个棋子继续 在 99 层扔，碎了则用仅存的一个棋子试 96~98。 若没碎，第一个棋子继续在 102 层扔，碎了则用仅存的一 个棋子试 100、101。 若没碎，第一个棋子继续在 104 层扔，碎了则用仅存的一个棋子试 103。 若没碎，第 一个棋子继续在 105 层扔，若到这一步还没碎，那么 105 便是结果。

tips:
如果 k > log2N 二分处理
int f(i,j) 剩余i层楼，还剩下j颗 最少需要多少次数
考虑最差情况

四边形不等式优化 非最优解

最优解
dp[i][j] : i是棋子数，j是扔的次数，假设有i个棋子，可以扔j次的情况下可以搞定多少层楼
dp[i][j] = dp[i-1][j-1] + dp[i][j-1] + 1
列的确定：用空间压缩的方法
O(K*S) S是客观上要解决的次数 K表示的棋子

可以继续优化（有可能转换成斐波那契问题）
