## 堆

- 堆结构就是用数组实现的完全二叉树结构
- 完全二叉树中如果每棵子树的最大值都在顶部就是大根堆
- 完全二叉树中如果每棵子树的最小值都在顶部就是小根堆
- 堆结构的heapInsert与heapify操作 复杂度O(logN)
- 堆中某个位置的值变化了，如何调整回堆 ，同时调用heapInsert() 和 heapify()
- 堆结构的增大和减少
- Java中的优先级队列结构(PriorityQueue)，就是堆结构

用数组表示堆的两种情况

// case 1 用0位置

// 左孩子 2 * i + 1

// 右孩子 2 * i + 2

// 父节点 （i - 1）/ 2

// case 2 不用0位置

// 左孩子 2 * i 即：i << 1

// 右孩子 2 * i + 1 即：i << 1 | 1

// 父节点 i / 2 即：i >> 1

Code_0026_Heap.java 


heapify操作
LintCode_0130_Heapify.java


堆排序 

1. 先让整个数组都变成大根堆结构，建立堆的过程: 
   a. 从上到下的方法，时间复杂度为O(N*logN) 
   b. 从下到上的方法，时间复杂度为O(N)
2. 把堆的最大值和堆末尾的值交换， 然后减少堆的大小之后，再去调整堆， 一直周而复始，时间复杂度为O(N*logN) 
3. 把堆的大小减小成0之后，排序完成


堆排序
NowCoder_HeapSort.java


相关堆的习题
已知一个几乎有序的数组。几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k，并且k相对于数组长度来说是比较小的。 请选择一个合适的排序策略，对这个数组进行排序。
Code_0028_DistanceLessK.java
tips:
加k个数进堆，然后再加入一个，弹出一个，最后堆里面剩下的继续弹出即可


自己手写的堆结构 

Code_0029_CustomHeap.java


用手写堆来解答的相关题目


题目1：
LintCode_0550_TopKTimesRealTime.java
请实现如下结构：

```java
TopRecord {
    public TopRecord(int K)  :  构造时事先指定好K的大小，构造后就固定不变了
    public  void add(String str)  :   向该结构中加入一个字符串，可以重复加入
    public  List<String> top() : 返回之前加入的所有字符串中，词频最大的K个
}
```

要求：
add方法，复杂度O(log K);
top方法，复杂度O(K)


题目2：
Dijkstra算法用自定义堆来优化 ,具体见[图](图.md)

[TODO]
题目3：
项目有四个信息:
1)哪个项目经理提的
2)被项目经理润色出来的时间点
3)项目优先级
4)项目花费的时间
项目经理们可以提交项目给程序员们，程序员可以做这些项目。
比如长度为4的数组[1, 3, 2, 2]，表示1号项目经理提的，被项目经理润色出来的时间点是3，优先级2，花 费程序员2个时间。
所以给一个N*4的矩阵，就可以代表N个项目。 给定一个正数pm，表示项目经理的数量，每个项目经理只负责自己的那些项目，并且一次只能提交一个项目 给程序员们，这个提交的项目做完了，才能再次提交。 经理对项目越喜欢，就会越早提交。一个项目优先级越高越被喜欢;如果优先级一样，花费时间越少越喜欢; 如果还一样，被项目经理润色出来的时间点越早越喜欢。 给定一个正数sde，表示程序员的数量，所有经理提交了的项目，程序员会选自己喜欢的项目做，每个人做 完了一个项目，然后才会再来挑选。 当程序员在挑选项目时，有自己的喜欢标准。一个项目花费时间越少越被喜欢;如果花费时间一样，该项目 的负责人编号越小越被喜欢。
返回一个长度为N的数组，表示N个项目的结束时间。
比如:
int pms = 2;
int sde = 2;
int[][] programs = { { 1, 1, 1, 2 }, { 1, 2, 1, 1 }, { 1, 3, 2, 2 }, { 2, 1, 1, 2 }, { 2, 3, 5, 5 } };
返回:{3, 4, 5, 3, 9}

tips:
项目经理堆
程序员堆
add() -> 加设计书
get() -> 程序员喜欢的项目