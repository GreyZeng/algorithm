## 滑动窗口

R++
新数从右侧进入

L++
旧数从左侧出去

L <= R 

窗口的最大值/最小值的更新结构
单调双端队列，从头到尾是从大到小的（放每个节点的位置）
每次加入的数从右边进，左边出
加入的数和头的值相比，如果小，就直接进入队列
如果大（或相等），就依次弹出，直到这个数可以进入队列
头部位置就是最大值
调整双端队列的平均复杂度是O（1）


题目一 

LeetCode_0239_SlidingWindowMaximum


题目二
给定一个整型数组arr，和一个整数num
某个arr中的子数组sub，如果想达标，必须满足：
sub中最大值 – sub中最小值 <= num，
返回arr中达标子数组的数量
NowCoder_AllLessNumSubArray.java

arr[L..R]达标，则arr中内部的任何一个子数组都达标
arr[L..R]不达标，则arr扩充后肯定也不达标

问题本身和范围建立单调性
1。开头符合窗口逻辑，结尾到窗口的结尾截止
2。首尾指针（首指针右走，尾指针左走）

题目三

LeetCode_0713_SubarrayProductLessThanK.java

题目四

LeetCode_0134_GasStation.java


## 双指针

给定一个数组arr，已知其中所有的值都是非负的，将这个数组看作一个容器， 请返回容器能装多少水
比如，arr = {3，1，2，5，2，4}，根据值画出的直方图就是容器形状，该容 器可以装下5格水
再比如，arr = {4，5，1，3，2}，该容器可以装下2格水

case 1
预处理数组
i位置，Math.max{Math.min(左边部分的最大值 左边部分的最大值) - [i], 0}

case 2 （最优解）
双指针
L,R,max左，max右
LeetCode_0042_TrappingRainWater



给定一个有序数组arr，从左到右依次表示X轴上从左往右点的位置
给定一个正整数K，返回如果有一根长度为K的绳子，最多能盖住几个点
绳子的边缘点碰到X轴上的点，也算盖住
Code_0065_CoverMax.java
tips：
暴力方法：
贪心，绳子边缘没必要不压中某个点
以每个位置作为结尾来找，假设某个位置是103，长度是5，
其实就是找[0，102]范围内>=98的最左的点
O(N*logN)
最优解
长度和范围有单调性 -> 滑动窗口，左右指针
在牛客上，[类似题目](https://www.nowcoder.com/questionTerminal/2b2567c9b95743f19c167bb1ec644b43)
和这题有点差别，牛客上的题目是不算边缘压中的情况的


给定一个数组arr，长度为N且每个值都是正数，代表N个人的体重。再给定一个正数 limit，代表一艘船的载重。
以下是坐船规则，
1)每艘船最多只能做两人;
2)乘客 的体重和不能超过limit
返回如果同时让这N个人过河最少需要几条船。
LeetCode_0881_BoatsToSavePeople.java
tips:
排序双指针
找到小于等于limit/2 的最右边的位置
双指针
[1,3,3,3,4,5,5,5, | 6,6,6,7,7,7,8,9,9]
               L    R
L往左 搭配 R 往右 凑一艘船
考虑 L + R 和 limit的关系，左右先耗尽的情况具体分析

