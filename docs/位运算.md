
首先异或操作是对每一位都进行异或（相同为0，不同为1），但需要先把数转换成补码才行。

1、正数的补码即本身

2、负数的补码为各位取反然后加1（最高为保持为1不变）

以-2的一个字节为例
 
原码： 1000 0010
反码： 1111 1101
补码： 1111 1110
3、将两数的补码按位进行异或

以 3 ^ （-2）为例
 
3 的补码：0000 0011
-2的补码：1111 1110
 
异或：    1111 1101  此为结果的补码，然后要反过来计算原码
 
由 原码 -> 取反 -> +1 补码  得 补码 -1 -> 取反 -> 原码
 
补码：    1111 1101
-1 ：     1111 1100
原码：    1000 0011
即结果为 -3
 


## Random to Random

核心就是生成0/1随机源！
LeetCode_0470_ImplementRand10UsingRand7.java
Code_0059_RandToRand.java

## 异或运算就是无进位相加

0^N = N
N^N = 0
异或满足交换律和结合律

```
a = a^b;
b = a^b;
a = a^b;
```

## 怎么把一个int类型的数，提取出最右侧的1来（二进制）

```
i & (~i + 1)
```



## 一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数？

NowCoder_EvenOddTimes.java

## 一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数

1. 假设出现了奇数次的数字为a和b，我们对数组所有数做异或操作，得到的最后结果一定是：a^b，记这个值为：m = a^b
2. 将m的二进制数的最右侧的1所代表的数找到，假设这个数为n，最右侧1所在的位置为r
3. 那么整个数组中，一定分为两类数：r位置上为1和r位置上为0的数，且a和b一定分别位于这两类数中（a和b不可能在r位置上同时为0或者同时为1）
4. 我们可以通过n和数组中每个数字做与操作，如果为0，说明这个数字中的r位置为0
5. 然后将这些r位置中为0的数字做异或操作，得到最后得结果就是a和b中的一个，假设为a
6. 然后将a和m做异或，得到b

Code_0004_EvenOddTimes.java

一个数字中有多少个1
LeetCode_0191_NumberOfOneBits.java



题目描述
NowCoder_FindOneInK.java
给定一个整型数组arr和一个大于1的整数k。已知arr中只有1个数出现了一次，其他的数出现k次，请返回出现了1次的数。
tips:
转成k进制，k进制的异或和

