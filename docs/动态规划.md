# 动态规划

## 认识递归

### 汉诺塔问题

LeetCodeCN_0806_HanotaLcci.java

NowCoder_HanotaII.java

[汉诺塔问题](https://www.cnblogs.com/greyzeng/p/14418802.html)

### 逆序一个栈（不申请额外的空间）

NowCoder_ReverseStack.java

### 打印所有子序列

LeetCode_0078_Subsets.java

### 打印字符串的全部排列

> 可以使用递归和非递归两种方式实现

LeetCode_0046_Permutations.java

LeetCode_0047_PermutationsII.java

## 范围上尝试的模型

> `arr[L...R]` 规模缩小

### 机器人达到指定位置方法数

> 使用压缩数组技巧

NowCoder_RobotWalk.java

### 纸牌博弈问题

NowCoder_Cards.java

## 从左往右的尝试模型

### 背包问题I && 背包问题II

LintCode_0092_Backpack.java

LintCode_0125_BackpackII.java

### 解码问题

LeetCode_0091_DecodeWays.java

### 贴纸拼词

LeetCode_0691_StickersToSpellWord.java

## 多样本位置全对应的尝试模型

> 常用解法：一个样本做行，一个样本做列

### 两个字符串的最长公共子序列

--- LeetCode_1143_LongestCommonSubsequence.java

LintCode_0077_LongestCommonSubsequence.java

### 马跳步问题

> 三维可变参数

NowCoder_HorseJump.java

## 范围上的尝试模型

### 求最长回文子序列长度

方式1：一个串和它的逆序串的最大公共子序列就是这个串的最长回文子序列

方式2：范围尝试

LeetCode_0516_LongestPalindromicSubsequence.java

LintCode_0667_LongestPalindromicSubsequence.java

## 寻找业务限制的尝试模型

给定一个数组arr，arr[i]代表第i号咖啡机泡一杯咖啡的时间 给定一个正数N，表示N个人等着咖啡机泡咖啡，每台咖啡机只能轮流泡咖啡
只有一台咖啡机，一次只能洗一个杯子，时间耗费a，洗完才能洗下一杯
每个咖啡杯也可以自己挥发干净，时间耗费b，咖啡杯可以并行挥发 假设所有人拿到咖啡之后立刻喝干净， 返回从开始等到所有咖啡机变干净的最短时间
三个参数：int[] arr、int N，int a、int b

Code_0085_Coffee.java

Code_0055_WashCoffee.java

## 空间压缩技巧

### 二维数组matrix的最大/最小路径和

LeetCodeCN_0047_MaxValue.java

LintCode_0110_MinimumPathSum.java

## 从左往右的尝试模型

### arr是货币数组，其中的值都是正数。再给定一个正数aim, 每个值都认为是一张货币，即便是值相同的货币也认为每一张都是不同的，返回组成aim的方法数

> 例如：arr = {1,1,1}，aim = 2 , 第0个和第1个能组成2，第1个和第2个能组成2，第0个和第2个能组成2 , 一共就3种方法，所以返回3

Code_0004_CoinsWayEveryPaperDifferent.java

### arr是货币数组，其中的值都是正数。再给定一个正数aim。每个值都认为是一张货币，认为值相同的货币没有任何不同，返回组成aim的方法数

> 例如：arr = {1,2,1,1,2,1,2}，aim = 4 方法：1+1+1+1、1+1+2、2+2 一共就3种方法，所以返回3

Code_0052_CoinsWaySameValueSamePaper.java

> 给定5个参数，N，M，row，col，k 表示在`N*M`的区域上，醉汉Bob初始在(row,col)位置 Bob一共要迈出k步，且每步都会等概率向上下左右四个方向走一个单位,任何时候Bob只要离开`N*M`的区域，就直接死亡,返回k步之后，Bob还在N*M的区域的概率

Code_0054_BobDie.java

> 给定3个参数，N，M，K 怪兽有N滴血，等着英雄来砍自己 英雄每一次打击，都会让怪兽流失[0~M]的血量 到底流失多少？每一次在[0~M]上等概率的获得一个值 求K次打击之后，英雄把怪兽砍死的概率 
 
可能性：(M+1)^K次方 优化枚举行为

血量<=0 -> (M+1)^time 次数 

Code_0082_KillMonster.java

### 从左往右的模型 arr是面值数组，其中的值都是正数且没有重复。再给定一个正数aim，每个值都认为是一种面值，且认为张数是无限的。返回组成aim的方法数

> 例如：arr = {1,2}，aim = 4 方法如下：1+1+1+1、1+1+2、2+2 一共就3种方法，所以返回3

Code_0025_CoinsWayNoLimit.java

### 裂开的方案数(优化枚举行为)

> 给定一个正数1，裂开的方法有一种，(1) 给定一个正数2，裂开的方法有两种，(1和1)、(2) 
> 给定一个正数3，裂开的方法有三种，(1、1、1)、(1、2)、(3) 
> 给定一个正数4， 裂开的方法有五种，(1、1、1、1)、(1、1、2)、(1、3)、(2、2)、 (4)
> 给定一个正数n，求裂开的方法数。 动态规划优化状态依赖的技巧 f(int pre, int rest)
> 裂开的方法数前面不能超过前面

Code_0044_SplitNum.java 

可以优化枚举行为（前面有：分硬币方法，股票问题3）

### 分成两个最接近集合问题(背包问题)

> 给定一个正数数组arr， 请把arr中所有的数分成两个集合，尽量让两个集合的累加和接近 返回： 最接近的情况下，较小集合的累加和  

Code_0083_SplitSumClosed.java

### 分成两个最接近集合问题II

> 给定一个正数数组arr，请把arr中所有的数分成两个集合 如果arr长度为偶数，两个集合包含数的个数要一样多 如果arr长度为奇数，
> 两个集合包含数的个数必须只差一个 请尽量让两个集合的累加和接近 返回： 最接近的情况下，较小集合的累加和

偶数个的时候，比如8，考虑4个的情况
奇数个的时候，比如7，要考虑4个和3个的情况

三维 Code_0084_SplitSumClosedSizeHalf.java 向上取整(N+1)/2

### N皇后问题 

在N*N的棋盘上要摆N个皇后， 要求任何两个皇后不同行、不同列， 也不在同一条斜线上 给定一个整数n，返回n皇后的摆法有多少种。 
n=1，返回1 
n=2或3，2皇后和3皇后问题无论怎么摆都不行，返回0 
n=8，返回92 

tip:
```
[x,y]和[甲,乙]
```
是否有冲突，只需要判断两个条件
```
(y == 乙) || (|甲-x|==|乙-y|)
```

Code_0086_NQueens.java O(N^N)

-----

## 范围上的尝试模型

### 最少添加多少个字符变成回文

LeetCode_1312_MinimumInsertionStepsToMakeAStringPalindrome.java

进阶：*可以通过dp表反推出所有决策结果*

## 寻找业务限制的尝试模型

### 零钱兑换系列问题

#### 硬币数量是无限的，计算并返回可以凑成总金额所需的最少的硬币个数, 如果没有任何一种硬币组合能组成总金额，返回-1

LeetCode_0322_CoinChange.java

## TODO



## 多样本位置全对应的尝试模型3

给定三个字符串str1、str2和aim，如果aim包含且仅包含来自str1和str2的所有字符， 而且在aim中属于str1的字符之间保持原来在str1中的顺序，属于str2的字符之间保持
原来在str2中的顺序，那么称aim是str1和str2的交错组成。实现一个函数，判断aim是 否是str1和str2交错组成 LeetCode_0097_InterleavingString.java 【举例】 str1="AB"
，str2="12"。那么"AB12"、"A1B2"、"A12B"、"1A2B"和"1AB2"等都是 str1 和 str2 的 交错组成 LeetCode_0097_InterleavingString.java tips:
一个样本做行一个样本做列的模型
```dp[i][j]``` str1 拿出前缀i长度，str2 拿出前缀j长度，能否交错组成str[i+j]

[TODO] 相关的背包问题 416 分割等和子集（medium） 494 目标和（medium） 474 一和零（medium） 322 零钱兑换（medium） 518 零钱兑换 II（medium） 139 单词拆分（medium）
377 组合总和 Ⅳ（medium）

## 范围上尝试的模型2

给定一个只由 0(假)、1(真)、&(逻辑与)、|(逻辑或)和^(异或)五种字符组成 的字符串express，再给定一个布尔值 desired。返回express能有多少种组合 方式，可以达到desired的结果。 【举例】
express="1^0|0|1"，desired=false 只有 1^((0|0)|1)和 1^(0|(0|1))的组合可以得到 false，返回 2。 express="1"，desired=false
无组合可以得到false，返回0 tips:
范围上尝试的模型 f(L,R,期待)
优化： 两张二维表 T表，F表 NowCoder_ExpressToDesired.java

现有n1+n2种面值的硬币，其中前n1种为普通币，可以取任意枚，后n2种为纪念币， 每种最多只能取一枚(可能有重复值)，每种硬币有一个面值，问能用多少种方法拼出m的面值? NowCoder_CoinWays.java

tips:
两个动态规划 普通 + 钱数 i,j 可以斜率优化 --> 只需要最后一行的数据 纪念 + 钱数 i,j 经典背包问题 -->
假设是10元 普通 0 纪念 10 普通 1 纪念 9 ... 普通 10 纪念 0

## 多样本位置全对应的尝试模型2

一个样本做行 一个样本做列 NowCoder_TwoSortedArraySumTopK.java 给定两个有序数组arr1和arr2，再给定一个正数K 求两个数累加和最大的前K个，两个数必须分别来自arr1和arr2 tips:
大根堆 sum来组织 右下角最大，先进大根堆，然后弹出，左边和上面的依次加入 不要重复加入 O(K*logK)

## 寻找业务限制的尝试模型2

人过河问题，鱼吃人以后，会被其他鱼吃掉 【鱼是奇数的时候，吃，偶数的时候，不能吃】

ABCDE海盗分硬币问题 超过一半的同意才能通过 未被通过的会被杀死 人性本恶 人性本善（利益受损才投死对方） 刚好一半

寄信问题（欧拉信封） 每个人只能寄一封信，只收一封信 f(5) = 4 * (f(3) + f(4))

f(i) = (i-1)*(f(i-1) + f(i-2))
f(1) = 0 f(2) = 1 f(3) = 2

给定一个二维数组matrix，每个单元都是一个整数，有正有负。最开始的时候小Q操纵 一条长度为0的蛇, 从矩阵最左侧任选一个单元格进入地图，蛇每次只能够到达当前位 置的右上相邻，右侧相邻和右下相邻的单元格。 蛇到达一个单元格后，自身的长度会
瞬间加上该单元格的数值，任何情况下长度为负则游戏结束。 小Q是个天才，他拥有一 个超能力， 可以在游戏开始的时候把地图中的某一个节点的值变为其相反数(注:最多 只能改变一个节点).问在小Q游戏过程中，他的蛇最长长度可以到多少? 比如:
1 -4 10 3 -2 -1 2 -1 0 0 5 -2 最优路径为从最左侧的3开始，3 -> -4(利用能力变成4) -> 10。所以返回17。 NowCoder_SnakeGame.java tips:
业务限制的模型

## 暴力递归到动态规划

所有的暴力过程，都是由于有重复计算（比如斐波那契数列问题）

背包容量为w NowCoder_Bag.java 一共有n袋零食, 第i袋零食体积为v[i]
总体积不超过背包容量的情况下， 一共有多少种零食放法？(总体积为0也算一种放法)。

拿纸牌问题改动态规划

动态规划进一步优化（枚举行为） CoinWays

动态规划的进一步优化主要是为了省略枚举行为 0）观察临近格子法 1）空间压缩 2）状态化简 3）四边形不等式

最长公共子串问题（空间压缩极致用法，二维的非最优解，最优解来自后缀数组） LintCode_0079_LongestCommonSubstring.java tips:
动态规划的空间压缩技巧！

范围上的尝试模型 + 从左到右的尝试模型 str中，至少切几刀，保证每个部分都是回文串 LeetCode_0132_PalindromePartitioningII

tips:
从左往右的尝试 f(str,i), 从i到后面，最多能且切多少个回文串 范围上的尝试 ```dp[i][j]``` 是否是回文 对角线是TRUE， 普遍位置：```i == j && dp[i+1][j-1]```

给出一组正整数arr，你从第0个数向最后一个数， 每个数的值表示你从这个位置可以向右跳跃的最大长度 计算如何以最少的跳跃次数跳到最后一个数。 step: 目前跳了几步 ,初始0 curR：step步内，右边界到哪里，初始 0 next:
如果再跳一步，能跳到哪里 初始-1 从左往右的尝试模型 LeetCode_0045_JumpGameII.java

## 重建二叉树 动态规划

- LeetCode_0106_ConstructBinaryTreeFromInorderAndPostorderTraversal.java
- LeetCode_0105_ConstructBinaryTreeFromPreorderAndInorderTraversal.java

## 放灯问题

- NowCoder_Light.java

编辑距离问题 给定两个字符串str1和str2，再给定三个整数ic、dc和rc，分别代表插入、删除和替换一个字符的代价，返回将str1编辑成str2的最小代价。 【举例】 str1="abc"，str2="adc"
，ic=5，dc=3，rc=2 从"abc"编辑成"adc"，把'b'替换成'd'是代价最小的，所以返回2 str1="abc"，str2="adc"，ic=5，dc=3，rc=100 从"abc"编辑成"adc"，先删除'b'
，然后插入'd'是代价最小的，所以返回8 str1="abc"，str2="abc"，ic=5，dc=3，rc=2 不用编辑了，本来就是一样的字符串，所以返回0 tips:
一个样本做行，一个样本做列的 str1 前i个，str2 前j个 最小编辑代价是多少 不带权重：LeetCode_0072_EditDistance.java 带权重: NowCoder_EditDistance.java

给定两个字符串s1和s2，问s2最少删除多少字符可以成为s1的子串？ 比如 s1 = "abcde"，s2 = "axbc"
返回1。s2删掉'x'就是s1的子串了。 Code_0018_MinDeleteCost.java tips:
case 1 如果s2很短，那么生成s2的所有子序列(2^M)，如果是s1的子串（kmp），直接删除s1 - s2 个字符就可以了 O(N*2^M)
case 2 如果s1和s2都很长，那么就生成s1的所有字串，然后和s2求编辑距离（只有插入代价或者删除行为，删除和代替的代价无穷大） O(N^2* M)

### 数组中最小不可组成和

> 给定一个正数数组 arr，其中所有的值都为整数，以下是最小不可组成和的概念：
>
> 把 arr 每个子集内的所有元素加起来会出现很多值，其中最小的记为 min，最大的记为max ，在区间[min,max]上，如果有数不可以被arr某一个子集相加到，那么其中最小的那个数是arr 的最小不可组成和。
>
> 在区间[min,max]上，如果所有的数都可以被arr的某一个子集相加得到，那么max+1是arr的最小不可组成和，请实现一个函数，返回正数数组 arr 的最小不可组成和。
>
> 举例：
>
> arr=[3,2,5]。子集{2}相加产生 2 为 min，子集{3,2,5}相加产生 10 为 max。在区间[2,10] 上，4、 6 和 9 不能被任何子集相加得到，其中 4 是 arr 的最小不可组成和。
>
> arr=[1,2,4]。子集{1}相加产生 1 为 min，子集{1,2,4}相加产生 7 为 max。在区间[1,7]上， 任何 数都可以被子集相加得到，所以 8 是 arr 的最小不可组成和。

tips：

```text
dp[i][j]0..i位置能否组成j
```

Code: NowCoder_FirstUnFormedNum.java

进阶

> 如果已知正数数组 arr 中肯定有 1 这个数，是否能更快地得到最小不可组成和?

Code: NowCoder_FirstUnFormedNumPro.java

tips:
先排序 range = 1 1 ~ range所有的数都可以加出来 i位置的数是a a > range + 1 --> return range + 1 a <= range + 1 --> range = range + a
如果都满足，return range + 1

### 数位dp问题

给定一个正数N，表示你在纸上写下1~N所有的数字，返回在书写的过程中，一共写下了多少个1 LeetCode_0233_NumberOfDigitOne.java

tips:
打表法不行

数位dp的问题 最高位是1 不是1 最高位开始有几个1 其次高位置上有几个1

f(13625) -> 3626 ~ f(3625)
N = 1到k位
最高位是1 N%10^(k-1) + 1

10^(k-2) * (k - 1)

最高位不是1 10^(k-1) + 10^(k-2) *a* (k - 1)

复杂度 O(log10(N) * log10(N))

给定一个二维数组matrix，可以从任何位置出发，每一步可以走向上、下、左、右，四个方向。返回最大递增链的长度。 LeetCode_0329_LongestIncreasingPathInAMatrix.java 例子： matrix =
5 4 3 3 1 2 2 1 3 从最中心的1出发，是可以走出1 2 3 4 5的链的，而且这是最长的递增链。所以返回长度5 tips:
记忆化搜索 -> O(N*M)

给定一个字符类型的二维数组board，和一个字符串组成的列表words。 可以从board任何位置出发，每一步可以走向上、下、左、右，四个方向， 但是一条路径已经走过的位置，不能重复走。 返回words哪些单词可以被走出来。 例子
board = [
['o','a','a','n'],
['e','t','a','e'],
['i','h','k','r'],
['i','f','l','v']
]
words = ["oath","pea","eat","rain"]
输出：["eat","oath"]

LeetCode_0212_WordSearchII tips:

0. 把words做成前缀树，加速
1. 不能重复走，置为0，然后要恢复现场
2. 深度优先

给定两个字符串S和T，返回S子序列等于T的不同子序列个数有多少个? 如果得到子序列A删除的位置与得到子序列B删除的位置不同，那么认为A和B就是不同的。 【例子】 S = "rabbbit", T = "rabbit"
返回: 3 是以下三个S的不同子序列，没有^的位置表示删除的位置，因为删除的位置不同，所以这三 个子序列是不一样的 rabbbit II IIII rabbbit III III rabbbit IIII II

LeetCode_0115_DistinctSubsequences.java tips:
样本做行 样本做列
```dp[i][j]``` : 表示s[0..i] 任意删除的方案，能组成 T[0..j] 这个前缀字符串

给定一个二维数组 map，含义是一张地图，例如，如下矩阵:
-2 -3 3 -5 -10 1 0 30 -5 游戏的规则如下:
骑士从左上角出发，每次只能向右或向下走，最后到达右下角见到公主。 地图中每个位置的值代表骑士要遭遇的事情。 如果是负数，说明此处有怪兽，要让骑士损失血量。 如果是非负数，代表此处有血瓶，能让骑士回血。
骑士从左上角到右下角的过程中，走到任何一个位置时，血量都不能少于1。 为了保证骑士能见到公主，初始血量至少是多少?根据map，返回至少的初始血量。 LeetCode_0174_DungeonGame.java

三维dp 给定一个矩阵matrix，先从左上角开始，每一步只能往右或者往下走，走到右下角。然后从右下角出发，每一步只能往上或者往左走，再回到左上角。任何一个位置的数字，只能获得一遍。返回最大路径和。
NowCoder_MatrixMaxPath LeetCode_0741_CherryPickup tips:
设置两个小人，走到同一位置的时候，只算一份，路径和，就是来回的最大路径和

业务限制的模型 Code_0036_Coffee.java arr中记录咖啡机制造一杯咖啡的时间，假设有m个人，都在0号时间点开始排队，返回一个数组 最后一个得到咖啡的人的时间尽可能短 tips:
小根堆 时间点+制造咖啡的时间 弹出，制造，修改咖啡机的开始时间，再加入小根堆

对于一个字符串, 从前开始读和从后开始读是一样的, 我们就称这个字符串是回文串。例如"ABCBA","AA", "A" 是回文串, 而"ABCD", "AAB"不是回文串。 牛牛特别喜欢回文串, 他手中有一个字符串s,
牛牛在思考能否从字符串中移除部分(0个或多个)字符使其变为回文串， 并且牛牛认为空串不是回文串。牛牛发现移除的方案可能有 很多种, 希望你来帮他计算一下一共有多少种移除方案可以使s变为回文串。 对于两种移除方案, 如果移除的字
符依次构成的序列不一样就是不同的方案。 例如，XXY 4种 ABA 5种 【说明】 这是今年的原题，提供的说明和例子都很让人费解。现在根据当时题目的所有测试用例，重新解释当时的题目 含义:
1)"1AB23CD21"，你可以选择删除A、B、C、D，然后剩下子序列{1,2,3,2,1}，只要剩下的子序列是同一个，那 么就只算1种方法，和A、B、C、D选择什么样的删除顺序没有关系。 2)"121A1"
，其中有两个{1,2,1}的子序列，第一个{1,2,1}是由{位置0，位置1，位置2}构成，第二个{1,2,1} 是由{位置0，位置1，位置4}构成。这两个子序列被认为是不同的子序列。也就是说在本题中，认为字面值一样
但是位置不同的字符就是不同的。 3)其实这道题是想求，str中有多少个不同的子序列，每一种子序列只对应一种删除方法，那就是把多余的东西去掉，而和去掉的顺序无关。 4)也许你觉得我的解释很荒谬，但真的是这样，不然解释不了为什么，XXY 4种
ABA 5种，而且其他的测试用例都印证了这一点。 NowCoder_PWays.java

tips:

范围模型 L x R x a L v R x b L x R v c L v R v d

```dp[L][R]```

```dp[L+1][R] = a + c```
```dp[L][R-1] = a + b```

加工 a + b + c d = a + 1  (考虑空串，所以要加1)

判定一个由[a-z]字符构成的字符串和一个包含'.'和'*'通配符的字符串是否匹配。 通配符'.'匹配任意单一字符,
'*'匹配前一个字符的任意多个字符(包括0个字符)。 字符串长度不会超过100，字符串不为空。 LeetCode_0010_RegularExpressionMatching.java 输入描述:
字符串 str 和包含通配符的字符串 pattern。1 <= 字符串长度 <= 100输出描述: true 表示匹配，false 表示不匹配 tips:
一个样本做行，一个样本做列尝试模型 f(si,ei)  -> si... 能否 匹配 ei... 有效性检查 可以改动态规划，但是没办法做斜率优化

[https://leetcode.com/problems/freedom-trail/](https://leetcode.com/problems/freedom-trail/)
LeetCode_0514_FreedomTrail.java

tips:
f(i,j) -> i拨动到j怎么走最省 map记录哪些位置拥有某个字符 深度优先遍历

给定一个数组 arr，代表一排有分数的气球。每打爆一个气球都能获得分数，假设打爆气 球 的分数为 X，获得分数的规则如下:
1)如果被打爆气球的左边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 L;如果被打爆气球的右边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 R。 获得分数为 L*X*R。 2)
如果被打爆气球的左边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 L;如果被打爆气球的右边所有气球都已经被打爆。获得分数为 L*X。 3)如果被打爆气球的左边所有的气球都已经被打爆;如果被打爆气球的右边有没被打爆的
气球，找到离被打爆气球最近的气球，假设分数为 R;如果被打爆气球的右边所有气球都 已经 被打爆。获得分数为 X*R。 4)如果被打爆气球的左边和右边所有的气球都已经被打爆。获得分数为 X。
目标是打爆所有气球，获得每次打爆的分数。通过选择打爆气球的顺序，可以得到不同的总分，请返回能获得的最大分数。 LeetCode_0312_BurstBalloons 【举例】 arr = {3,2,5} 如果先打爆3，获得3*
2;再打爆2，获得2*5;最后打爆5，获得5;最后总分21 如果先打爆3，获得3*2;再打爆5，获得2*5;最后打爆2，获得2;最后总分18 如果先打爆2，获得3*2*5;再打爆3，获得3*5;最后打爆5，获得5;最后总分50
如果先打爆2，获得3*2*5;再打爆5，获得3*5;最后打爆3，获得3;最后总分48 如果先打爆5，获得2*5;再打爆3，获得3*2;最后打爆2，获得2;最后总分18 如果先打爆5，获得2*5;再打爆2，获得3*
2;最后打爆3，获得3;最后总分19 返回能获得的最大分数为50

tips:

[3,2,5] -> [1,3,2,5,1]
f(1,3) -> 0位置和4位置永远不爆

## 二维数组matrix的最大/最小路径和 上下左右四个方向都可以

[TODO]LintCode_1582_MinimumPathSumII.java

## 纸牌排列数问题

根据数据量猜解法
[TODO] Code_0019_CardsProblem.java

## 打怪兽问题

[TODO] NowCoder_BeatMonster.java
