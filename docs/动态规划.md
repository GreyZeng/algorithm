## 递归复杂度的估计公式

子问题规模等量的情况下：
master公式  
T(N) = a * T(N/b) + O(N^d)(其中的a、b、d都是常数)

T(N)为父过程的数据规模
T(N / b)为子过程的数据规模
a为子过程的调用次数
O(N ^ d)为除了递归过程之外其他调用的时间复杂度

如果 log(b,a) < d，复杂度为O(N^d)
如果 log(b,a) > d，复杂度为O(N^log(b,a))
如果 log(b,a) == d，复杂度为O(N^d  * logN)

该公式只适用子过程的调用都是数据规模相同的情况，如这个例子中两个子过程的数据规模都是T(N/2)。如果一个递归过程有多个子过程数据规模不一样，那么它不能用该公式进行时间复杂度的计算。



## 暴力递归
1. 汉诺塔问题 2^N - 1 
递归方法
LeetCodeCN_0806_HanotaLcci.java

[TODO]非递归方法

2. 逆序一个栈（不申请额外的空间）

3. 打印所有子序列
    - 重复
    - 不重复
Code_0053_PrintAllSubSequence.java


4. 打印字符串的全部排列
LeetCode_0046_Permutations
LeetCode_0047_PermutationsII
    - 重复 
    - 不重复

### 从左往右的尝试模型 

规定1和A对应、2和B对应、3和C对应... 那么一个数字字符串比如"111"就可以转化为: "AAA"、"KA"和"AK"
给定一个只有数字字符组成的字符串str，
返回有多少种转化结果
LeetCode_0091_DecodeWays.java

[背包问题]
给定两个长度都为N的数组weights和values，
 weights[i]和values[i]分别代表 i号物品的重量和价值。
 给定一个正数bag，表示一个载重bag的袋子，
 你装的物品不能超过这个重量。 返回你能装下最多的价值是多少?
 NowCoder_Knapsack.java

[TODO] 相关的背包问题
416 分割等和子集（medium）
494 目标和（medium）
474 一和零（medium）
322 零钱兑换（medium）
518 零钱兑换 II（medium）
139 单词拆分（medium）
377 组合总和 Ⅳ（medium）


### 范围上尝试的模型
arr[L...R] 规模缩小 
给定一个整型数组arr，代表数值不同的纸牌排成一条线，
玩家A和玩家B依次拿走每张纸牌，
规定玩家A先拿，玩家B后拿，
但是每个玩家每次只能拿走最左或最右的纸牌，
玩家A和玩家B都绝顶聪明。请返回最后获胜者的分数。
Code_0054_CardsInLine
[TODO]NowCoder_CardsInLine

给定一个只由 0(假)、1(真)、&(逻辑与)、|(逻辑或)和^(异或)五种字符组成 的字符串express，再给定一个布尔值 desired。返回express能有多少种组合 方式，可以达到desired的结果。
【举例】
express="1^0|0|1"，desired=false
只有 1^((0|0)|1)和 1^(0|(0|1))的组合可以得到 false，返回 2。 express="1"，desired=false
无组合可以得到false，返回0
tips:
范围上尝试的模型
f(L,R,期待)
优化：
两张二维表 T表，F表
NowCoder_ExpressToDesired.java

[TODO]
范围上的尝试模型
给定一个字符串，如果能在任意位置添加字符，最少添加几个能让字符串整体都是回文串。
tips:
int f(L..R)
LeetCode_1312_MinimumInsertionStepsToMakeAStringPalindrome.java
进阶：可以通过dp表反推出所有决策结果



### 多样本位置全对应的尝试模型
一个样本做行，一个样本做列
两个字符串的最长公共子序列
LeetCode_1143_LongestCommonSubsequence

str1做行，str2做列
```dp[i][j] -> str1[0...i] str2[0..j]`` 最长公共子序列大小 -> ```dp[M][N]``` 就是我们要求的值
填第一行，第一列

普遍位置
```dp[i][j]``` 
既不以str1的i字符结尾，也不以str2的j字符结尾 ```dp[i][j] = dp[i-1][j-1]```
以str1的i字符结尾，不以str2的j字符结尾   ```dp[i][j] = dp[i][j-1]```
不以str1的i字符结尾，以str2的j字符结尾 ```dp[i][j] = dp[i-1][j]```
既以str1的i字符结尾，也以str2的j字符结尾 ```dp[i][j] = dp[i-1][j-1] + 1```



### 寻找业务限制的尝试模型
洗咖啡杯问题
给定一个数组，代表每个人喝完咖啡准备刷杯子的时间
只有一台咖啡机，一次只能洗一个杯子，时间耗费a，洗完才能洗下一杯
每个咖啡杯也可以自己挥发干净，时间耗费b，咖啡杯可以并行挥发
返回让所有咖啡杯变干净的最早完成时间
三个参数：int[] arr、int a、int b
Code_0055_WashCoffee.java

---
人过河问题，鱼吃人以后，会被其他鱼吃掉
【鱼是奇数的时候，吃，偶数的时候，不能吃】

 ABCDE海盗分硬币问题
 超过一半的同意才能通过
 未被通过的会被杀死
 人性本恶
 人性本善（利益受损才投死对方）
 刚好一半

 寄信问题（欧拉信封）
 每个人只能寄一封信，只收一封信
 f(5) = 4 * (f(3) + f(4))

 f(i) = (i-1)*(f(i-1) + f(i-2))
 f(1) = 0
 f(2) = 1
 f(3) = 2

N皇后问题
在N*N的棋盘上要摆N个皇后，
要求任何两个皇后不同行、不同列，
也不在同一条斜线上 给定一个整数n，返回n皇后的摆法有多少种。
n=1，返回1 n=2或3，2皇后和3皇后问题无论怎么摆都不行，返回0
n=8，返回92
tip: 最右侧的1取出来
每一行放一个，放在一个结构(int[] records)里面(records[i] = j , i行j位置放了一个皇后)，接下来只要规避不同列和不同斜线
如果试到某一步后不能处理，则返回上一层再处理
位运算进行常数项优化！
列限制，左斜线限制，右斜线限制 这三个变量或运算以后，1位置不能放皇后
[TODO]NowCoder_NQueens.java

## 暴力递归到动态规划
所有的暴力过程，都是由于有重复计算（比如斐波那契数列问题）

题目一
假设有排成一行的N个位置，记为1~N，
N 一定大于或等于 2 开始时机器人在其中的M位置上(M 一定是 1~N 中的一个)
如果机器人来到1位置，那么下一步只能往右来到2位置；
如果机器人来到N位置，那么下一步只能往左来到 N-1 位置；
如果机器人来到中间位置，那么下一步可以往左走或者往右走；
规定机器人必须走 K 步，
最终能来到P位置(P也是1~N中的一个)的方法有多少种 给定四个参数 N、M、K、P，返回方法数。
NowCoder_RobotWalk.java

记忆化搜索

背包问题改动态规划

LeetCode_0091_DecodeWays 改动态规划


背包容量为w
NowCoder_Bag.java 
一共有n袋零食, 第i袋零食体积为v[i] 
总体积不超过背包容量的情况下，
一共有多少种零食放法？(总体积为0也算一种放法)。



拿纸牌问题改动态规划

动态规划进一步优化（枚举行为） CoinWays

[TODO] 马跳步问题 Code_0057_HorseJump.java

贴纸问题 无法进一步优化

动态规划的进一步优化主要是为了省略枚举行为
0）观察临近格子法
1）空间压缩
2）状态化简
3）[四边形不等式](四边形不等式.md)


给定一个二维数组matrix，其中每个数都是正数，要求从左上到右下
   每一步只能向右或者向下，沿途经过的数字要累加起来
   最后请返回最小的路径和
LeetCodeCN_0047_MaxValue.java --> 可以做空间压缩



最长公共子串问题（空间压缩极致用法，二维的非最优解，最优解来自后缀数组）
LintCode_0079_LongestCommonSubstring.java
tips:
动态规划的空间压缩技巧！