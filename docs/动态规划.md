# 动态规划

## 认识递归

### 汉诺塔问题

LeetCodeCN_0806_HanotaLcci.java

NowCoder_HanotaII.java

[汉诺塔问题](https://www.cnblogs.com/greyzeng/p/14418802.html)

### 逆序一个栈（不申请额外的空间）

NowCoder_ReverseStack.java

### 打印所有子序列

LeetCode_0078_Subsets.java

LeetCode_0090_SubsetsII.java

### 打印字符串的全部排列

> 可以使用递归和非递归两种方式实现

LeetCode_0046_Permutations.java

LeetCode_0047_PermutationsII.java

## 范围上尝试的模型

> `arr[L...R]` 规模缩小

### 机器人达到指定位置方法数

> 使用压缩数组技巧

NowCoder_RobotWalk.java

### 纸牌博弈问题

NowCoder_Cards.java

## 从左往右的尝试模型

### 背包问题I && 背包问题II

LintCode_0092_Backpack.java

LintCode_0125_BackpackII.java

### 解码问题

LeetCode_0091_DecodeWays.java

### 贴纸拼词

LeetCode_0691_StickersToSpellWord.java

## 多样本位置全对应的尝试模型

> 常用解法：一个样本做行，一个样本做列

### 两个字符串的最长公共子序列

LeetCode_1143_LongestCommonSubsequence.java

### 马跳步问题

> 三维可变参数

NowCoder_HorseJump.java

## 范围上的尝试模型

### 求最长回文子序列长度

方式1：一个串和它的逆序串的最大公共子序列就是这个串的最长回文子序列

方式2：范围尝试

LeetCode_0516_LongestPalindromicSubsequence.java

## 寻找业务限制的尝试模型

### 洗咖啡杯问题

Code_0085_Coffee.java

## 空间压缩技巧

### 二维数组matrix的最小路径和(最大路径和类似)

LintCode_0110_MinimumPathSum.java

## 从左往右的尝试模型

### arr是货币数组，其中的值都是正数。再给定一个正数aim, 每个值都认为是一张货币，即便是值相同的货币也认为每一张都是不同的，返回组成aim的方法数

> 例如：arr = {1,1,1}，aim = 2 , 第0个和第1个能组成2，第1个和第2个能组成2，第0个和第2个能组成2 , 一共就3种方法，所以返回3

Code_0004_CoinsWayEveryPaperDifferent.java

### arr是货币数组，其中的值都是正数。再给定一个正数aim。每个值都认为是一张货币，认为值相同的货币没有任何不同，返回组成aim的方法数

> 例如：arr = {1,2,1,1,2,1,2}，aim = 4 方法：1+1+1+1、1+1+2、2+2 一共就3种方法，所以返回3

Code_0052_CoinsWaySameValueSamePaper.java

### Bob存活概率

Code_0054_BobDie.java

### 打怪兽问题

Code_0082_KillMonster.java

### arr是面值数组，其中的值都是正数且没有重复。再给定一个正数aim，每个值都认为是一种面值，且认为张数是无限的。返回组成aim的方法数

> 例如：arr = {1,2}，aim = 4 方法如下：1+1+1+1、1+1+2、2+2 一共就3种方法，所以返回3

Code_0025_CoinsWayNoLimit.java

### 裂开的方案数(优化枚举行为)

Code_0044_SplitNum.java

### 分成两个最接近集合问题(背包问题) && 分成两个最接近集合问题II

Code_0083_SplitSumClosed.java

Code_0084_SplitSumClosedSizeHalf.java

### N皇后问题

Code_0086_NQueens.java O(N^N)

### 最长递增链问题

> 给定一个二维数组matrix，可以从任何位置出发，每一步可以走向上、下、左、右，四个方向。返回最大递增链的长度。
> 本题只需要到记忆化搜索优化技巧即可。

LeetCode_0329_LongestIncreasingPathInAMatrix.java

### 目标和问题

LeetCode_0494_TargetSum.java

### 动态规划猜法中和外部信息简化的相关

-----

## 范围上的尝试模型

### 最少添加多少个字符变成回文

LeetCode_1312_MinimumInsertionStepsToMakeAStringPalindrome.java

进阶：*可以通过dp表反推出所有决策结果*

## 寻找业务限制的尝试模型

### 零钱兑换系列问题

#### 硬币数量是无限的，计算并返回可以凑成总金额所需的最少的硬币个数, 如果没有任何一种硬币组合能组成总金额，返回-1

LeetCode_0322_CoinChange.java

## TODO

## 多样本位置全对应的尝试模型3


[TODO] 相关的背包问题 416 分割等和子集（medium） 494 目标和（medium） 474 一和零（medium） 322 零钱兑换（medium） 518 零钱兑换 II（medium） 139 单词拆分（medium）
377 组合总和 Ⅳ（medium）

## 范围上尝试的模型2

给定一个只由 0(假)、1(真)、&(逻辑与)、|(逻辑或)和^(异或)五种字符组成 的字符串express，再给定一个布尔值 desired。返回express能有多少种组合 方式，可以达到desired的结果。 【举例】
express="1^0|0|1"，desired=false 只有 1^((0|0)|1)和 1^(0|(0|1))的组合可以得到 false，返回 2。 express="1"，desired=false
无组合可以得到false，返回0 tips:
范围上尝试的模型 f(L,R,期待)
优化： 两张二维表 T表，F表 NowCoder_ExpressToDesired.java

现有n1+n2种面值的硬币，其中前n1种为普通币，可以取任意枚，后n2种为纪念币， 每种最多只能取一枚(可能有重复值)，每种硬币有一个面值，问能用多少种方法拼出m的面值? NowCoder_CoinWays.java

tips:
两个动态规划 普通 + 钱数 i,j 可以斜率优化 --> 只需要最后一行的数据 纪念 + 钱数 i,j 经典背包问题 -->
假设是10元 普通 0 纪念 10 普通 1 纪念 9 ... 普通 10 纪念 0

## 多样本位置全对应的尝试模型2

一个样本做行 一个样本做列 NowCoder_TwoSortedArraySumTopK.java 给定两个有序数组arr1和arr2，再给定一个正数K 求两个数累加和最大的前K个，两个数必须分别来自arr1和arr2 tips:
大根堆 sum来组织 右下角最大，先进大根堆，然后弹出，左边和上面的依次加入 不要重复加入 O(K*logK)

## 寻找业务限制的尝试模型2

人过河问题，鱼吃人以后，会被其他鱼吃掉 【鱼是奇数的时候，吃，偶数的时候，不能吃】

ABCDE海盗分硬币问题 超过一半的同意才能通过 未被通过的会被杀死 人性本恶 人性本善（利益受损才投死对方） 刚好一半

寄信问题（欧拉信封） 每个人只能寄一封信，只收一封信 f(5) = 4 * (f(3) + f(4))

f(i) = (i-1)*(f(i-1) + f(i-2))
f(1) = 0 f(2) = 1 f(3) = 2

## 暴力递归到动态规划

所有的暴力过程，都是由于有重复计算（比如斐波那契数列问题）

拿纸牌问题改动态规划

动态规划进一步优化（枚举行为） CoinWays

动态规划的进一步优化主要是为了省略枚举行为 0）观察临近格子法 1）空间压缩 2）状态化简 3）四边形不等式

最长公共子串问题（空间压缩极致用法，二维的非最优解，最优解来自后缀数组） LintCode_0079_LongestCommonSubstring.java tips:
动态规划的空间压缩技巧！

范围上的尝试模型 + 从左到右的尝试模型 str中，至少切几刀，保证每个部分都是回文串 LeetCode_0132_PalindromePartitioningII

tips:
从左往右的尝试 f(str,i), 从i到后面，最多能且切多少个回文串 范围上的尝试 ```dp[i][j]``` 是否是回文 对角线是TRUE， 普遍位置：```i == j && dp[i+1][j-1]```


## 重建二叉树 动态规划

- LeetCode_0106_ConstructBinaryTreeFromInorderAndPostorderTraversal.java
- LeetCode_0105_ConstructBinaryTreeFromPreorderAndInorderTraversal.java

## 放灯问题

- NowCoder_Light.java

### 数组中最小不可组成和

> 给定一个正数数组 arr，其中所有的值都为整数，以下是最小不可组成和的概念：
>
> 把 arr 每个子集内的所有元素加起来会出现很多值，其中最小的记为 min，最大的记为max ，在区间[min,max]上，如果有数不可以被arr某一个子集相加到，那么其中最小的那个数是arr 的最小不可组成和。
>
> 在区间[min,max]上，如果所有的数都可以被arr的某一个子集相加得到，那么max+1是arr的最小不可组成和，请实现一个函数，返回正数数组 arr 的最小不可组成和。
>
> 举例：
>
> arr=[3,2,5]。子集{2}相加产生 2 为 min，子集{3,2,5}相加产生 10 为 max。在区间[2,10] 上，4、 6 和 9 不能被任何子集相加得到，其中 4 是 arr 的最小不可组成和。
>
> arr=[1,2,4]。子集{1}相加产生 1 为 min，子集{1,2,4}相加产生 7 为 max。在区间[1,7]上， 任何 数都可以被子集相加得到，所以 8 是 arr 的最小不可组成和。

tips：

```text
dp[i][j]0..i位置能否组成j
```

Code: NowCoder_FirstUnFormedNum.java

进阶

> 如果已知正数数组 arr 中肯定有 1 这个数，是否能更快地得到最小不可组成和?

Code: NowCoder_FirstUnFormedNumPro.java

tips:
先排序 range = 1 1 ~ range所有的数都可以加出来 i位置的数是a a > range + 1 --> return range + 1 a <= range + 1 --> range = range + a
如果都满足，return range + 1

### 数位dp问题

给定一个正数N，表示你在纸上写下1~N所有的数字，返回在书写的过程中，一共写下了多少个1 LeetCode_0233_NumberOfDigitOne.java

tips:
打表法不行

数位dp的问题 最高位是1 不是1 最高位开始有几个1 其次高位置上有几个1

f(13625) -> 3626 ~ f(3625)
N = 1到k位 最高位是1 N%10^(k-1) + 1

10^(k-2) * (k - 1)

最高位不是1 10^(k-1) + 10^(k-2) *a* (k - 1)

复杂度 O(log10(N) * log10(N))

给定一个字符类型的二维数组board，和一个字符串组成的列表words。 可以从board任何位置出发，每一步可以走向上、下、左、右，四个方向， 但是一条路径已经走过的位置，不能重复走。 返回words哪些单词可以被走出来。 例子
board = [
['o','a','a','n'],
['e','t','a','e'],
['i','h','k','r'],
['i','f','l','v']
]
words = ["oath","pea","eat","rain"]
输出：["eat","oath"]

LeetCode_0212_WordSearchII tips:

0. 把words做成前缀树，加速
1. 不能重复走，置为0，然后要恢复现场
2. 深度优先

给定两个字符串S和T，返回S子序列等于T的不同子序列个数有多少个? 如果得到子序列A删除的位置与得到子序列B删除的位置不同，那么认为A和B就是不同的。 【例子】 S = "rabbbit", T = "rabbit"
返回: 3 是以下三个S的不同子序列，没有^的位置表示删除的位置，因为删除的位置不同，所以这三 个子序列是不一样的 rabbbit II IIII rabbbit III III rabbbit IIII II

LeetCode_0115_DistinctSubsequences.java tips:
样本做行 样本做列
```dp[i][j]``` : 表示s[0..i] 任意删除的方案，能组成 T[0..j] 这个前缀字符串

给定一个二维数组 map，含义是一张地图，例如，如下矩阵:
-2 -3 3 -5 -10 1 0 30 -5 游戏的规则如下:
骑士从左上角出发，每次只能向右或向下走，最后到达右下角见到公主。 地图中每个位置的值代表骑士要遭遇的事情。 如果是负数，说明此处有怪兽，要让骑士损失血量。 如果是非负数，代表此处有血瓶，能让骑士回血。
骑士从左上角到右下角的过程中，走到任何一个位置时，血量都不能少于1。 为了保证骑士能见到公主，初始血量至少是多少?根据map，返回至少的初始血量。 LeetCode_0174_DungeonGame.java

三维dp 给定一个矩阵matrix，先从左上角开始，每一步只能往右或者往下走，走到右下角。然后从右下角出发，每一步只能往上或者往左走，再回到左上角。任何一个位置的数字，只能获得一遍。返回最大路径和。
NowCoder_MatrixMaxPath LeetCode_0741_CherryPickup tips:
设置两个小人，走到同一位置的时候，只算一份，路径和，就是来回的最大路径和

业务限制的模型 Code_0036_Coffee.java arr中记录咖啡机制造一杯咖啡的时间，假设有m个人，都在0号时间点开始排队，返回一个数组 最后一个得到咖啡的人的时间尽可能短 tips:
小根堆 时间点+制造咖啡的时间 弹出，制造，修改咖啡机的开始时间，再加入小根堆

对于一个字符串, 从前开始读和从后开始读是一样的, 我们就称这个字符串是回文串。例如"ABCBA","AA", "A" 是回文串, 而"ABCD", "AAB"不是回文串。 牛牛特别喜欢回文串, 他手中有一个字符串s,
牛牛在思考能否从字符串中移除部分(0个或多个)字符使其变为回文串， 并且牛牛认为空串不是回文串。牛牛发现移除的方案可能有 很多种, 希望你来帮他计算一下一共有多少种移除方案可以使s变为回文串。 对于两种移除方案, 如果移除的字
符依次构成的序列不一样就是不同的方案。 例如，XXY 4种 ABA 5种 【说明】 这是今年的原题，提供的说明和例子都很让人费解。现在根据当时题目的所有测试用例，重新解释当时的题目 含义:
1)"1AB23CD21"，你可以选择删除A、B、C、D，然后剩下子序列{1,2,3,2,1}，只要剩下的子序列是同一个，那 么就只算1种方法，和A、B、C、D选择什么样的删除顺序没有关系。 2)"121A1"
，其中有两个{1,2,1}的子序列，第一个{1,2,1}是由{位置0，位置1，位置2}构成，第二个{1,2,1} 是由{位置0，位置1，位置4}构成。这两个子序列被认为是不同的子序列。也就是说在本题中，认为字面值一样
但是位置不同的字符就是不同的。 3)其实这道题是想求，str中有多少个不同的子序列，每一种子序列只对应一种删除方法，那就是把多余的东西去掉，而和去掉的顺序无关。 4)也许你觉得我的解释很荒谬，但真的是这样，不然解释不了为什么，XXY 4种
ABA 5种，而且其他的测试用例都印证了这一点。 NowCoder_PWays.java

tips:

范围模型 L x R x a L v R x b L x R v c L v R v d

```dp[L][R]```

```dp[L+1][R] = a + c```
```dp[L][R-1] = a + b```

加工 a + b + c d = a + 1  (考虑空串，所以要加1)

判定一个由[a-z]字符构成的字符串和一个包含'.'和'*'通配符的字符串是否匹配。 通配符'.'匹配任意单一字符,
'*'匹配前一个字符的任意多个字符(包括0个字符)。 字符串长度不会超过100，字符串不为空。 LeetCode_0010_RegularExpressionMatching.java 输入描述:
字符串 str 和包含通配符的字符串 pattern。1 <= 字符串长度 <= 100输出描述: true 表示匹配，false 表示不匹配 tips:
一个样本做行，一个样本做列尝试模型 f(si,ei)  -> si... 能否 匹配 ei... 有效性检查 可以改动态规划，但是没办法做斜率优化

给定一个数组 arr，代表一排有分数的气球。每打爆一个气球都能获得分数，假设打爆气 球 的分数为 X，获得分数的规则如下:
1)如果被打爆气球的左边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 L;如果被打爆气球的右边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 R。 获得分数为 L*X*R。 2)
如果被打爆气球的左边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 L;如果被打爆气球的右边所有气球都已经被打爆。获得分数为 L*X。 3)如果被打爆气球的左边所有的气球都已经被打爆;如果被打爆气球的右边有没被打爆的
气球，找到离被打爆气球最近的气球，假设分数为 R;如果被打爆气球的右边所有气球都 已经 被打爆。获得分数为 X*R。 4)如果被打爆气球的左边和右边所有的气球都已经被打爆。获得分数为 X。
目标是打爆所有气球，获得每次打爆的分数。通过选择打爆气球的顺序，可以得到不同的总分，请返回能获得的最大分数。 LeetCode_0312_BurstBalloons 【举例】 arr = {3,2,5} 如果先打爆3，获得3*
2;再打爆2，获得2*5;最后打爆5，获得5;最后总分21 如果先打爆3，获得3*2;再打爆5，获得2*5;最后打爆2，获得2;最后总分18 如果先打爆2，获得3*2*5;再打爆3，获得3*5;最后打爆5，获得5;最后总分50
如果先打爆2，获得3*2*5;再打爆5，获得3*5;最后打爆3，获得3;最后总分48 如果先打爆5，获得2*5;再打爆3，获得3*2;最后打爆2，获得2;最后总分18 如果先打爆5，获得2*5;再打爆2，获得3*
2;最后打爆3，获得3;最后总分19 返回能获得的最大分数为50

tips:

[3,2,5] -> [1,3,2,5,1]
f(1,3) -> 0位置和4位置永远不爆

## 二维数组matrix的最大/最小路径和 上下左右四个方向都可以

[TODO]LintCode_1582_MinimumPathSumII.java

## 纸牌排列数问题

根据数据量猜解法
[TODO] Code_0019_CardsProblem.java
