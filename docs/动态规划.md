# 动态规划

## 认识递归

### 汉诺塔问题

LeetCodeCN_0806_HanotaLcci.java

NowCoder_HanotaII.java

[汉诺塔问题](https://www.cnblogs.com/greyzeng/p/14418802.html)

### 逆序一个栈（不申请额外的空间）

NowCoder_ReverseStack.java

### 打印所有子序列

LeetCode_0078_Subsets.java

LeetCode_0090_SubsetsII.java

### 打印字符串的全部排列

> 可以使用递归和非递归两种方式实现

LeetCode_0046_Permutations.java

LeetCode_0047_PermutationsII.java

## 范围上尝试的模型

> `arr[L...R]` 规模缩小

### 机器人达到指定位置方法数

> 使用压缩数组技巧

NowCoder_RobotWalk.java

### 纸牌博弈问题

NowCoder_Cards.java

## 从左往右的尝试模型

### 背包问题I && 背包问题II

LintCode_0092_Backpack.java

LintCode_0125_BackpackII.java

### 解码问题

LeetCode_0091_DecodeWays.java

### 贴纸拼词

LeetCode_0691_StickersToSpellWord.java

## 多样本位置全对应的尝试模型

> 常用解法：一个样本做行，一个样本做列

### 两个字符串的最长公共子序列

LeetCode_1143_LongestCommonSubsequence.java

### 马跳步问题

> 三维可变参数

NowCoder_HorseJump.java

## 范围上的尝试模型

### 求最长回文子序列长度

方式1：一个串和它的逆序串的最大公共子序列就是这个串的最长回文子序列

方式2：范围尝试

LeetCode_0516_LongestPalindromicSubsequence.java

## 寻找业务限制的尝试模型

### 洗咖啡杯问题

Code_0085_Coffee.java

## 空间压缩技巧

### 二维数组matrix的最小路径和(最大路径和类似)

LintCode_0110_MinimumPathSum.java

## 从左往右的尝试模型

### arr是货币数组，其中的值都是正数。再给定一个正数aim, 每个值都认为是一张货币，即便是值相同的货币也认为每一张都是不同的，返回组成aim的方法数

> 例如：arr = {1,1,1}，aim = 2 , 第0个和第1个能组成2，第1个和第2个能组成2，第0个和第2个能组成2 , 一共就3种方法，所以返回3

Code_0004_CoinsWayEveryPaperDifferent.java

### arr是货币数组，其中的值都是正数。再给定一个正数aim。每个值都认为是一张货币，认为值相同的货币没有任何不同，返回组成aim的方法数

> 例如：arr = {1,2,1,1,2,1,2}，aim = 4 方法：1+1+1+1、1+1+2、2+2 一共就3种方法，所以返回3

Code_0052_CoinsWaySameValueSamePaper.java

### Bob存活概率

Code_0054_BobDie.java

### 打怪兽问题

Code_0082_KillMonster.java

### arr是面值数组，其中的值都是正数且没有重复。再给定一个正数aim，每个值都认为是一种面值，且认为张数是无限的。返回组成aim的方法数

> 例如：arr = {1,2}，aim = 4 方法如下：1+1+1+1、1+1+2、2+2 一共就3种方法，所以返回3

Code_0025_CoinsWayNoLimit.java

### 裂开的方案数(优化枚举行为)

Code_0044_SplitNum.java

### 分成两个最接近集合问题(背包问题) && 分成两个最接近集合问题II

Code_0083_SplitSumClosed.java

Code_0084_SplitSumClosedSizeHalf.java

### N皇后问题

Code_0086_NQueens.java O(N^N)

### 最长递增链问题

> 给定一个二维数组matrix，可以从任何位置出发，每一步可以走向上、下、左、右，四个方向。返回最大递增链的长度。
> 本题只需要到记忆化搜索优化技巧即可。

LeetCode_0329_LongestIncreasingPathInAMatrix.java

### 目标和问题

LeetCode_0494_TargetSum.java

### 动态规划猜法中和外部信息简化的相关

-----



## 寻找业务限制的尝试模型

### 零钱兑换系列问题

#### 硬币数量是无限的，计算并返回可以凑成总金额所需的最少的硬币个数, 如果没有任何一种硬币组合能组成总金额，返回-1

LeetCode_0322_CoinChange.java

## TODO

## 多样本位置全对应的尝试模型3


[TODO] 相关的背包问题 416 分割等和子集（medium） 494 目标和（medium） 474 一和零（medium） 322 零钱兑换（medium） 518 零钱兑换 II（medium） 139 单词拆分（medium）
377 组合总和 Ⅳ（medium）

## 范围上尝试的模型2

给定一个只由 0(假)、1(真)、&(逻辑与)、|(逻辑或)和^(异或)五种字符组成 的字符串express，再给定一个布尔值 desired。返回express能有多少种组合 方式，可以达到desired的结果。 【举例】
express="1^0|0|1"，desired=false 只有 1^((0|0)|1)和 1^(0|(0|1))的组合可以得到 false，返回 2。 express="1"，desired=false
无组合可以得到false，返回0 tips:
范围上尝试的模型 f(L,R,期待)
优化： 两张二维表 T表，F表 NowCoder_ExpressToDesired.java

现有n1+n2种面值的硬币，其中前n1种为普通币，可以取任意枚，后n2种为纪念币， 每种最多只能取一枚(可能有重复值)，每种硬币有一个面值，问能用多少种方法拼出m的面值? NowCoder_CoinWays.java

tips:
两个动态规划 普通 + 钱数 i,j 可以斜率优化 --> 只需要最后一行的数据 纪念 + 钱数 i,j 经典背包问题 -->
假设是10元 普通 0 纪念 10 普通 1 纪念 9 ... 普通 10 纪念 0

## 多样本位置全对应的尝试模型2

一个样本做行 一个样本做列 NowCoder_TwoSortedArraySumTopK.java 给定两个有序数组arr1和arr2，再给定一个正数K 求两个数累加和最大的前K个，两个数必须分别来自arr1和arr2 tips:
大根堆 sum来组织 右下角最大，先进大根堆，然后弹出，左边和上面的依次加入 不要重复加入 O(K*logK)

## 寻找业务限制的尝试模型2

人过河问题，鱼吃人以后，会被其他鱼吃掉 【鱼是奇数的时候，吃，偶数的时候，不能吃】

ABCDE海盗分硬币问题 超过一半的同意才能通过 未被通过的会被杀死 人性本恶 人性本善（利益受损才投死对方） 刚好一半

寄信问题（欧拉信封） 每个人只能寄一封信，只收一封信 f(5) = 4 * (f(3) + f(4))

f(i) = (i-1)*(f(i-1) + f(i-2))
f(1) = 0 f(2) = 1 f(3) = 2

## 暴力递归到动态规划

所有的暴力过程，都是由于有重复计算（比如斐波那契数列问题）

拿纸牌问题改动态规划

动态规划进一步优化（枚举行为） CoinWays

动态规划的进一步优化主要是为了省略枚举行为 0）观察临近格子法 1）空间压缩 2）状态化简 3）四边形不等式

最长公共子串问题（空间压缩极致用法，二维的非最优解，最优解来自后缀数组） LintCode_0079_LongestCommonSubstring.java tips:
动态规划的空间压缩技巧！

## 重建二叉树 动态规划

- LeetCode_0106_ConstructBinaryTreeFromInorderAndPostorderTraversal.java
- LeetCode_0105_ConstructBinaryTreeFromPreorderAndInorderTraversal.java

### 数组中最小不可组成和

> 给定一个正数数组 arr，其中所有的值都为整数，以下是最小不可组成和的概念：
>
> 把 arr 每个子集内的所有元素加起来会出现很多值，其中最小的记为 min，最大的记为max ，在区间[min,max]上，如果有数不可以被arr某一个子集相加到，那么其中最小的那个数是arr 的最小不可组成和。
>
> 在区间[min,max]上，如果所有的数都可以被arr的某一个子集相加得到，那么max+1是arr的最小不可组成和，请实现一个函数，返回正数数组 arr 的最小不可组成和。
>
> 举例：
>
> arr=[3,2,5]。子集{2}相加产生 2 为 min，子集{3,2,5}相加产生 10 为 max。在区间[2,10] 上，4、 6 和 9 不能被任何子集相加得到，其中 4 是 arr 的最小不可组成和。
>
> arr=[1,2,4]。子集{1}相加产生 1 为 min，子集{1,2,4}相加产生 7 为 max。在区间[1,7]上， 任何 数都可以被子集相加得到，所以 8 是 arr 的最小不可组成和。

tips：

```text
dp[i][j]0..i位置能否组成j
```

Code: NowCoder_FirstUnFormedNum.java

进阶

> 如果已知正数数组 arr 中肯定有 1 这个数，是否能更快地得到最小不可组成和?

Code: NowCoder_FirstUnFormedNumPro.java

tips:
先排序 range = 1 1 ~ range所有的数都可以加出来 i位置的数是a a > range + 1 --> return range + 1 a <= range + 1 --> range = range + a
如果都满足，return range + 1

### 数位dp问题

给定一个正数N，表示你在纸上写下1~N所有的数字，返回在书写的过程中，一共写下了多少个1 LeetCode_0233_NumberOfDigitOne.java

tips:
打表法不行

数位dp的问题 最高位是1 不是1 最高位开始有几个1 其次高位置上有几个1

f(13625) -> 3626 ~ f(3625)
N = 1到k位 最高位是1 N%10^(k-1) + 1

10^(k-2) * (k - 1)

最高位不是1 10^(k-1) + 10^(k-2) *a* (k - 1)

复杂度 O(log10(N) * log10(N))

给定两个字符串S和T，返回S子序列等于T的不同子序列个数有多少个? 如果得到子序列A删除的位置与得到子序列B删除的位置不同，那么认为A和B就是不同的。 【例子】 S = "rabbbit", T = "rabbit"
返回: 3 是以下三个S的不同子序列，没有^的位置表示删除的位置，因为删除的位置不同，所以这三 个子序列是不一样的 rabbbit II IIII rabbbit III III rabbbit IIII II

LeetCode_0115_DistinctSubsequences.java tips:
样本做行 样本做列
```dp[i][j]``` : 表示s[0..i] 任意删除的方案，能组成 T[0..j] 这个前缀字符串

给定一个二维数组 map，含义是一张地图，例如，如下矩阵:
-2 -3 3 -5 -10 1 0 30 -5 游戏的规则如下:
骑士从左上角出发，每次只能向右或向下走，最后到达右下角见到公主。 地图中每个位置的值代表骑士要遭遇的事情。 如果是负数，说明此处有怪兽，要让骑士损失血量。 如果是非负数，代表此处有血瓶，能让骑士回血。
骑士从左上角到右下角的过程中，走到任何一个位置时，血量都不能少于1。 为了保证骑士能见到公主，初始血量至少是多少?根据map，返回至少的初始血量。 LeetCode_0174_DungeonGame.java

三维dp 给定一个矩阵matrix，先从左上角开始，每一步只能往右或者往下走，走到右下角。然后从右下角出发，每一步只能往上或者往左走，再回到左上角。任何一个位置的数字，只能获得一遍。返回最大路径和。
NowCoder_MatrixMaxPath LeetCode_0741_CherryPickup tips:
设置两个小人，走到同一位置的时候，只算一份，路径和，就是来回的最大路径和

业务限制的模型 Code_0036_Coffee.java arr中记录咖啡机制造一杯咖啡的时间，假设有m个人，都在0号时间点开始排队，返回一个数组 最后一个得到咖啡的人的时间尽可能短 tips:
小根堆 时间点+制造咖啡的时间 弹出，制造，修改咖啡机的开始时间，再加入小根堆


给定一个数组 arr，代表一排有分数的气球。每打爆一个气球都能获得分数，假设打爆气 球 的分数为 X，获得分数的规则如下:
1)如果被打爆气球的左边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 L;如果被打爆气球的右边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 R。 获得分数为 L*X*R。 2)
如果被打爆气球的左边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 L;如果被打爆气球的右边所有气球都已经被打爆。获得分数为 L*X。 3)如果被打爆气球的左边所有的气球都已经被打爆;如果被打爆气球的右边有没被打爆的
气球，找到离被打爆气球最近的气球，假设分数为 R;如果被打爆气球的右边所有气球都 已经 被打爆。获得分数为 X*R。 4)如果被打爆气球的左边和右边所有的气球都已经被打爆。获得分数为 X。
目标是打爆所有气球，获得每次打爆的分数。通过选择打爆气球的顺序，可以得到不同的总分，请返回能获得的最大分数。 LeetCode_0312_BurstBalloons 【举例】 arr = {3,2,5} 如果先打爆3，获得3*
2;再打爆2，获得2*5;最后打爆5，获得5;最后总分21 如果先打爆3，获得3*2;再打爆5，获得2*5;最后打爆2，获得2;最后总分18 如果先打爆2，获得3*2*5;再打爆3，获得3*5;最后打爆5，获得5;最后总分50
如果先打爆2，获得3*2*5;再打爆5，获得3*5;最后打爆3，获得3;最后总分48 如果先打爆5，获得2*5;再打爆3，获得3*2;最后打爆2，获得2;最后总分18 如果先打爆5，获得2*5;再打爆2，获得3*
2;最后打爆3，获得3;最后总分19 返回能获得的最大分数为50

tips:

[3,2,5] -> [1,3,2,5,1]
f(1,3) -> 0位置和4位置永远不爆

## 二维数组matrix的最大/最小路径和 上下左右四个方向都可以

[TODO]LintCode_1582_MinimumPathSumII.java

## 纸牌排列数问题

根据数据量猜解法
[TODO] Code_0019_CardsProblem.java
