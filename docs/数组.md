[TODO]数组全为正数
 累加和为K的最子数组个数
 LeetCode_0560_SubarraySumEqualsK.java
 

[TODO]
数组全为正数
累加和为K的子数组【无重复】
用动态规划
LeetCode_0039_CombinationSum.java

 数组中有正，负，0
 1. 累加和为K的最长子数组长度
    LintCode_0911_MaximumSizeSubarraySumEqualsK.java
  2. 数组中1和0一样多的子数组最长的长度
     LeetCode_0525_ContiguousArray.java
     
数组中有正，负，0，累加和<=K的最长子数组长度 NowCoder_LessKMaxSubArray.java


给定一个数组arr，再给定一个k值, 返回累加和小于等于k，但是离k最近的子数组累加和
Code_0024_SumLessOrEqualsK
tips:
TreeSet
前缀和 加入有序表
某个位置结尾的情况下，收集一下答案
如果数组全是正数，可以用窗口

类似：
数组三连的第三个O(N*logN)解法
tips: 采用前缀和
[3,-1,6,-4,2,3,4]
help
[3,2,8,4,6,9, ]
help' 维持一个只升不降的数组
[3,3,8,8,8,9,]
二分查找

给定一个二维数组matrix，再给定一个k值
返回累加和小于等于k，但是离k最近的子矩阵累加和
Code_0034_MatrixSumLessOrEqualsK.java
tips:
通过压缩数组来处理

[TODO]
给定一棵二叉树的头节点head，和一个数K

路径的定义: 
可以从任何一个点开始，但是只能往下走，往下可以走到任何节点停止
返回路径累加和为K的所有路径中，最长的路径最多有几个节点？
tips:
累加和为K的最长子数组（数组三连问题）
从头节点到当前节点的前缀和 放在一个map里面，这个map只维持具体的某一条支路
存前缀和最早出现的位置

[TODO] 多种解法
最大累加和
LeetCode_0053_MaximumSubarray.java

有一些排成一行的正方形。每个正方形已经被染成红色或者绿色。现在可以选择任意一个正方形然后用这两种颜色的任意一种进行染色,这个正方形的颜色将 会被覆盖。目标是在完成染色之后,每个红色R都比每个绿色G距离最左侧近。 返回最少需要涂染几个正方形。
如样例所示: s = RGRGR 我们涂染之后变成RRRGG满足要求了,涂染的个数为2,没有比这个更好的涂染方案。
tips
预处理数组
左边R的数量
左边G的数量
NowCoder_RedAndGreen.java


给定一个数组arr长度为N，你可以把任意长度大于0且小于N的前缀作为左部分，剩下的 作为右部分。
NowCoder_MaxGap.java
但是每种划分下都有左部分的最大值和右部分的最大值，请返回最大的， 左部分最大值减去右部分最大值的绝对值。
tips: 
全局的max，0位置的数和N-1位置的数谁小，用max减谁




给定一个有序数组arr，给定一个正数aim
1）返回累加和为aim的，所有不同二元组
// leetcode 类似题目，简单一些，题目中限制了无重复元素
LeetCode_0167_TwoSumII.java
双指针
[L] + [R] > aim
[L] + [R] < aim
[L] + [R] = aim
L - 1 和 L 位置的数不等于的时候 收集答案
2）返回累加和为aim的，所有不同三元组
遍历每个位置，剩余位置 根据 找二元组的算法找出aim — [i] 的所有二元组
LeetCode_0015_3Sum.java



子数组的最大累加和
tips：
cur 依次累加，小于0则重置为0
max，cur和max比较，可以更新则更新max
证明：假设答案法
i...j 是最大累加和 且最长
[i...k]的前缀和>=0
[k.. i-1]的累加和一定< 0

LeetCode_0053_MaximumSubarray.java


子矩阵的最大累加和(就相当于求长方形的数量)
NowCoder_MaxSumSquare.java
必须含有
0行且只含有0行
0-1行且只含有0-1行
0-2行且只含有0-2行
...
1 行 且只含有1行
...

转换成子数组累加和最大

压缩数组技巧
O(N^2 * M) --> 考虑一下N和M的长度


在一个字符串中找到没有重复字符子串中最长的长度。
LeetCode_0003_LongestSubstringWithoutRepeatingCharacters.java
例如:
abcabcbb没有重复字符的最长子串是abc，长度为3
bbbbb，答案是b，长度为1
pwwkew，答案是wke，长度是3
要求:答案必须是子串，"pwke" 是一个子字符序列但不是一个子字符串。

tips：
必须以i位置结尾的情况下答案是多少
预处理数组：上次i位置出现的位置 用map
还依赖dp[i-1]的值




给定一个无序数组arr，如果只能再一个子数组上排序
返回如果让arr整体有序，需要排序的最短子数组长度
NowCoder_MinSubArrayNeedSort.java
tips:
从左往右遍历i，i左边最大值maxleft maxleft <= a[i] v   maxleft > a[i] x
从右往左遍历i，i右边最大值minright minleft >= a[i] v   minleft < a[i] x




在一个字符串中找到没有重复字符子串中最长的长度。
LeetCode_0003_LongestSubstringWithoutRepeatingCharacters.java
例如:
abcabcbb没有重复字符的最长子串是abc，长度为3
bbbbb，答案是b，长度为1
pwwkew，答案是wke，长度是3
要求:答案必须是子串，"pwke" 是一个子字符序列但不是一个子字符串。

tips：
必须以i位置结尾的情况下答案是多少
预处理数组：上次i位置出现的位置 用map 如果限制了是小写字母，可以用数组替代
还依赖dp[i-1]的值



给定一个全是小写字母的字符串str，删除多余字符，使得每种字符只保留一个，并让 最终结果字符串的字典序最小
【举例】
str = "acbc"，删掉第一个'c'，得到"abc"，是所有结果字符串中字典序最小的。
str = "dbcacbca"，删掉第一个'b'、第一个'c'、第二个'c'、第二个'a'，得到"dabc"， 是所有结 果字符串中字典序最小的。
LeetCode_0316_RemoveDuplicateLetters.java
tips:
建立词频表，建立L和R指针，然后慢慢删除，当一个位置的词频删除到0的时候，L...R这段中要选出第一个符合的位置（ASCII码最小的那个）
删除数据可以转换为需要挑出的数据

O(K*N)



给定一个正整数M，请构造出一个长度为M的数组arr，要求
对任意的i、j、k三个位置，如果i<j<k，都有arr[i] + arr[k] != 2*arr[j]
返回构造出的arr
Code_0010_RandomArray.java
tips:
长度为1，满足
假设 a + b != 2*c
-> 2 * a - 1 + 2 * b - 1 != 2 * c - 1
2 * a + 2 * b != 2 * c

[a,b,c]
->[2 * a - 1, 2 * b - 1, 2 * c - 1, 2 * a, 2 * b, 2 * c]

[1,5,3]
->[1,9,5,2,10,6]

长度为M，只需要一个(M + 1)/2长度的种子

复杂度估计
T(N) = T(N/2) + O(N)

空间复杂度可以做到O(1)


有n个打包机器从左到右一字排开，上方有一个自动装置会抓取一批放物品到每个打包机上，放到每个机器上的这些物品数量有多有少，
由于物品数量不相同，需要工人 将每个机器上的物品进行移动从而到达物品数量相等才能打包。
每个物品重量太大、 每次只能搬一个物品进行移动，为了省力，只在相邻的机器上移动。请计算在搬动最小轮数的前提下，使每个机器上的物品数量相等。
如果不能使每个机器上的物品相同， 返回-1。
例如[1,0,5]表示有3个机器，每个机器上分别有1、0、5个物品，经过这些轮后:
第一轮:1    0 <- 5 => 1 1 4
第二轮:1 <- 1 <- 4 => 2 1 3
第三轮:2    1 <- 3 => 2 2 2
移动了3轮，每个机器上的物品相等，所以返回3
例如[2,2,3]表示有3个机器，每个机器上分别有2、2、3个物品， 这些物品不管怎么移动，都不能使三个机器上物品数量相等，返回-1

Code_0014_PartionPackage.java

tips:
所有数的累加和 % N != 0, 怎么都无法做到

考虑i位置，
左有 ，左余
右有，右余
预处理数组，累加和


给定一个有序的正数数组arr和一个正数range，如果可以自由选择arr中的数字，想累加得 到 1~range 范围上所有的数，返回arr最少还缺几个数。
NowCoder_MissingNum.java
【举例】
arr = {1,2,3,7}，range = 15
想累加得到 1~15 范围上所有的数，arr 还缺 14 这个数，所以返回1
arr = {1,5,7}，range = 15
想累加得到 1~15 范围上所有的数，arr 还缺 2 和 4，所以返回2
tips:
先排序



[TODO]
最长递增子序列问题的O(N*logN)解法

- 这里的递增指的是严格递增（相等都不算）
- 暴力解是 O(N^2)

经典解法：
- ends数组，ends[i] 找到的所有长度为i+1的递增子序列中最小结尾是什么
- dp[i]数组, 必须以i结尾的，最长递增子序列有多长

tips:
dp数组和ends数组配合

ends数组：找到的所有长度为i+1的递增子序列中最小结尾是啥
ends的有效区必须有序[需要证明]
任何一个当前数，
去有效区找大于等于cur的最左边的位置，
找到，填进去，然后看下这个位置包括自己在内左边一共有几个数，就是cur此时的dp值
没有找到，扩充有效区，一直到把所有dp都生成


嵌套信封问题的原型就是最长递增子序列
一维从小到大，二维从大到小，二维数据拿出来，最长递增子序列就是嵌套层数

二维穿过点最多的曲线问题

相关习题：

Code_0021_LIS.java
LeetCode_0300_LongestIncreasingSubsequence.java
LeetCode_0334_IncreasingTripletSubsequence.java
LeetCode_0354_RussianDollEnvelopes.java

给定一个正数数组arr，返回该数组能不能分成4个部分，并且每个部分的累加和相等，切分位置的数不要。
Code_0020_Split4Parts.java
例如:
arr=[3, 2, 4, 1, 4, 9, 5, 10, 1, 2, 2] 返回true
三个切割点下标为2, 5, 7. 切出的四个子数组为[3,2], [1,4], [5], [1,2,2]，
累加和都是5

tips:
数组长度一定要大于7
前缀和加入map中
第一刀 1 .... N - 6
第一刀确定后，第二刀的位置


先给出可整合数组的定义:如果一个数组在排序之后，每相邻两个数差的绝对值 都为 1， 则该数组为可整合数组。
例如，[5,3,4,6,2]排序之后为[2,3,4,5,6]， 符合每相邻两个数差的绝对值 都为 1，所以这个数组为可整合数组。
给定一个整型数组 arr，请返回其中最大可整合子数组的长度。例如， [5,5,3,2,6,4,3]的最大 可整合子数组为[5,3,2,6,4]，所以返回 5。
NowCoder_MaxUnionArray
tips:
hashset, 最大-最小 和 个数之间的关系



给定一个数组arr，如果有某个数出现次数超过了数组长度的一半，打印这个数，如果没有不打印
LeetCode_0169_MajorityElement.java
tips:
每次删掉两个不同的数，这个数最后会剩下来，

[TODO]
扩展：投票问题

给定一个数组arr和整数k，arr长度为N，如果有某些数出现次数超过了N/K，打印这些数，如果没有不打印
NowCoder_FindKMajor.java
tips:
最多只有k-1个候选
一次删掉k个不同的数