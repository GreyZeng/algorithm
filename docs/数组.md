##
 [TODO]数组全为正数
 累加和为K的最子数组个数
 LeetCode_0560_SubarraySumEqualsK.java
 

[TODO]
数组全为正数
累加和为K的子数组【无重复】
用动态规划
LeetCode_0039_CombinationSum.java
https://www.nowcoder.com/practice/75e6cd5b85ab41c6a7c43359a74e869a?tpId=117&&tqId=34967&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking

 数组中有正，负，0
 1. 累加和为K的最长子数组长度
    LintCode_0911_MaximumSizeSubarraySumEqualsK.java
  2. 数组中1和0一样多的子数组最长的长度
     LeetCode_0525_ContiguousArray.java


 
 数组中有正，负，0
 累加和<=K的最长子数组长度
 NowCoder_LessKMaxSubArray.java

[TODO] 多种解法
最大累加和
LeetCode_0053_MaximumSubarray.java



有一些排成一行的正方形。每个正方形已经被染成红色或者绿色。现在可以选择任意一个正方形然后用这两种颜色的任意一种进行染色,这个正方形的颜色将 会被覆盖。目标是在完成染色之后,每个红色R都比每个绿色G距离最左侧近。 返回最少需要涂染几个正方形。
如样例所示: s = RGRGR 我们涂染之后变成RRRGG满足要求了,涂染的个数为2,没有比这个更好的涂染方案。
tips
预处理数组
左边R的数量
左边G的数量
NowCoder_RedAndGreen.java


给定一个数组arr长度为N，你可以把任意长度大于0且小于N的前缀作为左部分，剩下的 作为右部分。

但是每种划分下都有左部分的最大值和右部分的最大值，请返回最大的， 左部分最大值减去右部分最大值的绝对值。
tips: 
全局的max，0位置的数和N-1位置的数谁小，用max减谁
NowCoder_MaxGap.java



给定一个有序数组arr，给定一个正数aim
1）返回累加和为aim的，所有不同二元组
// leetcode 类似题目，简单一些，题目中限制了无重复元素
LeetCode_0167_TwoSumII.java
双指针
[L] + [R] > aim
[L] + [R] < aim
[L] + [R] = aim
L - 1 和 L 位置的数不等于的时候 收集答案
2）返回累加和为aim的，所有不同三元组
遍历每个位置，剩余位置 根据 找二元组的算法找出aim — [i] 的所有二元组
LeetCode_0015_3Sum.java



子数组的最大累加和
tips：
cur 依次累加，小于0则重置为0
max，cur和max比较，可以更新则更新max
证明：假设答案法
i...j 是最大累加和 且最长
[i...k]的前缀和>=0
[k.. i-1]的累加和一定< 0

LeetCode_0053_MaximumSubarray.java


子矩阵的最大累加和(就相当于求长方形的数量)
NowCoder_MaxSumSquare.java
必须含有
0行且只含有0行
0 ~ 1行且只含有0 ~ 1行
0 ~ 2行且只含有0 ~ 2行
...
1 行 且只含有1行
...

转换成子数组累加和最大

压缩数组技巧
O(N^2 * M) --> 考虑一下N和M的长度


在一个字符串中找到没有重复字符子串中最长的长度。
LeetCode_0003_LongestSubstringWithoutRepeatingCharacters.java
例如:
abcabcbb没有重复字符的最长子串是abc，长度为3
bbbbb，答案是b，长度为1
pwwkew，答案是wke，长度是3
要求:答案必须是子串，"pwke" 是一个子字符序列但不是一个子字符串。

tips：
必须以i位置结尾的情况下答案是多少
预处理数组：上次i位置出现的位置 用map
还依赖dp[i-1]的值
