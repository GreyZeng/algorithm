# 图

## 邻接矩阵，邻接表

> 自定义图结构，以后的题目转换成自己熟悉的图结构

## DFS

Code_0051_DFS.java

## BFS

Code_0050_BFS.java

## 拓扑排序（有向无环图）

LintCode_0127_TopologicalSorting.java

LintCode_0127_TopologicalSorting2.java

## 最小生成树，不破坏连通性删掉某些边，使得整体的权重最小

NowCoder_MinimumSpanningTree.java

### K算法 （边权值排序，并查集）（如果无向图会少一侧的情况，按情况补充即可）

最小生成树算法之Kruskal

  1）总是从权值最小的边开始考虑，依次考察权值依次变大的边

  2）当前的边要么进入最小生成树的集合，要么丢弃

  3）如果当前的边进入最小生成树的集合中不会形成环，就要当前边

  4）如果当前的边进入最小生成树的集合中会形成环，就不要当前边

  5）考察完所有边之后，最小生成树的集合也得到了

如果边数比较大的时候，K算法比较卡

### P算法

  1）可以从任意节点出发来寻找最小生成树

  2）某个点加入到被选取的点中后，解锁这个点出发的所有新的边

  3）在所有解锁的边中选最小的边，然后看看这个边会不会形成环

  4）如果会，不要当前边，继续考察剩下解锁的边中最小的边，重复3）

  5）如果不会，要当前边，将该边的指向点加入到被选取的点中，重复2）

  6）当所有点都被选取，最小生成树就得到了

## Dijkstra算法

LeetCode_0743_NetworkDelayTime.java

1）Dijkstra算法必须指定一个源点,每个边的权值均为非负数,求这个点到其他所有点的最短距离，到不了则为正无穷

2）生成一个源点到各个点的最小距离表，一开始只有一条记录，即原点到自己的最小距离为0， 源点到其他所有点的最小距离都为正无穷大

3）从距离表中拿出没拿过记录里的最小记录，通过这个点发出的边，更新源 点到各个点的最小距离表，不断重复这一步

4）源点到所有的点记录如果都被拿过一遍，过程停止，最小距离表得到了

给定出发点，出发点到所有点的距离之和最小是多少？

Dijkstra算法优化：采用手写改进堆 复习手写堆结构！！！

LeetCode 505. The Maze II

LeetCode 787. Cheapest Flights Within K Stops

LeetCode 1489. 找到最小生成树里的关键边和伪关键边

给你一个字符串类型的数组arr，譬如:
NowCoder_Folder.java
String[] arr = { "b\st", "d\", "a\d\e", "a\b\c" };
把这些路径中蕴含的目录结构给打印出来，子目录直接列在父目录下面，并比父目录向右进两格，同一级的需要按字母顺序排列不能乱。

```text
a
  b
    c
  d
    e
b
  cst
d
```

tips:
前缀树 + TreeMap + 深度优先遍历

### 单词接龙 && 单词接龙进阶

给定两个字符串，记为start和to，再给定一个字符串列表list，list中一定包含to list中没有重复字符串，所有的字符串都是小写的。
规定: start每次只能改变一个字符，最终的目标是彻底变成to，但是每次变成的新字符串必须在list 中存在。
请返回所有最短的变换路径。
【举例】
start="abc",end="cab",list={"cab","acc","cbc","ccc","cac","cbb","aab","abb"}
转换路径的方法有很多种，但所有最短的转换路径如下:
abc -> abb -> aab -> cab
abc -> abb -> cbb -> cab
abc -> cbc -> cac -> cab
abc -> cbc -> cbb -> cab

Code:
只返回变换路径是多少：LeetCode_0127_WordLadder
返回所有的变换路径：LeetCode_0126_WordLadderII

tips:
构造一个图，只改一个位置可以变到，这两个点就有一个边

构造邻居表
map -> key: string value : 邻居
这一步的复杂度：O(N^2*k) k为字符串的平均长度

构造邻居表可以加速
HashSet中有可能的所有邻居（只变动一个位置的字符）都放入进去 O(K^2) k是字符串的长度

宽度优先遍历 + 深度优先遍历
