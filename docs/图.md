# 图

## 邻接矩阵，邻接表

> 自定义图结构，以后的题目转换成自己熟悉的图结构

GraphGenerator.java

## DFS

Code_0051_DFS.java

## BFS

Code_0050_BFS.java

## 拓扑排序（有向无环图）

LintCode_0127_TopologicalSorting.java

## 最小生成树，不破坏连通性删掉某些边，使得整体的权重最小

### K算法 （边权值排序，并查集）（如果无向图会少一侧的情况，按情况补充即可）

Code_0083_K.java

### P算法

Code_0084_P.java

## Dijkstra算法

Code_0082_Dijkstra.java

LeetCode_0743_NetworkDelayTime.java

1）Dijkstra算法必须指定一个源点,每个边的权值均为非负数,求这个点到其他所有点的最短距离，到不了则为正无穷, 不能有累加和为负数的环

2）生成一个源点到各个点的最小距离表，一开始只有一条记录，即原点到自己的最小距离为0， 源点到其他所有点的最小距离都为正无穷大

3）从距离表中拿出没拿过记录里的最小记录，通过这个点发出的边，更新源 点到各个点的最小距离表，不断重复这一步

4）源点到所有的点记录如果都被拿过一遍，过程停止，最小距离表得到了

给定出发点，出发点到所有点的距离之和最小是多少？

Dijkstra算法优化：采用手写改进堆 复习手写堆结构！！！

---

LeetCode 505. The Maze II

LeetCode 787. Cheapest Flights Within K Stops

LeetCode 1489. 找到最小生成树里的关键边和伪关键边

给你一个字符串类型的数组arr，譬如:
NowCoder_Folder.java
String[] arr = { "b\st", "d\", "a\d\e", "a\b\c" };
把这些路径中蕴含的目录结构给打印出来，子目录直接列在父目录下面，并比父目录向右进两格，同一级的需要按字母顺序排列不能乱。

```text
a
  b
    c
  d
    e
b
  cst
d
```

tips:
前缀树 + TreeMap + 深度优先遍历

### 单词接龙 && 单词接龙进阶

给定两个字符串，记为start和to，再给定一个字符串列表list，list中一定包含to list中没有重复字符串，所有的字符串都是小写的。
规定: start每次只能改变一个字符，最终的目标是彻底变成to，但是每次变成的新字符串必须在list 中存在。
请返回所有最短的变换路径。
【举例】
start="abc",end="cab",list={"cab","acc","cbc","ccc","cac","cbb","aab","abb"}
转换路径的方法有很多种，但所有最短的转换路径如下:
abc -> abb -> aab -> cab
abc -> abb -> cbb -> cab
abc -> cbc -> cac -> cab
abc -> cbc -> cbb -> cab

Code:
只返回变换路径是多少：LeetCode_0127_WordLadder
返回所有的变换路径：LeetCode_0126_WordLadderII

tips:
构造一个图，只改一个位置可以变到，这两个点就有一个边

构造邻居表
map -> key: string value : 邻居
这一步的复杂度：O(N^2*k) k为字符串的平均长度

构造邻居表可以加速
HashSet中有可能的所有邻居（只变动一个位置的字符）都放入进去 O(K^2) k是字符串的长度

宽度优先遍历 + 深度优先遍历
