# 斐波那契问题和扩展

LeetCode_0509_FibonacciNumber.java

斐波那契数列的暴力解法是O(2^n)

如果某个递归，除了初始项之外，具有如下的形式
F(N) = C1 * F(N) + C2 * F(N-1) + … + Ck * F(N-k) ( C1…Ck 和k都是常数)

并且这个递归的表达式是严格的、不随条件转移的
那么都存在类似斐波那契数列的优化，时间复杂度都能优化成O(logN)
|F2,F3| * | a,b| = |F3,F4|
          | c,d|

a = 0, b,c,d = 1

eg: 

```
F(N) = 6 F(N-1) + 3 F(N-5)
-->
|Fn,Fn-1,Fn-2,Fn-3,Fn-4| = |F5,F4,F3,F2,F1|x|5x5|^(N-5)
```
如果存在条件转移，那就用不了，例如：Code06_ConvertToLetterString

某个数的N次方的logN算法
LintCode_0428_PowXN.java
N无论正负先转换成正数abs(N)，如果N是系统最小值，那么先算abs(N+1),  
LintCode_0428_PowXN.java

矩阵的乘法/N次幂:具体幂次具体写相应的公式方法，这样虽然繁琐，但是最快


第一年农场有1只成熟的母牛A，往后的每年：
1）每一只成熟的母牛都会生一只母牛
2）每一只新出生的母牛都在出生的第三年成熟
3）每一只母牛永远不会死
返回N年后牛的数量
TIPS : F(N) = F(N-1) + F(N-3) （最后F(N-3)表示三阶问题，同理，F(N) = F(N-1) + ... + F(N-K)
表示某个K阶问题
NowCoder_Cow.java
假设母牛10年后会死，表达式：
F(N) = F(N-1) + F(N-3) - F(N-10)
N年后牛的数量等于，去年牛的数量，和3年前牛的数量（因为3年后牛可以生小牛）

[TODO]
给定一个数N，想象只由0和1两种字符，组成的所有长度为N的字符串

如果某个字符串,任何0字符的左边都有1紧挨着,认为这个字符串达标

返回有多少达标的字符串
fi=fi-2 + fi-1

[TODO]
一个人可以一次往上迈1个台阶，也可以迈2个台阶

返回这个人迈上N级台阶的方法数
NowCoder_Stair



[TODO]
贴瓷砖
2*N范围
瓷砖1*2大小
F(N) = F(N-1) + F(N-2)