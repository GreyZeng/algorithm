# 二叉树的基本操作

## 前中后序遍历（递归方式，非递归方式）

笔记：https://www.cnblogs.com/greyzeng/articles/15941957.html

## 按层遍历

笔记：https://www.cnblogs.com/greyzeng/p/16356829.html

LeetCode_0102_BinaryTreeLevelOrderTraversal.java

## 某个节点的祖先节点

证明：先序遍历中，X处在第i位置，后序遍历中，X处在第j位置，[start...i-1] 与 [j + 1, end]的交集，就是且仅是X的祖先节点

## 二叉树的序列化和反序列化

- 补空节点

- 中序遍历无法序列化 比如：

```text
 1
1
 1
和
1
 1
1
```

中序遍历的结果都是`[null,1,1,1,null]`

LeetCode_0297_SerializeAndDeserializeBinaryTree.java

## 将 N 叉树编码为二叉树

LeetCode 431

LintCode_1530_EncodeNaryTreeToBinaryTree.java

## 求树的最大宽度的有效节点个数

Code_0039_TreeMaxWidth.java

## 找一个节点的后继节点

Code_0040_SuccessorNode.java

## 折痕问题

Code_0041_PaperFolding.java

---

## 求树的最大宽度

LeetCode_0662_MaximumWidthOfBinaryTree.java 注意：不是某层节点个数

## 按层遍历进阶

- LeetCode_0107_BinaryTreeLevelOrderTraversalII.java

- LeetCode_0637_AverageOfLevelsInBinaryTree.java

## 填充每个节点的下一个右侧节点指针

- LeetCode_0116_PopulatingNextRightPointersInEachNode.java

- LeetCode_0117_PopulatingNextRightPointersInEachNodeII.java

## 打印二叉树

## 二叉搜索树中查找后继节点

LintCode_0448_InorderSuccessorInBST.java

## 中序遍历+先序遍历求后序遍历

NowCoder_PreAndMidToPos.java

---

# 二叉树递归套路 O(N)

## 是否完全二叉树

LeetCode_0958_CheckCompletenessOfABinaryTree.java

## 是否为平衡二叉树

LeetCode_0110_BalancedBinaryTree.java

## 是否为搜索二叉树

LeetCode_0098_ValidateBinarySearchTree.java

## 二叉树的最大距离

边代表距离 LeetCode_0543_DiameterOfBinaryTree

节点数代表距离 Code_0042_MaxDistance

边 = 节点 - 1

## 是否为满二叉树

Code_0046_IsFull.java

## 二叉树中最大的二叉搜索子树的大小

Code_0079_MaxSubBSTSize.java

## 二叉树中最大的二叉搜索子树的头节点

Code_0043_MaxSubBSTHead.java

## 给定一棵二叉树的头节点head，和另外两个节点a和b, 返回a和b的最低公共祖先

> 常规方法：遍历二叉树，遍历的节点把父节点记录到Map中，然后找所有父节点，用Set来判断

LeetCode_0236_LowestCommonAncestorOfBinaryTree.java

## 派对最大快乐值问题

Code_0080_MaxHappy.java

---

## 给定一棵二叉搜索树的头节点head,和另外两个节点a和b，返回a和b的最低公共祖先

LeetCode_0235_LowestCommonAncestorOfABinarySearchTree.java

## 二叉树最大路径和

LeetCode_0124_BinaryTreeMaximumPathSum.java


# Morris遍历

[笔记](https://www.cnblogs.com/greyzeng/articles/15941957.html)

## 代码

Code_0047_Morris.java

## 相关习题

### 是否是搜索二叉树

中序遍历一下，如果数一直递增，说明是搜索二叉树，第二次回到自己的时候，恢复指针后，看下是否是叶子节点

LeetCode_0098_ValidateBinarySearchTree.java

### 最小高度（以叶子节点来算）

LeetCode_0111_MinimumDepthOfBinaryTree.java

tips：

morris发现当前层？

> 上一个节点是X，在第8层，下一个遍历的节点是Y，如何判断Y在第几层， 如果Y左树的最右节点是A（非X），Y必定是第9层，如果Y左树的最右节点是X，那Y在第 X层数-Y的左树的右节点的个数

morris发现叶节点？

> 第二次回到自己的时候，恢复指针后，看下是否是叶子节点, 最后要单独遍历一下左树的最右节点。

### 什么时候用二叉树的递归套路，什么时候用Morris遍历

如果你需要你的左树给你一些信息，右树给你一些信息，然后整合，这个时候就用二叉树的递归套路
如果你用完左树信息后，可以不用再管左树的信息了，那么就可以用Morris遍历

如果需要用Hash表，且题目中固定了数据的范围，这个时候可以用数组来替代Hash表

-----

给定一个二叉树的头节点head，路径的规定有以下三种不同的规定：

1）路径必须是头节点出发，到叶节点为止，返回最大路径和

LeetCode_0104_MaximumDepthOfBinaryTree.java

既可以用二叉树递归套路，也可以用morris遍历

[TODO]
给定一个二叉树的头节点head
2）路径可以从任何节点出发，但必须往下走到达任何节点，返回最大路径和

3）路径可以从任何节点出发，到任何节点，返回最大路径和
LeetCode_0124_BinaryTreeMaximumPathSum.java




