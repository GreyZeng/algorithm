## 二叉树

前中后序遍历（递归方式，非递归方式）
后序遍历：两个栈实现，一个栈实现
Morris遍历(空间复杂度O(1))
LeetCode_0144_BinaryTreePreorderTraversal
LeetCode_0094_BinaryTreeInorderTraversal
LeetCode_0145_BinaryTreePostorderTraversal

按层遍历  
 1. hash表+LinkedList
 2. 仅用LinkedList
 3. 自定义队列(空间复杂度O(1))
LeetCode_0102_BinaryTreeLevelOrderTraversal.java 
LeetCode_0107_BinaryTreeLevelOrderTraversalII.java
LeetCode_0637_AverageOfLevelsInBinaryTree.java
自定义Queue实现宽度优先遍历 （可以替换LinkedList，省空间）
LeetCode_0116_PopulatingNextRightPointersInEachNode.java 
LeetCode_0117_PopulatingNextRightPointersInEachNodeII.java

求树的最大宽度 
LeetCode_0662_MaximumWidthOfBinaryTree
Code_0039_TreeMaxWidth.java


二叉树的序列化和反序列化 
- 补空节点 
- 中序遍历无法序列化 
LeetCode_0297_SerializeAndDeserializeBinaryTree


重建二叉树 动态规划
LeetCode_0106_ConstructBinaryTreeFromInorderAndPostorderTraversal.java
LeetCode_0105_ConstructBinaryTreeFromPreorderAndInorderTraversal.java

后继节点
【特殊的树结构，包含父节点的指针】
Code_0040_SuccessorNode.java
二叉搜索树中查找后继节点
LintCode_0448_InorderSuccessorInBST.java


### 二叉树递归套路

是否为平衡二叉树
LeetCode_0110_BalancedBinaryTree
是否完全二叉树
LeetCode_0958_CheckCompletenessOfABinaryTree
是否为搜索二叉树
LeetCode_0098_ValidateBinarySearchTree
是否为满二叉树
Code_0046_IsFull.java
二叉树中最大的二叉搜索子树的大小
NowCoder_MaxSubBSTSize
二叉树中最大的二叉搜索子树的头节点
Code_0043_MaxSubBSTHead.java

给定一棵二叉树的头节点head，和另外两个节点a和b, 返回a和b的最低公共祖先
LeetCode_0236_LowestCommonAncestorOfBinaryTree.java
给定一棵二叉搜索树的头节点head,和另外两个节点a和b，返回a和b的最低公共祖先
LeetCode_0235_LowestCommonAncestorOfABinarySearchTree.java



派对最大快乐值问题
NowCoder_MaxHappy.java

二叉树的最大距离
- 边代表距离 LeetCode_0543_DiameterOfBinaryTree
- 节点数代表距离 Code_0042_MaxDistance
边 = 节点 - 1






### Morris遍历
Code_0047_Morris.java
当前是cur
1. cur无左树,cur = cur.right
2. cur有左树,找到左树最右节点mostRight
	a. mostRight的右指针指向null, mostRight.right = cur, cur = cur.right
	b. mostRight的右指针指向当前节点cur，mostRight.right = null, cur = cur.right
3. cur = null 停

Morris遍历实现前中后序遍历,空间 O（1）,时间 O（N） 递归和非递归的方式实现的复杂度是：空间：O（h）O（N）


第一次来到，则打印-> 先序遍历

打印两次的，第二次到达则打印 -> 中序遍历

最小高度（以叶子节点来算）
LeetCode_0111_MinimumDepthOfBinaryTree



是否是搜索二叉树
中序遍历一下，如果数一直递增，说明是搜索二叉树

二叉树的最小高度（二叉树的递归套路）

什么时候用二叉树的递归套路，什么时候用Morris遍历
如果你需要你的左树给你一些信息，右树给你一些信息，然后整合，这个时候就用二叉树的递归套路
如果你用完左数信息后，可以不用再管左树的信息了，那么就可以用Morris遍历

如果需要用Hash表，且题目中固定了数据的范围，这个时候用数组来替代Hash表



给定一个二叉树的头节点head，路径的规定有以下三种不同的规定：

1）路径必须是头节点出发，到叶节点为止，返回最大路径和 
LeetCode_0104_MaximumDepthOfBinaryTree.java 既可以用二叉树递归套路，也可以用morris遍历

[TODO]
给定一个二叉树的头节点head
2）路径可以从任何节点出发，但必须往下走到达任何节点，返回最大路径和

3）路径可以从任何节点出发，到任何节点，返回最大路径和
LeetCode_0124_BinaryTreeMaximumPathSum.java



完全二叉树节点的个数 ，要求复杂度低于O(N)
tips:
求总深度，左边扎到最深
右树的最左节点可以扎到最深处，则左树一定是满的
右树的最左节点不能扎到最深处，则右树一定是满的 
O(h^2) -> O((logN)^2)
LeetCode_0222_CountCompleteTreeNodes.java


已知一棵二叉树中没有重复节点，并且给定了这棵树的中序遍历数组和先序遍历 数组，返回后序遍历数组。
比如给定:
int[] pre = { 1, 2, 4, 5, 3, 6, 7 };
int[] in = { 4, 2, 5, 1, 6, 3, 7 }; 返回:
{4,5,2,6,7,3,1}
NowCoder_PreAndMidToPos.java

双向链表节点结构和二叉树节点结构是一样的，如果你把last认为是left，next认为是next的话。
给定一个搜索二叉树的头节点head，请转化成一条有序的双向链表，并返回链表的头节点。
LintCode_1534_CovertBSTToDoubleLinkedList.java

tips:
case1 中序遍历
case2 二叉树的递归套路
case3 morris遍历



给定一棵二叉树的头节点head，已知所有节点的值都不一样，返回其中最大的且符 合搜索二叉树条件的最大拓扑结构的大小。
拓扑结构：不是子树，只要能连起来的结构都算。
NowCoder_BiggestTopology.java
tips:

二叉树的递归套路，每个位置的贡献记录，左树的最右节点，右树的最左节点
复杂度 O(N)


