# 无序数组求第K大的数

## 问题描述

无序数组求第K大的数，其中K从1开始算。

例如：`[0,3,1,8,5,2]`这个数组，第2大的数是`5`

OJ可参考：[LeetCode_0215_KthLargestElementInAnArray](https://leetcode.com/problems/kth-largest-element-in-an-array/)

## 堆解法

设置一个小根堆，先把前K个数放入小根堆，对于这前K个数来说，堆顶元素一定是第K大的数，接下来的元素继续入堆，但是每入一个就弹出一个，最后，堆顶元素就是整个数组的第K大元素。代码如下：

```java
    public static int findKthLargest3(int[] nums, int k) {
        PriorityQueue<Integer> h = new PriorityQueue<>();
        int i = 0;
        // 经历这个循环，前K个数的第K大的数就是h的堆顶元素
        while (i < k) {
            h.offer(nums[i++]);
        }
        // 每次入一个，出一个，这样就保证了堆顶元素永远保持第K大的元素
        while (i < nums.length) {
            h.offer(nums[i++]);
            h.poll();
        }
        return h.peek();
    }
```

由于每次堆需要`logK`的调整代价, 所以这个解法的时间复杂度为`O(N*logK)`

## 快速排序改进

以下是快速排序的经典代码

```java

```

// TODO

## bfprt算法

## 三种解法复杂度分析

| 算法     | 时间               | 空间 |
| -------- | ------------------ | ---- |
| 堆       | O(N*logK)          | O(N) |
| 快排改进 | 概率上收敛到：O(N) | O(1) |
| bfprt    | 严格收敛到：O(N) 证明[TODO]  | O(N) |

## 相关题目

LeetCode_0004_MedianOfTwoSortedArrays

长度为N的数组arr，一定可以组成N^2个数值对。
例如arr = [3,1,2]，
数值对有(3,3) (3,1) (3,2) (1,3) (1,1) (1,2) (2,3) (2,1) (2,2)，
也就是任意两个数都有数值对，而且自己和自己也算数值对。
数值对怎么排序？规定，第一维数据从小到大，第一维数据一样的，第二维数组也从小到大。
所以上面的数值对排序的结果为：
(1,1)(1,2)(1,3)(2,1)(2,2)(2,3)(3,1)(3,2)(3,3)

给定一个数组arr，和整数k，返回第k小的数值对。
Code_0015_KMinPair.java
tips:
第一个数字定位
第二个数字定位
无序数组求第K小 bfprt和快排改进
