资源限制
1）布隆过滤器用于集合的建立与查询，并可以节省大量空间
2）一致性哈希解决数据服务器的负载管理问题
3）利用并查集结构做岛问题的并行计算
4）哈希函数可以把数据按照种类均匀分流
5）位图解决某一范围上数字的出现情况，并可以节省大量空间
6）利用分段统计思想、并进一步节省大量空间
7）利用堆、外排序来做多个处理单元的结果合并

32位无符号整数的范围是0~4,294,967,295，（0 ~ 2^32 - 1）
现在有一个正好包含40亿个无符号整数的文件，
可以使用最多1GB的内存，怎么找到出现次数最多的数？
如果使用Hash表，假设40亿个数都不一样 ，那么需要 40亿 * 8byte = 32 G

如果申请一个int数组，需要40亿*4byte = 160亿byte = 16G，内存不够
1G内存，如果用Hash表，保守估计，可以装下1千万条记录。

40亿 / 1千万 = 400

使用hash函数，将每个数的值算出一个hash值，然后用这个hash值%400 得出的结果，m做完hash再%400后是i，就把m发送到i号文件。

所以相同的数一定进入同一个文件。 400个文件，每个文件最多1千万种数，取每个文件中出现次数最多的数，就是整个文件出现次数最多的数。

推论--> 大文件 + 内存限制
大文件 做hash，再模上一个值，发送到一个机器上。进行统计

---

32位无符号整数的范围是0~4,294,967,295，
现在有一个正好包含40亿个无符号整数的文件，
所以在整个范围中必然存在没出现过的数。
可以使用最多1GB的内存，怎么找到所有未出现过的数？

如果用HashSet，大约16G，内存爆掉
使用位图
2^32 次方的bit数组，对应的内存大小是 2^32/8 （536M）  在1G内存下可以拿下，用int数组来拼bit数组。

i号bit的状态：

```java
int[] arr = new int[10];
int i = 179;
int status = (arr[i / 32] & (i << (i % 32 ))) == 0 ? 0 : 1
```



【进阶】
内存限制为 3KB，但是只用找到一个没出现过的数即可

3KB 如果用来表示int[] , 最多可以表示多长？ 
3000/4 = 750
选择一个离750最近的2的某次幂，512
申请512长度数组
使用2^32 / 512 = 8388608
分512份
int[512] 统计第一个... 第512个在每一份中出现的情况，由于总数小于2^32次方，所以导致某一份统计不够8388608
然后在不满足的条件下继续分512份。
有限几个变量怎么做？
用二分。


有一个包含100亿个URL的大文件，假设每个URL占用64B，
请找出其中所有重复的URL
如果允许失误率，就用布隆过滤器，如果不允许失误，则使用Hash函数，分到小文件思想。
【补充】
某搜索公司一天的用户搜索词汇是海量的(百亿数据量)，
请设计一种求出每天热门Top100词汇的可行办法

32位无符号整数的范围是0~4294967295，
现在有40亿个无符号整数，
可以使用最多1GB的内存，
找出所有出现了两次的数。
tips: 拿两位bit来表达一个数出现的次数

32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数
可以使用最多3KB的内存，怎么找到这40亿个整数的中位数？
tips：分段统计：512均分，区间累加到差不多20亿，就一定在这个区间中

32位无符号整数的范围是0~4294967295，
有一个10G大小的文件，每一行都装着这种类型的数字，
整个文件是无序的，给你5G的内存空间，
请你输出一个10G大小的文件，就是原文件所有数字排序的结果

tips：门槛堆（大根堆）


大文件中，次数最多的前100名
tips：hash 到小文件，统计每个文件的top3
每个文件中的内容组成大根堆，每个文件组成的大根堆堆顶再组成一个top大根堆中
top中的堆顶就是全局最大，然后弹出，看弹出的记录来自哪个文件，然后把这个文件中下一个记录加入top大根堆，再从大根堆中获取最大值，就是全局第二大的数
周而复始，凑够top k个。

