# 二叉树的基本操作

## 前中后序遍历（递归方式，非递归方式, Morris遍历）

- LeetCode_0144_BinaryTreePreorderTraversal.java

- LeetCode_0094_BinaryTreeInorderTraversal.java

- LeetCode_0145_BinaryTreePostorderTraversal.java

## 按层遍历

 1. hash表+LinkedList
 2. 仅用LinkedList
 3. 自定义Queue实现宽度优先遍历 （可以替换LinkedList，省空间）空间复杂度O(1)

- LeetCode_0102_BinaryTreeLevelOrderTraversal.java

- LeetCode_0107_BinaryTreeLevelOrderTraversalII.java

- LeetCode_0637_AverageOfLevelsInBinaryTree.java


## 填充每个节点的下一个右侧节点指针

- LeetCode_0116_PopulatingNextRightPointersInEachNode.java

- LeetCode_0117_PopulatingNextRightPointersInEachNodeII.java

## 找一个节点的后继节点

- Code_0040_SuccessorNode.java


## 二叉树的序列化和反序列化

- 补空节点
- 中序遍历无法序列化 比如：

```
 1
1
 1
和
1
 1
1
```
中序遍历的结果都是： [null,1,1,1,null]

.java

## 将 N 叉树编码为二叉树

LintCode_1530_EncodeNaryTreeToBinaryTree.java

## 打印二叉树

## 求树的最大宽度

- LeetCode_0662_MaximumWidthOfBinaryTree.java 注意：不是某层节点个数

- Code_0039_TreeMaxWidth.java

## 重建二叉树 动态规划

- LeetCode_0106_ConstructBinaryTreeFromInorderAndPostorderTraversal.java
- LeetCode_0105_ConstructBinaryTreeFromPreorderAndInorderTraversal.java



## 二叉搜索树中查找后继节点

LintCode_0448_InorderSuccessorInBST.java

## 折痕问题

Code_0041_PaperFolding