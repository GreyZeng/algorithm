# 二叉树的基本操作

## 前中后序遍历（递归方式，非递归方式, Morris遍历）

- LeetCode_0144_BinaryTreePreorderTraversal
- LeetCode_0094_BinaryTreeInorderTraversal
- LeetCode_0145_BinaryTreePostorderTraversal

## 按层遍历

 1. hash表+LinkedList
 2. 仅用LinkedList
 3. 自定义队列(空间复杂度O(1))
LeetCode_0102_BinaryTreeLevelOrderTraversal.java
LeetCode_0107_BinaryTreeLevelOrderTraversalII.java
LeetCode_0637_AverageOfLevelsInBinaryTree.java

## 自定义Queue实现宽度优先遍历 （可以替换LinkedList，省空间）

- LeetCode_0116_PopulatingNextRightPointersInEachNode.java
- LeetCode_0117_PopulatingNextRightPointersInEachNodeII.java

## 二叉树的序列化和反序列化

- 补空节点
- 中序遍历无法序列化 比如：

```
 1
1
 1
和
1
 1
1
```
中序遍历的结果都是： [null,1,1,1,null]

LeetCode_0297_SerializeAndDeserializeBinaryTree.java

## 将 N 叉树编码为二叉树 TODO

LintCode_1530_EncodeNaryTreeToBinaryTree.java

## 打印二叉树

## 求树的最大宽度

- LeetCode_0662_MaximumWidthOfBinaryTree
- Code_0039_TreeMaxWidth.java

## 重建二叉树 动态规划

- LeetCode_0106_ConstructBinaryTreeFromInorderAndPostorderTraversal.java
- LeetCode_0105_ConstructBinaryTreeFromPreorderAndInorderTraversal.java

## 后继节点

【特殊的树结构，包含父节点的指针】
Code_0040_SuccessorNode.java

## 二叉搜索树中查找后继节点

LintCode_0448_InorderSuccessorInBST.java

## 折痕问题

Code_0041_PaperFolding