[TODO]
矩形最大重合位置
矩形的遍历顺序，按底从小到大，矩形放list，重合区域必以某个底为底
遍历list的时候，如果某个矩形的上顶都比底更低，那么就可以剔除掉，
此时得到一堆矩形，这堆矩形的左边和右边抽取出来，看线段重合最多的即为答案

至少移除多少个区间后可以保证线段不重合
LeetCode_0435_NonOverlappingIntervals.java

字符串尽可能分割成多个片段，每个字符最多出现在一个片段中
LeetCode_0763_PartitionLabels

# 树状数组

[TODO]

数组在不变的情况下 前缀和数组 可以加速生成i-j位置的累加和信息

如果数组要单点修改，则以上的情况不适用

树状数组就是解决这个问题 log（N)

线段树是树状数组的升级版
 奇数
 二进制最后一位是1：则只管自己这个位置的内容
 偶数
   0010 管 0001 ~ 0010
  00100 管 00001 ~ 00100 0110 管 0101 ~ 0110

一般地 1010111000 管 1010110001 ~ 1010111000

单点更新的时候，改了某个值，要关心到底哪些位置受到了牵连

单点的二进制最末尾的1+1，依次到数组结尾，都是受到牵连的 一个数最右侧的1 ： index & (-index)  或者 index & (~index + 1)

只支持单点修改，如果多次修改，一个一个调用

index tree方便改成二维和三维的index tree

炮弹炸数组问题 考虑炸边界 + 线段树

根据数据范围选择分治策略

## 线段树和树状数组题目

[segment-tree](https://leetcode.com/tag/segment-tree/)

[binary-indexed-tree](https://leetcode.com/tag/binary-indexed-tree/)
