# 树状数组

## 要解决的问题

数组在不变的情况下，前缀和数组可以用来加速生成`i ~ j`位置的累加和信息, 假设前缀和数组为`preSum`，那么`i...j`的累加和

`sum[i...j] = preSum[j] - preSum[i-1]`

但是如果数组要单点修改，则以上的情况不适用，树状数组就是解决这个问题，时间复杂度可以达到O(logN)。

下标从1开始。

TODO 举例：1，2，3，4，5，6，7，8，9，10，11，12，13，14，15，16，17，18

如果奇数位置

  二进制最后一位是1：则只管自己这个位置的内容

如果偶数位置
  
  0010 管 0001 ~ 0010
  00100 管 00001 ~ 00100 0110 管 0101 ~ 0110

一般地 1010111000 管 1010110001 ~ 1010111000

单点更新的时候，改了某个值，要关心到底哪些位置受到了牵连



一个数最右侧的1 ： `index & (-index)  或者 index & (~index + 1)`

## i位置的前缀和

求i位置的前缀和

![image](https://img2020.cnblogs.com/blog/683206/202109/683206-20210927115016921-49141485.png)

证明 TODO

## 单点值变化，受到牵连的位置

单点的二进制最末尾的1+1，依次到数组结尾，都是受到牵连的

只支持单点修改，如果多次修改，一个一个调用

index tree方便改成二维和三维的index tree

炮弹炸数组问题 考虑炸边界 + 线段树

根据数据范围选择分治策略

## 线段树 VS 树状数组

线段树是树状数组的升级版，树状数组只能做到单点更新后，维持累加和信息的快速更新，线段树可以支持范围更新

## 代码

Code_0068_IndexTree
Code_0069_IndexTree2D

## 线段树和树状数组题目

[segment-tree](https://leetcode.com/tag/segment-tree/)

[binary-indexed-tree](https://leetcode.com/tag/binary-indexed-tree/)
