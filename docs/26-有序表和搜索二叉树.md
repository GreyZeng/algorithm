# 有序表和搜索二叉树

## 搜索二叉树

定义：**任何一个节点，左树都比这个节点小，右数都比这个节点大，经典搜索二叉树是没有重复值的，有重复值就压在一起**

构造搜索二叉树方法：

1. 比节点大，就往右边滑，滑到空就把节点加上
2. 比节点小，就往左边滑，滑到空就把节点加上

搜索二叉树的增删改，注：**改可以转换成删掉再增加**

搜索二叉树的删除流程如下

1. 未找到，直接返回
2. 如果找到，既没有左孩子，也没有右孩子，直接删掉
3. 如果找到，有右无左，右孩子提拔
4. 如果找到，有左无右，左孩子提拔
5. 如果找到，有左有右，则找右树的最左节点（后继节点）替代被删除位置，后继节点的右孩子直接给新的右树最左节点。

搜索二叉树的删除示例图如下，假设原搜索二叉树是如下结构：

![image](https://img2020.cnblogs.com/blog/683206/202110/683206-20211012215832947-318429430.png)

如果要删除60号节点，因为60号节点既没有左孩子，也没有右孩子，所以直接删除即可。

![image](https://img2020.cnblogs.com/blog/683206/202110/683206-20211012215850435-1511101976.png)

如果要删除75号节点，因为75号节点只有左孩子，所以直接用75号节点的左孩子替代被删除的75号节点位置即可。

![image](https://img2020.cnblogs.com/blog/683206/202110/683206-20211012215952597-138797449.png)

如果要删除71号节点，因为71号节点只有右孩子，所以直接用其右孩子替代即可。

![image](https://img2020.cnblogs.com/blog/683206/202110/683206-20211012220104992-1109400402.png)

如果要删除的节点是70号节点，因为70号节点既有左孩子又有右孩子，所以，首先要找到70号节点的后继节点（即71号位置）

![image](https://img2020.cnblogs.com/blog/683206/202110/683206-20211012220523665-1108744978.png)

然后用后继节点替代被删除节点的位置，同时，把后继节点的右孩子给新的右侧最左节点（即75号节点位置）

![image](https://img2020.cnblogs.com/blog/683206/202110/683206-20211012220659321-882067873.png)

注意`delete`方法在删除的时候，需要考虑后继节点是直接的右孩子还是距离需要删除的节点有一定距离的节点！

搜索二叉树的最大问题是： **输入状况决定性能，如果输入状况比较好，树是平衡的，输入状况比较差，树不是平衡的，严格的平衡性指的是：任何一个节点左树右树高度差不超过1**，比如用户输入的数据如下`[1,2,3,4,5]`，形成的搜索二叉树就退化成了如下链表结构

![image](https://img2020.cnblogs.com/blog/683206/202110/683206-20211012223724447-1144066569.png)

所以需要引入自平衡的功能， 即**平衡搜索二叉树**

## 平衡搜索二叉树

平衡搜索二叉树要满足如下两种情况

1. key按序组织
2. 增删改`O(logN)`

AVL树, SBT, 红黑树都是平衡搜索二叉树的一种具体实现，增删改的时间复杂度均为`O(logN)`

平衡搜索二叉树在搜索二叉树的基础上增加了两个操作，左旋和右旋。

左旋和右旋要针对具体节点说

左旋示例，如下搜索二叉树，如果针对A节点左旋

![image](https://img2020.cnblogs.com/blog/683206/202110/683206-20211012225823421-1221168859.png)

如下搜索二叉树，如果针对A节点右旋

![image](https://img2020.cnblogs.com/blog/683206/202110/683206-20211012230139786-1843762664.png)

AVL树，SBT，红黑树无论平衡性如何定义，**底层的操作都是左旋和右旋**。

## AVL树

AVL树最严格的平衡性，**左右高度只差绝对值小于2。**

AVL树的增删节点和平衡二叉树一样，只是在调用增删操作后，AVL树有自己的调整策略。

AVL树平衡性破坏有如下几种类型

### LL

解决办法：只做一次右旋，示例：

![image](https://img2020.cnblogs.com/blog/683206/202110/683206-20211012233352626-1371501135.png)

RR同理，只做一次左旋即可。

### LR

LR情况示例

![image](https://img2020.cnblogs.com/blog/683206/202110/683206-20211012233924897-721635223.png)

先对B进行一次左旋

![image](https://img2020.cnblogs.com/blog/683206/202110/683206-20211012233829712-1896392335.png)

再对头部A进行一次右旋

![image](https://img2020.cnblogs.com/blog/683206/202110/683206-20211012233858178-1555523049.png)

RL同理

### LL+LR

对于既是LL，又是LR的情况，例如：

![image](https://img2020.cnblogs.com/blog/683206/202110/683206-20211012234247288-635821682.png)

在这样的情况下，**一定要按照LL方式来调整。**

如上例，调整规则为：

![image](https://img2020.cnblogs.com/blog/683206/202110/683206-20211012234953526-1073705185.png)

同理，对于既是RR，又是RL的情况，**也要按照RR方式来调整。**

### AVL调整过程

在增加节点的时候，插入位置的父节点一直往上查，看下每个节点是否违规。

在删除节点的时候，删除位置的父节点一直往上查，看下每个节点是否违规，如果删除节点包含左右孩子，那么必须从这个节点的后继节点往上一直查。

### AVL实现代码

Code_0002_AVLTreeMap.java

## SBT

SBT全称Size Blanced Tree，任何一个叔节点子树节点数不少于他的侄子节点个数（叔侄关系如下示例图），即左右树节点数的规模差不多就是2倍加1

![image](https://img2020.cnblogs.com/blog/683206/202110/683206-20211014001004563-947482437.png)

AVL树维持的是每个节点的高度，**而SBT维持的是每个节点子树节点个数。**

SBT的违规情况

### SBT的LL违规和调整过程

父的左孩子的左孩子的节点个数大于父亲右孩子的节点数，例如：

![image](https://img2020.cnblogs.com/blog/683206/202110/683206-20211014001949201-1404338248.png)

所以，上述搜索二叉树在做完AVL调整后，为如下情况：

![image](https://img2020.cnblogs.com/blog/683206/202110/683206-20211014002322121-1724288941.png)

按AVL的方式调用完毕后，看谁的孩子发生了变化，如上例，是A和父两个点的孩子发生变化，就递归调用m(A), m(父)。

注：**SBT在删除节点的时候，不做平衡性调整，只在add节点的时候做平衡性调整，因为有递归行为。**

### SBT的实现代码

Code_0003_SizeBalancedTreeMap.java

## 各种有序表的性能对比

Code_0061_TreeMapTest.java

## 有序表的使用

[找工作问题_NowCoder_FindJob](https://www.nowcoder.com/questionTerminal/5e1b251c90ba4e6982cb349076ed4449)

LeetCode_0218_TheSkylineProblem.java
给定一个 N×3 的矩阵 matrix，对于每一个长度为 3 的小数组 arr，都表示一个大楼的三个数据。arr[0]表示大楼的左边界，
arr[1]表示大楼的右边界，arr[2]表示大楼的高度(一定大于 0)。 每座大楼的地基都在 X 轴上，大楼之间可能会有重叠，请返回整体的轮廓线数组。
【举例】
matrix ={{2,5,6}, {1,7,4}, {4,6,7}, {3,6,5}, {10,13,2}, {9,11,3}, {12,14,4},{10,12,5} }
返回: {{1,2,4},{2,4,6}, {4,6,7}, {6,7,4}, {9,10,3}, {10,12,5}, {12,14,4}}

tips:
最大高度的变化
开始变化的时候，最高高度开始变化，结算前一次的轮廓线
建立一组记录：
每个大楼的开始和结束点对应的最大高度
离散化处理

封装对象：
[3,7,6]  -> 3 + 6 , 7 - 6

第一个有序表 记录次数
第二个有序表 记录轮廓
为了防止纸片大楼，在排序的时候，把+放在-之前

## 需要改写有序表的问题一 TODO

LeetCode_0327_CountOfRangeSum
方法1：归并排序
方法2：改写有序表

## 需要改写有序表的题目二 TODO

有一个滑动窗口：

1）L是滑动窗口最左位置、R是滑动窗口最右位置，一开始LR都在数组左侧
2）任何一步都可能R往右动，表示某个数进了窗口
3）任何一步都可能L往右动，表示某个数出了窗口

想知道每一个窗口状态的中位数（严格中位数，如果是偶数，要返回上下中位数之和除以2）
tips：
有序表找第K小
Code_0062_SlidingWindowMedian.java

## 有序表可以改进ArrayList和LinkedList TODO

做到查询，删除，增加 都达到`O(logN)`级别

Code_0063_AddRemoveGetIndexGreat.java

## 改写有序表的题目核心点

1）分析增加什么数据项可以支持题目

2）有序表一定要保持内部参与排序的key不重复

3）增加这个数据项了，在平衡性调整时，保证这个数据项也能更新正确

4）做到上面3点，剩下就是搜索二叉树怎么实现你想要的接口的问题了
