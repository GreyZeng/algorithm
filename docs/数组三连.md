# 数组三连

## 问题1

> 给定一个正整数组成的无序数组arr，给定一个正整数值K，找到arr的所有子数组里，哪个子数组的累加和等于K，并且是长度最大的，返回其长度。

Code_0062_LongestSumSubArrayLengthInPositiveArray.java

## 问题2

> 给定一个整数组成的无序数组arr，值可能正、可能负、可能0，给定一个整数值K，找到arr的所有子数组里，哪个子数组的累加和等于K，并且是长度最大的，返回其长度

LintCode_0911_MaximumSizeSubarraySumEqualsK.java

> 给定一个整数组成的无序数组arr，值可能正、可能负、可能0，找到arr的所有子数组里，数组中1和0一样多的子数组最长的长度

LeetCode_0525_ContiguousArray.java

## 问题3

> 给定一个整数组成的无序数组arr，值可能正、可能负、可能0，给定一个整数值K，找到arr的所有子数组里，哪个子数组的累加和<=K，并且是长度最大的，返回其长度

Code_0013_LessKMaxSubArray.java

> 给定一个数组arr，给定一个值v，求子数组平均值小于等于v的最长子数组长度

Code_0092_AvgLessEqualValueLongestSubarray.java

---

[TODO]数组全为正数
 累加和为K的子数组个数
 LeetCode_0560_SubarraySumEqualsK.java
 

[TODO]
数组全为正数
累加和为K的子数组【无重复】
用动态规划
LeetCode_0039_CombinationSum.java

类似：
数组三连的第三个O(N*logN)解法
tips: 采用前缀和
[3,-1,6,-4,2,3,4]
help
[3,2,8,4,6,9, ]
help' 维持一个只升不降的数组
[3,3,8,8,8,9,]
二分查找

给定一个二维数组matrix，再给定一个k值
返回累加和小于等于k，但是离k最近的子矩阵累加和
Code_0034_MatrixSumLessOrEqualsK.java
tips:
通过压缩数组来处理

[TODO]
给定一棵二叉树的头节点head，和一个数K

路径的定义: 
可以从任何一个点开始，但是只能往下走，往下可以走到任何节点停止
返回路径累加和为K的所有路径中，最长的路径最多有几个节点？
tips:
累加和为K的最长子数组（数组三连问题）
从头节点到当前节点的前缀和 放在一个map里面，这个map只维持具体的某一条支路
存前缀和最早出现的位置



有一些排成一行的正方形。每个正方形已经被染成红色或者绿色。现在可以选择任意一个正方形然后用这两种颜色的任意一种进行染色,这个正方形的颜色将 会被覆盖。目标是在完成染色之后,每个红色R都比每个绿色G距离最左侧近。 返回最少需要涂染几个正方形。
如样例所示: s = RGRGR 我们涂染之后变成RRRGG满足要求了,涂染的个数为2,没有比这个更好的涂染方案。
tips
预处理数组
左边R的数量
左边G的数量
NowCoder_RedAndGreen.java

给定一个有序数组arr，给定一个正数aim
1）返回累加和为aim的，所有不同二元组
// leetcode 类似题目，简单一些，题目中限制了无重复元素
LeetCode_0167_TwoSumII.java
双指针
[L] + [R] > aim
[L] + [R] < aim
[L] + [R] = aim
L - 1 和 L 位置的数不等于的时候 收集答案
2）返回累加和为aim的，所有不同三元组
遍历每个位置，剩余位置 根据 找二元组的算法找出aim — [i] 的所有二元组
LeetCode_0015_3Sum.java



给定一个有序的正数数组arr和一个正数range，如果可以自由选择arr中的数字，想累加得 到 1~range 范围上所有的数，返回arr最少还缺几个数。
NowCoder_MissingNum.java
【举例】
arr = {1,2,3,7}，range = 15
想累加得到 1~15 范围上所有的数，arr 还缺 14 这个数，所以返回1
arr = {1,5,7}，range = 15
想累加得到 1~15 范围上所有的数，arr 还缺 2 和 4，所以返回2
tips:
先排序


相关习题：

LeetCode_0300_LongestIncreasingSubsequence.java
LeetCode_0334_IncreasingTripletSubsequence.java
LeetCode_0354_RussianDollEnvelopes.java



