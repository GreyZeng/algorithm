# 数组三连

## 问题1

> 给定一个正整数组成的无序数组arr，给定一个正整数值K，找到arr的所有子数组里，哪个子数组的累加和等于K，并且是长度最大的，返回其长度。

Code_0062_LongestSumSubArrayLengthInPositiveArray.java

## 问题2

> 给定一个整数组成的无序数组arr，值可能正、可能负、可能0，给定一个整数值K，找到arr的所有子数组里，哪个子数组的累加和等于K，并且是长度最大的，返回其长度

LintCode_0911_MaximumSizeSubarraySumEqualsK.java

> 给定一个整数组成的无序数组arr，值可能正、可能负、可能0，找到arr的所有子数组里，数组中1和0一样多的子数组最长的长度

LeetCode_0525_ContiguousArray.java

## 问题3

> 给定一个整数组成的无序数组arr，值可能正、可能负、可能0，给定一个整数值K，找到arr的所有子数组里，哪个子数组的累加和<=K，并且是长度最大的，返回其长度

Code_0013_LessKMaxSubArray.java

> 给定一个数组arr，给定一个值v，求子数组平均值小于等于v的最长子数组长度

Code_0092_AvgLessEqualValueLongestSubarray.java

---

[TODO]数组全为正数
 累加和为K的子数组个数
 LeetCode_0560_SubarraySumEqualsK.java
 

[TODO]
数组全为正数
累加和为K的子数组【无重复】
用动态规划
LeetCode_0039_CombinationSum.java

类似：
数组三连的第三个O(N*logN)解法
tips: 采用前缀和
[3,-1,6,-4,2,3,4]
help
[3,2,8,4,6,9, ]
help' 维持一个只升不降的数组
[3,3,8,8,8,9,]
二分查找

给定一个二维数组matrix，再给定一个k值
返回累加和小于等于k，但是离k最近的子矩阵累加和
Code_0034_MatrixSumLessOrEqualsK.java
tips:
通过压缩数组来处理

[TODO]
给定一棵二叉树的头节点head，和一个数K

路径的定义: 
可以从任何一个点开始，但是只能往下走，往下可以走到任何节点停止
返回路径累加和为K的所有路径中，最长的路径最多有几个节点？
tips:
累加和为K的最长子数组（数组三连问题）
从头节点到当前节点的前缀和 放在一个map里面，这个map只维持具体的某一条支路
存前缀和最早出现的位置



有一些排成一行的正方形。每个正方形已经被染成红色或者绿色。现在可以选择任意一个正方形然后用这两种颜色的任意一种进行染色,这个正方形的颜色将 会被覆盖。目标是在完成染色之后,每个红色R都比每个绿色G距离最左侧近。 返回最少需要涂染几个正方形。
如样例所示: s = RGRGR 我们涂染之后变成RRRGG满足要求了,涂染的个数为2,没有比这个更好的涂染方案。
tips
预处理数组
左边R的数量
左边G的数量
NowCoder_RedAndGreen.java

给定一个有序数组arr，给定一个正数aim
1）返回累加和为aim的，所有不同二元组
// leetcode 类似题目，简单一些，题目中限制了无重复元素
LeetCode_0167_TwoSumII.java
双指针
[L] + [R] > aim
[L] + [R] < aim
[L] + [R] = aim
L - 1 和 L 位置的数不等于的时候 收集答案
2）返回累加和为aim的，所有不同三元组
遍历每个位置，剩余位置 根据 找二元组的算法找出aim — [i] 的所有二元组
LeetCode_0015_3Sum.java

给定一个全是小写字母的字符串str，删除多余字符，使得每种字符只保留一个，并让 最终结果字符串的字典序最小
【举例】
str = "acbc"，删掉第一个'c'，得到"abc"，是所有结果字符串中字典序最小的。
str = "dbcacbca"，删掉第一个'b'、第一个'c'、第二个'c'、第二个'a'，得到"dabc"， 是所有结 果字符串中字典序最小的。
LeetCode_0316_RemoveDuplicateLetters.java
tips:
建立词频表，建立L和R指针，然后慢慢删除，当一个位置的词频删除到0的时候，L...R这段中要选出第一个符合的位置（ASCII码最小的那个）
删除数据可以转换为需要挑出的数据

O(K*N)

给定一个有序的正数数组arr和一个正数range，如果可以自由选择arr中的数字，想累加得 到 1~range 范围上所有的数，返回arr最少还缺几个数。
NowCoder_MissingNum.java
【举例】
arr = {1,2,3,7}，range = 15
想累加得到 1~15 范围上所有的数，arr 还缺 14 这个数，所以返回1
arr = {1,5,7}，range = 15
想累加得到 1~15 范围上所有的数，arr 还缺 2 和 4，所以返回2
tips:
先排序


二维穿过点最多的曲线问题

相关习题：

Code_0021_LIS.java
LeetCode_0300_LongestIncreasingSubsequence.java
LeetCode_0334_IncreasingTripletSubsequence.java
LeetCode_0354_RussianDollEnvelopes.java

给定一个正数数组arr，返回该数组能不能分成4个部分，并且每个部分的累加和相等，切分位置的数不要。
Code_0020_Split4Parts.java
例如:
arr=[3, 2, 4, 1, 4, 9, 5, 10, 1, 2, 2] 返回true
三个切割点下标为2, 5, 7. 切出的四个子数组为[3,2], [1,4], [5], [1,2,2]，
累加和都是5

tips:
数组长度一定要大于7
前缀和加入map中
第一刀 1 .... N - 6
第一刀确定后，第二刀的位置

